<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Royale</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Google Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            background-color: #2a623d; /* Arena green */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            display: block;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            cursor: pointer; /* This is from your working file */
            transition: background-color 0.5s ease; /* For arena theme change */
        }
        /* Arena Themes */
        canvas.arena-1 { background-color: #2a623d; } /* Added this line from your file */
        canvas.arena-2 { background-color: #6abf82; }
        canvas.arena-3 { 
            background-color: #4a4a4a;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        /* MODAL OVERLAY STYLES (Merged) */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            font-size: 1.5rem; /* Standardized font size */
            font-weight: bold;
            text-align: center;
            border-radius: 8px;
            z-index: 50;
            padding: 1.5rem;
        }
        /* OLD MODAL OVERLAYS (from your file) */
        #messageOverlay, #chestOpenOverlay, #debugPasswordOverlay {
             font-size: 2.5rem;
             padding: 1rem;
        }
        /* Make old modals use new class */
        #messageOverlay, #chestOpenOverlay, #debugPasswordOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            font-weight: bold;
            text-align: center;
            border-radius: 8px;
            z-index: 50;
        }

        /* BUTTON STYLES (Merged) */
        .modal-btn, #messageOverlay button, #chestOpenOverlay button, .login-btn, .debug-btn, #debugPasswordOverlay button {
            font-size: 1rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            margin-top: 20px;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80%;
            max-width: 300px;
        }
        
        #messageOverlay button:hover, #chestOpenOverlay button:hover, .login-btn:hover, .debug-btn:hover, #debugPasswordOverlay button:hover, .modal-btn:hover {
            background-color: #4338ca;
        }

        .login-btn.google {
            background-color: #dc2626; /* red-600 */
        }
        .login-btn.google:hover {
            background-color: #b91c1c; /* red-700 */
        }
        .login-btn.guest {
            background-color: #6b7280; /* gray-500 */
        }
        .login-btn.guest:hover {
            background-color: #4b5563; /* gray-600 */
        }
        
        /* NEW Button Colors */
        .cancel-btn { background-color: #dc2626; }
        .cancel-btn:hover { background-color: #b91c1c; }
        .confirm-btn { background-color: #16a34a; }
        .confirm-btn:hover { background-color: #15803d; }
        
        /* Debug Password Input */
        #debugPasswordInput {
            font-size: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 2px solid #6b7280;
            background-color: #1f2937;
            color: white;
            margin-top: 20px;
            width: 80%;
            max-width: 300px;
            text-align: center;
        }
        #debugPasswordOverlay .cancel-btn {
            background-color: #dc2626; /* red-600 */
        }
        #debugPasswordOverlay .cancel-btn:hover {
            background-color: #b91c1c; /* red-700 */
        }
        
        /* NEW Modal Input/Textarea Styles */
        .modal-input {
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 2px solid #6b7280;
            background-color: #1f2937;
            color: white;
            margin-top: 20px;
            width: 100%;
            max-width: 320px;
            text-align: center;
        }
        .modal-textarea {
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 2px solid #6b7280;
            background-color: #1f2937;
            color: white;
            margin-top: 1rem;
            width: 100%;
            max-width: 320px;
            height: 120px;
            resize: none;
        }

        /* Hide screens by default */
        .screen {
            display: none;
            width: 100%;
            height: 100vh;
            overflow-y: auto;
        }
        /* Show the active screen */
        .screen.active {
            display: flex;
        }
        /* Loading Screen Animation */
        @keyframes pulse-king {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .animate-pulse-king {
            animation: pulse-king 2s infinite;
        }
        /* Bottom Nav */
        #bottomNav {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            max-width: 400px;
            margin: 0 auto;
            z-index: 20;
        }
        /* Card Style */
        .card-ui {
            width: 80px;
            height: 112px;
            background-color: #4b5563; /* gray-600 */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            padding: 4px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: white;
            cursor: pointer;
            user-select: none;
            border: 4px solid #374151; /* gray-700 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            overflow: hidden;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .card-ui.selected {
            border-color: #ec4899; /* pink-500 */
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 0 20px #ec4899;
        }
        .card-ui.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(80%);
        }
        .card-ui-small {
            width: 60px;
            height: 84px;
            border-radius: 6px;
        }
        .card-ui-name {
            font-size: 0.7rem;
            background-color: rgba(0,0,0,0.6);
            padding: 0 4px;
            border-radius: 4px;
            z-index: 2;
        }
        .card-ui-emoji {
            font-size: 2.5rem;
            line-height: 1;
            z-index: 2;
        }
         .card-ui-small .card-ui-emoji {
            font-size: 2rem;
        }
        .card-ui-type {
            font-size: 0.6rem;
            color: #d1d5db; /* gray-300 */
            z-index: 2;
        }
        .card-ui-cost {
            position: absolute;
            top: 2px;
            left: 2px;
            background-color: #7e22ce;
            border: 2px solid #a855f7;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            z-index: 3;
        }
        .card-ui-level {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 0.7rem;
            font-weight: 800;
            background-color: rgba(0,0,0,0.7);
            color: #fde047; /* yellow-300 */
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }
        .card-ui-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background-color: #1f2937; /* gray-800 */
            z-index: 1;
        }
        .card-ui-progress {
            height: 100%;
            background-color: #3b82f6; /* blue-500 */
            transition: width 0.3s;
        }
        .card-ui .can-upgrade {
            background-color: #fde047; /* yellow-300 */
        }
        /* NEW: Locked Card Styles */
        .card-ui-locked {
            filter: grayscale(100%);
            opacity: 0.6;
        }
        .card-ui-locked-arena {
            position: absolute;
            bottom: 4px;
            left: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            background-color: rgba(0,0,0,0.8);
            color: #fde047;
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }


        /* Card Info Modal */
        #cardInfoModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #cardInfoModalContent {
            background-color: #374151; /* gray-700 */
            border-radius: 12px;
            padding: 1.5rem;
            width: 90%;
            max-width: 350px;
            border: 4px solid #4b5563; /* gray-600 */
            position: relative;
        }
        #cardInfoCloseBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 2rem;
            line-height: 1;
            cursor: pointer;
            color: #9ca3af; /* gray-400 */
        }
        #cardInfoStats, #towerInfoStats {
            font-size: 0.9rem;
            color: #d1d5db; /* gray-300 */
        }
        #cardInfoStats span, #towerInfoStats span {
            color: white;
            font-weight: 600;
        }
        /* Renamed .modal-btn to .modal-action-btn */
        .modal-action-btn {
            width: 100%;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 0.75rem;
            margin-top: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-action-btn.add { background-color: #16a34a; color: white; }
        .modal-action-btn.remove { background-color: #dc2626; color: white; }
        .modal-action-btn.upgrade { background-color: #16a34a; color: white; }
        .modal-action-btn:disabled {
            background-color: #6b7280; /* gray-500 */
            color: #d1d5db; /* gray-300 */
            cursor: not-allowed;
        }
        #cardInfoProgressContainer, #towerInfoProgressContainer {
            width: 100%;
            background-color: #1f2937;
            border-radius: 5px;
            height: 20px;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }
        #cardInfoProgressBar, #towerInfoProgressBar {
            height: 100%;
            background-color: #3b82f6;
        }
        #cardInfoProgressText, #towerInfoProgressText {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
        }
        /* Troop Ghost & Spell Radius */
        #placementIndicator {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 20;
            font-size: 2rem;
            opacity: 0.7;
            text-align: center;
            line-height: 1;
            transform: translate(-50%, -50%); 
        }
        #placementIndicator.spell {
            border: 4px dashed white;
            background: rgba(255, 255, 255, 0.2);
        }
        #placementIndicator.cant-place {
            background: rgba(220, 38, 38, 0.4);
            border-color: #dc2626;
        }
        /* Chest Reward Styles */
        #chestRewardList {
            font-size: 1.2rem;
            margin-top: 1rem;
        }
        #chestRewardList div {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        /* Red 'Can't Place' Overlay */
        #placementOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(220, 38, 38, 0.2),
                rgba(220, 38, 38, 0.2) 10px,
                rgba(220, 38, 38, 0.3) 10px,
                rgba(220, 38, 38, 0.3) 20px
            );
            z-index: 10;
            pointer-events: none;
            display: none;
            /* Clip-path will be set by JS */
            clip-path: path('M 0 0 L 400 0 L 400 250 L 0 250 Z'); /* Default: Top half */
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-2">
    
    <!-- 
    ========================================================
    SCREEN: LOGIN (MERGED)
    ========================================================
    -->
    <div id="loginScreen" class="screen active flex-col justify-center items-center">
        <div class="text-6xl">üëë</div>
        <h1 class="text-4xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-300">Sign in or play as guest!</p> <!-- UPDATED TEXT -->
        <p id="loginError" class="text-lg mt-2 text-red-500 font-bold h-6"></p> 
        
        <!-- NEW: Load from Key Button -->
        <button id="loadKeyBtn" class="login-btn guest">
            Enter Save Key
        </button>
        
        <!-- "Play as Guest (No Save)" button -->
        <button id="trueGuestLoginBtn" class="login-btn guest">
            Play as Guest
        </button>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: LOADING
    ========================================================
    -->
    <div id="loadingScreen" class="screen flex-col justify-center items-center bg-gray-900">
        <div class="text-8xl animate-pulse-king">üëë</div>
        <h1 class="text-3xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-300">Loading...</p>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: MENU (HOME) (MERGED)
    ========================================================
    -->
    <div id="menuScreen" class="screen flex-col items-center p-4">
        <!-- Main Content Area -->
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <!-- Header -->
            <div class="flex justify-between items-center w-full">
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="goldDisplay" class="text-xl font-bold text-yellow-400">üí∞ 500</span>
                </div>
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="trophyDisplay" class="text-xl font-bold text-blue-400">üèÜ 0</span>
                </div>
            </div>
            
            <!-- Arena Display -->
            <div class="flex flex-col items-center my-8">
                <span id="arenaEmoji" class="text-8xl">üèûÔ∏è</span>
                <h2 id="arenaName" class="text-2xl font-bold mt-2">Arena 1: Emoji Valley</h2>
            </div>
            
            <!-- Battle Button -->
            <button id="battleButton" class="bg-red-600 hover:bg-red-700 text-white w-3/4 py-4 rounded-lg shadow-lg text-3xl font-extrabold transition transform hover:scale-105">
                BATTLE!
            </button>
            
            <!-- NEW: Save Data Button -->
            <button id="saveDataKeyBtn" class="w-3/4 py-3 rounded-lg shadow-lg text-xl font-bold transition transform hover:scale-105 bg-blue-600 hover:bg-blue-700 text-white mt-4">
                Save Data
            </button>
            
            <!-- Chest Slots -->
            <div class="mt-8 w-full">
                <h3 class="text-xl font-bold text-center mb-2">Your Chests</h3>
                <div id="chestSlots" class="grid grid-cols-4 gap-2">
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                </div>
            </div>
        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-yellow-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <!-- NEW: Debug Button -->
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: DECK
    ========================================================
    -->
    <div id="deckScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 id="deckCount" class="text-2xl font-bold">Deck (0 / 8)</h1>
            <div id="deckCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Deck cards injected by JS -->
            </div>
            
            <hr class="border-gray-600 w-full my-4">
            
            <h2 class="text-2xl font-bold">Your Collection</h2>
            <div id="collectionCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Collection cards injected by JS -->
            </div>

            <!-- NEW: Locked Cards Section -->
            <hr class="border-gray-600 w-full my-4">
            <h2 class="text-2xl font-bold">Not Unlocked</h2>
            <div id="lockedCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Locked cards injected by JS -->
            </div>

        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-yellow-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: TOWER
    ========================================================
    -->
    <div id="towerScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Tower Power</h1>
            <p id="towerLevelDisplay" class="text-lg text-yellow-300 font-bold">Tower Level 1</p>
            <div class="text-8xl my-4">üëë</div>
            
            <!-- Stats -->
            <div class="bg-gray-800 p-4 rounded-lg mt-4 w-full space-y-2">
                <h3 class="text-xl font-bold text-center">Tower Stats</h3>
                <div id="towerInfoStats" class="grid grid-cols-2 gap-2">
                    <!-- Stats injected by JS -->
                </div>
            </div>
            
            <!-- Upgrade -->
            <div class="bg-gray-800 p-4 rounded-lg mt-8 w-full">
                <h3 class="text-xl font-bold text-center">Upgrade Tower</h3>
                <div id="towerInfoProgressContainer">
                    <div id="towerInfoProgressBar" style="width: 0%;"></div>
                    <div id="towerInfoProgressText">0 / 0</div>
                </div>
                <button id="towerUpgradeButton" class="modal-action-btn upgrade" disabled>
                    Upgrade
                </button>
            </div>
        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn active flex flex-col items-center text-yellow-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: DEBUG (NEW)
    ========================================================
    -->
    <div id="debugScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Debug Menu</h1>
            <p class="text-gray-400 text-center my-4">For testing only!</p>
            
            <button id="debugArena2" class="debug-btn bg-green-600 hover:bg-green-700">Jump to Arena 2 (250 üèÜ)</button>
            <button id="debugArena3" class="debug-btn bg-red-600 hover:bg-red-700">Jump to Arena 3 (500 üèÜ)</button>
            <button id="debugUnlockAll" class="debug-btn bg-blue-600 hover:bg-blue-700">Unlock All Cards</button>
            <button id="debugUpgradeAll" class="debug-btn bg-purple-600 hover:bg-purple-700">Upgrade All Cards +1 Lvl</button>
            <button id="debugGetChest" class="debug-btn bg-yellow-600 hover:bg-yellow-700">Get a Free Chest üì¶</button>
            <button id="debugAddGold" class="debug-btn bg-yellow-400 text-gray-900 hover:bg-yellow-300">Get 1000 Gold üí∞</button>
            <button id="debugReset" class="debug-btn bg-gray-600 hover:bg-gray-700">Reset Account (New User)</button>

        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn active flex flex-col items-center text-yellow-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>


    <!-- 
    ========================================================
    SCREEN: GAME
    ========================================================
    -->
    <div id="gameScreen" class="screen flex-col items-center p-2">
        <div id="gameContainer">
            <div id="timerDisplay" class="absolute top-2 left-1/2 -translate-x-1/2 text-2xl font-bold bg-black bg-opacity-50 px-4 py-1 rounded-lg z-10">2:00</div>
            <!-- NEW: Placement Overlay -->
            <div id="placementOverlay"></div>
            <canvas id="gameCanvas" width="400" height="500"></canvas>
            <div id="messageOverlay">
                <span id="messageText"></span>
                <button id="startButton" class="modal-btn confirm-btn">Start Game</button> <!-- Added classes -->
                <button id="menuButton" class="modal-btn cancel-btn">Back to Menu</button> <!-- Added classes -->
            </div>
            <!-- Placement "Ghost" Indicator -->
            <div id="placementIndicator"></div>
        </div>

        <!-- Card UI Bar -->
        <div class="bg-gray-800 p-4 shadow-inner w-full max-w-md mt-2 rounded-lg" style="padding-bottom: env(safe-area-inset-bottom, 1rem);">
            <div class="max-w-md mx-auto">
                <!-- Elixir Bar -->
                <div class="mb-4">
                    <div class="w-full bg-gray-700 rounded-full h-6 border-2 border-gray-900 shadow-inner">
                        <div id="elixirBar" class="bg-purple-500 h-full rounded-full transition-all duration-100 ease-linear text-right pr-2 font-bold" style="width: 30%;">
                            <span id="elixirText">3</span>
                        </div>
                    </div>
                </div>
                
                <!-- 4-Card Hand + Next Card -->
                <div class="flex justify-center items-end space-x-2">
                    <div class="flex flex-col items-center">
                        <span class="text-xs mb-1">NEXT</span>
                        <div id="nextCardSlot" class="card-ui-small"></div>
                    </div>
                    <div id="cardHand" class="flex justify-center space-x-2"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    CARD INFO MODAL
    ========================================================
    -->
    <div id="cardInfoModal">
        <div id="cardInfoModalContent">
            <span id="cardInfoCloseBtn">&times;</span>
            <div class="flex items-center space-x-4">
                <div id="cardInfoDisplay" class="flex-shrink-0"></div>
                <div>
                    <h2 id="cardInfoName" class="text-2xl font-bold">Card Name</h2>
                    <p id="cardInfoType" class="text-lg text-gray-400">Card Type</p>
                    <p id="cardInfoLevel" class="text-lg font-bold text-yellow-300">Level 1</p>
                </div>
            </div>
            <hr class="border-gray-500 my-4">
            <div id="cardInfoStats" class="space-y-1"></div>
            <!-- NEW: Add/Remove Button container -->
            <div id="cardInfoButtons">
                <!-- Add/Remove button injected by JS -->
            </div>
            <div id="cardInfoProgressContainer">
                <div id="cardInfoProgressBar" style="width: 0%;"></div>
                <div id="cardInfoProgressText">0 / 0</div>
            </div>
            <button id="cardInfoButton" class="modal-action-btn"></button> <!-- Class renamed -->
        </div>
    </div>
    
    <!-- 
    ========================================================
    CHEST OPENING MODAL
    ========================================================
    -->
    <div id="chestOpenOverlay">
        <h2 class="text-4xl font-bold">Chest Unlocked!</h2>
        <div class="text-7xl my-4">üì¶</div>
        <div id="chestRewardList">
            <!-- Rewards injected by JS -->
        </div>
        <button id="chestCloseButton" class="modal-btn confirm-btn">Awesome!</button> <!-- Added classes -->
    </div>

    <!-- 
    ========================================================
    DEBUG PASSWORD MODAL (NEW)
    ========================================================
    -->
    <div id="debugPasswordOverlay">
        <h2 class="text-2xl font-bold">Enter Debug Password</h2>
        <input type="password" id="debugPasswordInput" class="modal-input" placeholder="Password"> <!-- Class added -->
        <button id="debugPasswordSubmit" class="modal-btn confirm-btn">Enter</button> <!-- Added classes -->
        <button id="debugPasswordCancel" class="modal-btn cancel-btn">Cancel</button> <!-- Class added -->
    </div>

    <!-- 
    ========================================================
    NEW: SAVE KEY MODAL
    ========================================================
    -->
    <div id="saveKeyOverlay" class="modal-overlay">
        <h2 class="text-2xl font-bold">Save Your Progress</h2>
        <p class="text-sm font-normal text-gray-300 mt-2">Copy this key and save it somewhere safe! Paste it on the login screen to load your data.</p>
        <textarea id="saveKeyText" class="modal-textarea" readonly placeholder="Click 'Generate' to get your key..."></textarea>
        <button id="generateKeyBtn" class="modal-btn confirm-btn">Generate Save Key</button>
        <button id="closeSaveKeyBtn" class="modal-btn cancel-btn">Close</button>
    </div>

    <!-- 
    ========================================================
    NEW: LOAD KEY MODAL
    ========================================================
    -->
    <div id="loadKeyOverlay" class="modal-overlay">
        <h2 class="text-2xl font-bold">Load Progress</h2>
        <p class="text-sm font-normal text-gray-300 mt-2">Paste your save key below to load your data.</p>
        <textarea id="loadKeyInput" class="modal-textarea" placeholder="Paste your save key here..."></textarea>
        <button id="loadKeySubmitBtn" class="modal-btn confirm-btn">Load Data</button>
        <button id="closeLoadKeyBtn" class="modal-btn cancel-btn">Cancel</button>
    </div>


    <!-- 
    ========================================================
    MAIN SCRIPT
    ========================================================
    -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Your web app's Firebase configuration
        // MERGED: Using the real config
        const firebaseConfig = {
          apiKey: "AIzaSyCnaXKjDvPDXP2tF5ZmtB7naYjCuLGUsd4",
          authDomain: "emoji-royale-8fb68.firebaseapp.com",
          projectId: "emoji-royale-8fb68",
          storageBucket: "emoji-royale-8fb68.firebasestorage.app",
          messagingSenderId: "1021589049311",
          appId: "1:1021589049311:web:61ce6353950831e298be6a",
          measurementId: "G-FDQ9L0MQGM"
        };

        // Initialize Firebase (TRY-CATCH block for safety)
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            // setLogLevel('debug'); // Uncomment for debugging Firestore
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            // Show an error to the user on the login screen
            const loginError = document.getElementById('loginError');
            if(loginError) {
                loginError.textContent = 'Game server is offline. Please try again later.';
            }
        }
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Use __app_id
        let userDocRef; // Reference to the user's document in Firestore
        let userId; // The user's unique ID
        
        // --- Global State ---
        let currentScreen = 'login'; // Start on login screen
        let trophies = 0;
        let gold = 500;
        let trophyChests = [];
        let allCards = {};
        let cardCollection = {};
        let playerDeck = [];
        let gameDeck = [];
        let hand = [];
        let nextCard = null;
        let discardPile = [];
        let aiDeck = [];
        let aiHand = [];
        let aiNextCard = null;
        let aiDiscardPile = [];
        let towerLevel = 1;
        let towerCardCount = 0;
        // --- NEW: Level Cap at 15 ---
        const towerUpgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        const towerStats = {
            1: { kingHealth: 2000, princessHealth: 1000, damage: 50, hitSpeed: 1 },
            2: { kingHealth: 2200, princessHealth: 1100, damage: 55, hitSpeed: 1 },
            3: { kingHealth: 2420, princessHealth: 1210, damage: 60, hitSpeed: 1 },
            4: { kingHealth: 2662, princessHealth: 1331, damage: 66, hitSpeed: 1 },
            5: { kingHealth: 2928, princessHealth: 1464, damage: 72, hitSpeed: 1 },
            6: { kingHealth: 3220, princessHealth: 1610, damage: 79, hitSpeed: 1 },
            7: { kingHealth: 3542, princessHealth: 1771, damage: 87, hitSpeed: 1 },
            8: { kingHealth: 3896, princessHealth: 1948, damage: 96, hitSpeed: 1 },
            9: { kingHealth: 4285, princessHealth: 2142, damage: 105, hitSpeed: 1 },
            10: { kingHealth: 4713, princessHealth: 2356, damage: 116, hitSpeed: 1 },
            11: { kingHealth: 5184, princessHealth: 2591, damage: 128, hitSpeed: 1 },
            12: { kingHealth: 5702, princessHealth: 2850, damage: 141, hitSpeed: 1 },
            13: { kingHealth: 6272, princessHealth: 3135, damage: 155, hitSpeed: 1 },
            14: { kingHealth: 6899, princessHealth: 3448, damage: 170, hitSpeed: 1 },
            15: { kingHealth: 7589, princessHealth: 3793, damage: 187, hitSpeed: 1 },
        };

        let selectedSpawningUnit = null;
        let isSpawningSpell = false;
        let spellRadius = 0;
        let placementRadius = 0;
        let canPlace = false;
        const arenaFloors = { 0: "Arena 1: Emoji Valley", 250: "Arena 2: Laughing Village", 500: "Arena 3: Lava Town" };
        let currentArenaFloor = 0;
        let currentArenaTheme = 'arena-1'; // For canvas styling

        // --- NEW: Level Cap at 15 ---
        const upgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        let isDataSaved = false; // Flag to control saving (default to false for guest)
        let isGuestSession = false; // NEW: Flag for guest mode
        let isInitialAuthCheck = true; // Flag to stop auto-login
        let loadTimeout; // Timer for stuck loads
        let isLoading = false; // Flag to prevent double-loads
        
        // --- NEW: Drag logic state ---
        let isDragging = false; // Are we currently dragging a card?
        let startDragPos = { x: 0, y: 0 }; // Where did the drag start?
        const DRAG_SENSITIVITY = 10; // Pixels to move before it's a "drag"

        // NEW: Save key cooldown
        let saveKeyCooldown = 0;


        // --- Start Game ---
        window.onload = () => {

            // --- Game Constants ---
            const WIDTH = 400; // Define constants first
            const HEIGHT = 500;
            const RIVER_Y = HEIGHT / 2;
            const BRIDGE_Y = RIVER_Y;
            // NEW: Define spawn zone lines
            const PLAYER_SPAWN_LIMIT_Y = RIVER_Y; // Can't spawn past river
            const AI_SPAWN_LIMIT_Y = RIVER_Y;
            const PLAYER_NEW_SPAWN_LIMIT_Y = HEIGHT * 0.30; // New line after taking tower
            
            const LANE_LEFT_X = WIDTH / 4;
            const LANE_RIGHT_X = (WIDTH / 4) * 3;
            const MAX_ELIXIR = 10;
            const BASE_ELIXIR_REGEN_RATE = 0.008;
            const REGULATION_TIME = 120 * 60;
            const OVERTIME_TIME = 120 * 60;
            const TROOP_AGGRO_RANGE = 100; // NEW: Range for troops to see enemies
            const BUILDING_AGGRO_RANGE = 120; // NEW: Range for Giants to see buildings

            // --- Game State ---
            let gameObjects = [];
            let playerElixir = 3;
            let aiElixir = 3;
            let gameRunning = false;
            let gameLoopId = 0;
            let lastTime = 0;
            let aiThinkTimer = 0;
            let gameTimer = REGULATION_TIME;
            let isOvertime = false;
            let currentElixirRate = BASE_ELIXIR_REGEN_RATE;
            let isTieBreaker = false;
            let tieBreakerTick = 0;
            // NEW: Track destroyed towers for spawn zones
            let playerLeftTowerDestroyed = false;
            let playerRightTowerDestroyed = false;
            let aiLeftTowerDestroyed = false;
            let aiRightTowerDestroyed = false;

            // --- DOM Elements ---
            const screens = document.querySelectorAll('.screen');
            const navButtons = document.querySelectorAll('.nav-btn');
            const loginScreen = document.getElementById('loginScreen');
            // const googleLoginBtn = document.getElementById('googleLoginBtn'); // Removed
            const trueGuestLoginBtn = document.getElementById('trueGuestLoginBtn'); // FIXED
            const loginError = document.getElementById('loginError'); 
            const loadingScreen = document.getElementById('loadingScreen');
            const menuScreen = document.getElementById('menuScreen');
            const gameScreen = document.getElementById('gameScreen');
            const deckScreen = document.getElementById('deckScreen');
            const towerScreen = document.getElementById('towerScreen');
            const debugScreen = document.getElementById('debugScreen'); // NEW
            const battleButton = document.getElementById('battleButton');
            const trophyDisplay = document.getElementById('trophyDisplay');
            const goldDisplay = document.getElementById('goldDisplay');
            const chestSlots = document.getElementById('chestSlots');
            const arenaName = document.getElementById('arenaName');
            const arenaEmoji = document.getElementById('arenaEmoji');
            const deckCardGrid = document.getElementById('deckCardGrid');
            const collectionCardGrid = document.getElementById('collectionCardGrid');
            const lockedCardGrid = document.getElementById('lockedCardGrid'); 
            const deckCount = document.getElementById('deckCount');
            const cardHandEl = document.getElementById('cardHand');
            const nextCardSlotEl = document.getElementById('nextCardSlot');
            const placementIndicator = document.getElementById('placementIndicator');
            const placementOverlay = document.getElementById('placementOverlay'); // NEW
            const menuButton = document.getElementById('menuButton');
            const towerLevelDisplay = document.getElementById('towerLevelDisplay');
            const towerInfoStats = document.getElementById('towerInfoStats');
            const towerInfoProgressContainer = document.getElementById('towerInfoProgressContainer');
            const towerInfoProgressBar = document.getElementById('towerInfoProgressBar');
            const towerInfoProgressText = document.getElementById('towerInfoProgressText');
            const towerUpgradeButton = document.getElementById('towerUpgradeButton');
            const cardInfoModal = document.getElementById('cardInfoModal');
            const cardInfoCloseBtn = document.getElementById('cardInfoCloseBtn');
            const cardInfoDisplay = document.getElementById('cardInfoDisplay');
            const cardInfoName = document.getElementById('cardInfoName');
            const cardInfoType = document.getElementById('cardInfoType');
            const cardInfoLevel = document.getElementById('cardInfoLevel');
            const cardInfoStats = document.getElementById('cardInfoStats');
            const cardInfoButtons = document.getElementById('cardInfoButtons'); 
            const cardInfoProgressContainer = document.getElementById('cardInfoProgressContainer');
            const cardInfoProgressBar = document.getElementById('cardInfoProgressBar');
            const cardInfoProgressText = document.getElementById('cardInfoProgressText');
            const cardInfoButton = document.getElementById('cardInfoButton');
            const chestOpenOverlay = document.getElementById('chestOpenOverlay');
            const chestRewardList = document.getElementById('chestRewardList');
            const chestCloseButton = document.getElementById('chestCloseButton');
            // Debug Buttons
            const debugArena2 = document.getElementById('debugArena2');
            const debugArena3 = document.getElementById('debugArena3');
            const debugUnlockAll = document.getElementById('debugUnlockAll');
            const debugUpgradeAll = document.getElementById('debugUpgradeAll');
            const debugGetChest = document.getElementById('debugGetChest');
            const debugAddGold = document.getElementById('debugAddGold');
            const debugReset = document.getElementById('debugReset');
            // Debug Password
            const debugPasswordOverlay = document.getElementById('debugPasswordOverlay');
            const debugPasswordInput = document.getElementById('debugPasswordInput');
            const debugPasswordSubmit = document.getElementById('debugPasswordSubmit');
            const debugPasswordCancel = document.getElementById('debugPasswordCancel');
            
            // NEW: Save/Load Key Elements
            const loadKeyBtn = document.getElementById('loadKeyBtn');
            const saveDataKeyBtn = document.getElementById('saveDataKeyBtn');
            const saveKeyOverlay = document.getElementById('saveKeyOverlay');
            const saveKeyText = document.getElementById('saveKeyText');
            const generateKeyBtn = document.getElementById('generateKeyBtn');
            const closeSaveKeyBtn = document.getElementById('closeSaveKeyBtn');
            const loadKeyOverlay = document.getElementById('loadKeyOverlay');
            const loadKeyInput = document.getElementById('loadKeyInput');
            const loadKeySubmitBtn = document.getElementById('loadKeySubmitBtn');
            const closeLoadKeyBtn = document.getElementById('closeLoadKeyBtn');


            // --- Game Elements (from gameScreen) ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const elixirBar = document.getElementById('elixirBar');
            const elixirText = document.getElementById('elixirText');
            const messageOverlay = document.getElementById('messageOverlay');
            const messageText = document.getElementById('messageText');
            const startButton = document.getElementById('startButton');
            const timerDisplay = document.getElementById('timerDisplay');


            // ==============================================
            // FIREBASE & USER DATA (Simplified for Guest Mode)
            // ==============================================
            
            // NOTE: All Firebase auth logic is removed for now,
            // focusing on guest and save-key logic.
            
            function initNewUser() {
                trophies = 0;
                gold = 500;
                towerLevel = 1;
                towerCardCount = 0;
                trophyChests = [];
                cardCollection = initNewUserCards(false);
                playerDeck = initNewUserCards(true);
            }

            // "Guest (No Save)" logic
            function initGuestSession() {
                initNewUser(); // Load default data
                
                // Disable Firebase saving
                userDocRef = null; 
                userId = null;
                isDataSaved = false; // Prevent Firebase save attempts
                isGuestSession = true; // Identify as guest
            }
            
            // NEW: Get all data for save key
            function getSaveData() {
                return {
                    trophies,
                    gold,
                    towerLevel,
                    towerCardCount,
                    trophyChests,
                    cardCollection,
                    playerDeck,
                    v: 1 // Version number, in case we change format
                };
            }
            
            // NEW: Load all data from save key
            function loadSaveData(data) {
                if (!data || data.v !== 1) {
                    throw new Error("Invalid or outdated save key.");
                }
                trophies = data.trophies || 0;
                gold = data.gold || 500;
                towerLevel = data.towerLevel || 1;
                towerCardCount = data.towerCardCount || 0;
                trophyChests = data.trophyChests || [];
                cardCollection = data.cardCollection || initNewUserCards(false);
                playerDeck = data.playerDeck || initNewUserCards(true);
            }

            function initNewUserCards(deckOnly = false) {
                let newCollection = {};
                
                // Add all cards to collection with count 0 (except Arena 1)
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; 
                    newCollection[cardId] = { level: 1, count: 0 };
                }
                
                // Add Arena 1 cards with count 1
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; 
                    if (allCards[cardId].arena === 1) {
                        newCollection[cardId] = { level: 1, count: 1 };
                    }
                }
                
                if (deckOnly) {
                    return Object.keys(allCards).filter(id => allCards[id].arena === 1 && id !== 'tower');
                }
                return newCollection;
            }

            async function saveUserData() {
                // This function is now a placeholder.
                // We don't save to Firebase in guest mode.
                // The "Save Data" button will generate a key instead.
                if (!isGuestSession) {
                    console.log("Attempted to save, but not in a guest session.");
                }
            }
            
            // "Play as Guest (No Save)" button
            trueGuestLoginBtn.addEventListener('click', () => {
                loginError.textContent = ''; // Clear errors
                initGuestSession(); // Load default data, disable saving
                showScreen('loading');
                loadingScreen.querySelector('p').textContent = 'Starting Guest Game...';
                setTimeout(() => showScreen('menu'), 1000); // Short delay
            });

            // NEW: Save/Load Key Listeners
            loadKeyBtn.addEventListener('click', () => {
                loadKeyInput.value = '';
                loadKeyInput.placeholder = 'Paste your save key here...';
                loadKeyOverlay.style.display = 'flex';
            });
            closeLoadKeyBtn.addEventListener('click', () => {
                loadKeyOverlay.style.display = 'none';
            });
            loadKeySubmitBtn.addEventListener('click', () => {
                const key = loadKeyInput.value.trim();
                if (!key) return;
                try {
                    const jsonString = atob(key); // Decode Base64
                    const loadedData = JSON.parse(jsonString); // Parse JSON
                    loadSaveData(loadedData); // Load data into global state
                    
                    // Success!
                    isGuestSession = true; // We are in a guest session
                    isDataSaved = false; // Firebase saving is off
                    loadKeyOverlay.style.display = 'none';
                    showScreen('loading');
                    loadingScreen.querySelector('p').textContent = 'Loading Progress...';
                    setTimeout(() => showScreen('menu'), 1000); // Short delay

                } catch (e) {
                    console.error("Failed to load save key:", e);
                    loadKeyInput.value = '';
                    loadKeyInput.placeholder = 'Invalid key! Please try again.';
                }
            });
            
            saveDataKeyBtn.addEventListener('click', () => {
                saveKeyText.value = '';
                generateKeyBtn.disabled = saveKeyCooldown > 0;
                generateKeyBtn.textContent = saveKeyCooldown > 0 ? `Wait ${saveKeyCooldown}s` : 'Generate Save Key';
                saveKeyOverlay.style.display = 'flex';
            });
            closeSaveKeyBtn.addEventListener('click', () => {
                saveKeyOverlay.style.display = 'none';
            });
            generateKeyBtn.addEventListener('click', () => {
                if (saveKeyCooldown > 0) return;
                
                // Get all data
                const dataToSave = getSaveData();
                const jsonString = JSON.stringify(dataToSave);
                const base64String = btoa(jsonString); // Encode to Base64
                saveKeyText.value = base64String;
                
                // Start 30s cooldown
                saveKeyCooldown = 30;
                generateKeyBtn.disabled = true;
                generateKeyBtn.textContent = `Wait ${saveKeyCooldown}s`;
                
                const interval = setInterval(() => {
                    saveKeyCooldown--;
                    if (saveKeyCooldown > 0) {
                        generateKeyBtn.textContent = `Wait ${saveKeyCooldown}s`;
                    } else {
                        clearInterval(interval);
                        saveKeyCooldown = 0;
                        generateKeyBtn.disabled = false;
                        generateKeyBtn.textContent = 'Generate Save Key';
                    }
                }, 1000);
            });


            // ==============================================
            // SCREEN & NAVIGATION LOGIC
            // ==============================================
            function showScreen(screenId) {
                currentScreen = screenId;
                screens.forEach(s => { s.id === screenId + 'Screen' ? s.classList.add('active') : s.classList.remove('active'); });
                
                if (screenId === 'menu' || screenId === 'deck' || screenId === 'tower' || screenId === 'debug') {
                    navButtons.forEach(btn => { if (btn.dataset.screen === screenId) { btn.classList.add('text-yellow-400'); btn.classList.remove('text-gray-400'); } else { btn.classList.remove('text-yellow-400'); btn.classList.add('text-gray-400'); } });
                }
                
                if (screenId === 'deck') { renderDeckScreen(); }
                if (screenId === 'tower') { renderTowerScreen(); }
                if (screenId === 'menu') { updateArena(); trophyDisplay.textContent = `üèÜ ${trophies}`; goldDisplay.textContent = `üí∞ ${gold}`; renderChests(); updateBattleButtonState(); }
            }

            // NEW: Handle Debug password
            function showDebugPassword() {
                debugPasswordInput.value = '';
                debugPasswordOverlay.style.display = 'flex';
                debugPasswordInput.focus();
            }
            debugPasswordSubmit.addEventListener('click', () => {
                if (debugPasswordInput.value.toUpperCase() === 'GEOMETRIC') {
                    debugPasswordOverlay.style.display = 'none';
                    showScreen('debug');
                } else {
                    debugPasswordInput.value = '';
                    debugPasswordInput.placeholder = 'Wrong! Try again.';
                }
            });
            debugPasswordCancel.addEventListener('click', () => {
                debugPasswordOverlay.style.display = 'none';
            });


            function updateArena() {
                let currentTrophyFloor = 0;
                let arenaDisplayName = "Arena 1: Emoji Valley";
                let emoji = "üèûÔ∏è";
                currentArenaTheme = 'arena-1';
                
                for (const floor in arenaFloors) { if (trophies >= parseInt(floor)) { currentTrophyFloor = parseInt(floor); arenaDisplayName = arenaFloors[floor]; } }
                currentArenaFloor = currentTrophyFloor;
                
                if (arenaDisplayName.includes("Laughing Village")) {
                    emoji = "üèòÔ∏è";
                    currentArenaTheme = 'arena-2';
                } else if (arenaDisplayName.includes("Lava Town")) {
                    emoji = "üåã";
                    currentArenaTheme = 'arena-3';
                }
                arenaName.textContent = arenaDisplayName;
                arenaEmoji.textContent = emoji;
                canvas.className = currentArenaTheme;
            }

            function renderChests() {
                const slots = document.querySelectorAll('#chestSlots .chest-slot');
                slots.forEach((slot, index) => {
                    slot.innerHTML = '';
                    slot.onclick = null;
                    if (trophyChests[index]) {
                        slot.innerHTML = `üì¶`;
                        slot.classList.remove('text-gray-500', 'bg-gray-700');
                        slot.classList.add('bg-yellow-700', 'cursor-pointer');
                        slot.onclick = () => openChest(index);
                    } else {
                        slot.innerHTML = ``;
                        slot.classList.add('text-gray-500', 'bg-gray-700');
                        slot.classList.remove('bg-yellow-700', 'cursor-pointer');
                    }
                });
            }
            
            function openChest(index) {
                const chest = trophyChests[index];
                if (!chest) return;
                trophyChests.splice(index, 1);
                
                const rewardGold = 50 + Math.floor(Math.random() * 50);
                gold += rewardGold;
                let rewardsHTML = `<div><span class="text-3xl">üí∞</span> <span class="text-yellow-400">${rewardGold} Gold</span></div>`;
                
                const unlockedCards = getUnlockedCards(true); // Get list of cards this player *can* win
                const numCardStacks = 2 + Math.floor(Math.random() * 2);
                
                for(let i = 0; i < numCardStacks; i++) {
                    const cardId = unlockedCards[Math.floor(Math.random() * unlockedCards.length)];
                    const cardCount = 3 + Math.floor(Math.random() * 5);
                    
                    if (cardId === 'tower') {
                        towerCardCount += cardCount;
                        rewardsHTML += `<div><span class="text-3xl">üëë</span> ${cardCount}x Tower Cards</div>`;
                    } else {
                        // FIX: Ensure card exists in collection
                        if (!cardCollection[cardId]) {
                            cardCollection[cardId] = { level: 1, count: 0 };
                        }
                        cardCollection[cardId].count += cardCount;
                        rewardsHTML += `<div><span class="text-3xl">${allCards[cardId].emoji}</span> ${cardCount}x ${allCards[cardId].name}</div>`;
                    }
                }
                
                chestRewardList.innerHTML = rewardsHTML;
                chestOpenOverlay.style.display = 'flex';
                
                renderChests();
                updateArena();
                // saveUserData(); // Guest mode doesn't auto-save
            }
            chestCloseButton.addEventListener('click', () => {
                chestOpenOverlay.style.display = 'none';
            });

            navButtons.forEach(btn => { 
                btn.addEventListener('click', () => { 
                    if (btn.dataset.screen === 'debug') {
                        showDebugPassword();
                    } else {
                        showScreen(btn.dataset.screen); 
                    }
                }); 
            });
            battleButton.addEventListener('click', () => {
                if (battleButton.disabled) return;
                menuScreen.classList.remove('active');
                loadingScreen.classList.add('active');
                loadingScreen.querySelector('p').textContent = 'Finding Opponent...';
                setTimeout(() => {
                    showScreen('game');
                    messageText.textContent = 'Get Ready!';
                    startButton.style.display = 'none';
                    menuButton.style.display = 'none';
                    messageOverlay.style.display = 'flex';
                    setTimeout(() => {
                        initGame();
                        lastTime = performance.now();
                        gameLoopId = requestAnimationFrame(gameLoop);
                    }, 1500);
                }, 2000);
            });
            menuButton.addEventListener('click', () => { showScreen('menu'); gameRunning = false; cancelAnimationFrame(gameLoopId); });

            // ==============================================
            // DEBUG MENU LOGIC (NEW)
            // ==============================================
            debugArena2.addEventListener('click', () => {
                trophies = 250;
                updateArena();
                // saveUserData(); // Guest mode doesn't auto-save
                showScreen('menu');
            });
            debugArena3.addEventListener('click', () => {
                trophies = 500;
                updateArena();
                // saveUserData(); // Guest mode doesn't auto-save
                showScreen('menu');
            });
            debugUnlockAll.addEventListener('click', () => {
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue;
                    if (!cardCollection[cardId]) {
                        cardCollection[cardId] = { level: 1, count: 1 };
                    } else if (cardCollection[cardId].count === 0) {
                        cardCollection[cardId].count = 1;
                    }
                }
                // saveUserData(); // Guest mode doesn't auto-save
                console.log('All cards unlocked!');
            });
            debugUpgradeAll.addEventListener('click', () => {
                for (const cardId in cardCollection) {
                    const cardData = cardCollection[cardId];
                    if (cardData.count > 0 && cardData.level < 15) { // Only upgrade unlocked cards, cap at 15
                        cardData.level++;
                    }
                }
                if (towerLevel < 15) towerLevel++;
                // saveUserData(); // Guest mode doesn't auto-save
                console.log('All owned cards and tower upgraded +1 level!');
            });
            debugGetChest.addEventListener('click', () => {
                if (trophyChests.length < 4) {
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                    // saveUserData(); // Guest mode doesn't auto-save
                    console.log('Got a chest!');
                } else {
                    console.log('Chest slots are full!');
                }
            });
            debugAddGold.addEventListener('click', () => {
                gold += 1000;
                goldDisplay.textContent = `üí∞ ${gold}`;
                // saveUserData(); // Guest mode doesn't auto-save
                console.log('+1000 Gold!');
            });
            debugReset.addEventListener('click', () => {
                // Use a custom modal later
                if (true) { // Replaced confirm()
                    initNewUser(); // This saves
                    // saveUserData(); // Guest mode doesn't auto-save
                    showScreen('menu');
                    console.log('Account reset!');
                }
            });


            // ==============================================
            // CARD & DECK LOGIC
            // ==============================================

            function createCardDOM(cardId, isSmall = false, inHand = false) {
                const card = allCards[cardId];
                if (!card) return null;
                
                const cardData = cardCollection[cardId];
                // --- CARD LOCKING FIX ---
                const isLocked = (!cardData || cardData.count === 0) && card.arena > 1;
                
                const cardEl = document.createElement('div');
                cardEl.className = `card-ui ${isSmall ? 'card-ui-small' : ''}`;
                cardEl.dataset.unit = cardId;
                
                if (isLocked && !inHand) {
                    cardEl.classList.add('card-ui-locked');
                    cardEl.innerHTML = `
                        <div class="card-ui-cost">${card.cost}</div>
                        <span class="card-ui-name">${card.name}</span>
                        <span class="card-ui-emoji">${card.emoji}</span>
                        <span class="card-ui-type">${card.type}</span>
                        <div class="card-ui-locked-arena">Unlocks in Arena ${card.arena}</div>
                    `;
                    return cardEl;
                }

                const displayLevel = (cardData && cardData.level) ? cardData.level : 1;
                const displayCount = (cardData && cardData.count) ? cardData.count : 0;
                
                cardEl.dataset.cost = card.cost;
                cardEl.dataset.type = card.type;
                cardEl.dataset.emoji = card.emoji;
                cardEl.dataset.radius = card.placementRadius;
                if (card.radius) cardEl.dataset.spellRadius = card.radius;
                let progressBarHTML = '';
                let levelTextHTML = `<div class="card-ui-level">Lvl ${displayLevel}</div>`;
                if (!inHand) {
                    const costs = upgradeCosts[displayLevel];
                    let progress = 0;
                    let canUpgrade = false;
                    if (costs) {
                        progress = (displayCount / costs.cards) * 100;
                        if (displayCount >= costs.cards && gold >= costs.gold) { canUpgrade = true; }
                    } else { progress = 100; } // Max level
                    progressBarHTML = `<div class="card-ui-progress-bar"><div class="card-ui-progress ${canUpgrade ? 'can-upgrade' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>`;
                } else { levelTextHTML = ''; }
                cardEl.innerHTML = `<div class="card-ui-cost">${card.cost}</div><span class="card-ui-name">${card.name}</span><span class="card-ui-emoji">${card.emoji}</span><span class="card-ui-type">${card.type}</span>${levelTextHTML}${progressBarHTML}`;
                return cardEl;
            }

            function getUnlockedCards(includeTower = false, aiLevel = 0) {
                const unlocked = [];
                // Use AI level if provided, otherwise use player's trophies
                const arenaNum = aiLevel > 0 ? aiLevel : (currentArenaFloor === 0 ? 1 : (currentArenaFloor === 250 ? 2 : 3));
                
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; // FIX: Never include tower in this list
                    if (allCards[cardId].arena <= arenaNum) {
                        unlocked.push(cardId);
                    }
                }
                if (includeTower) {
                    unlocked.push('tower');
                }
                return unlocked;
            }

            function renderDeckScreen() {
                deckCardGrid.innerHTML = '';
                collectionCardGrid.innerHTML = '';
                lockedCardGrid.innerHTML = ''; 
                
                deckCount.textContent = `Deck (${playerDeck.length} / 8)`;
                
                // Render Deck
                playerDeck.forEach(cardId => { 
                    const cardEl = createCardDOM(cardId, true); 
                    cardEl.addEventListener('click', () => openCardModal(cardId)); 
                    deckCardGrid.appendChild(cardEl); 
                });
                
                // Render Collection & Locked Cards
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; // FIX: Don't show 'tower' in collection
                    
                    const cardData = cardCollection[cardId];
                    // --- CARD LOCKING FIX ---
                    const isLocked = (!cardData || cardData.count === 0) && allCards[cardId].arena > 1;
                    
                    const cardEl = createCardDOM(cardId, true);
                    cardEl.addEventListener('click', () => openCardModal(cardId));
                    
                    if (isLocked) {
                        lockedCardGrid.appendChild(cardEl);
                    } else {
                        collectionCardGrid.appendChild(cardEl);
                    }
                }
                
                updateBattleButtonState();
            }
            
            function renderTowerScreen() {
                towerLevelDisplay.textContent = `Tower Level ${towerLevel}`;
                const stats = towerStats[towerLevel] || towerStats[Object.keys(towerStats).length];
                const dps = (stats.damage / stats.hitSpeed).toFixed(1);
                
                towerInfoStats.innerHTML = `
                    <div>King Health: <span>${stats.kingHealth}</span></div>
                    <div>Princess Health: <span>${stats.princessHealth}</span></div>
                    <div>Damage: <span>${stats.damage}</span></div>
                    <div>Hit Speed: <span>${stats.hitSpeed}s</span></div>
                    <div class="col-span-2 text-center">DPS: <span>${dps}</span></div>
                `;
                
                const costs = towerUpgradeCosts[towerLevel];
                if (costs) {
                    towerInfoProgressContainer.style.display = 'block';
                    const progress = (towerCardCount / costs.cards);
                    towerInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                    towerInfoProgressText.textContent = `${towerCardCount} / ${costs.cards}`;
                    
                    const canUpgrade = towerCardCount >= costs.cards && gold >= costs.gold;
                    towerUpgradeButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                    towerUpgradeButton.disabled = !canUpgrade;
                } else {
                    towerInfoProgressContainer.style.display = 'none';
                    towerUpgradeButton.textContent = 'Max Level (15)';
                    towerUpgradeButton.disabled = true;
                }
            }
            towerUpgradeButton.addEventListener('click', () => {
                const costs = towerUpgradeCosts[towerLevel];
                if (costs && towerCardCount >= costs.cards && gold >= costs.gold) {
                    towerCardCount -= costs.cards;
                    gold -= costs.gold;
                    towerLevel++;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    renderTowerScreen();
                    // saveUserData(); // Guest mode doesn't auto-save
                }
            });


            function updateBattleButtonState() {
                if (playerDeck.length === 8) {
                    battleButton.disabled = false;
                    battleButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = 'BATTLE!';
                } else {
                    battleButton.disabled = true;
                    battleButton.classList.add('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = `Deck must have 8 cards (${playerDeck.length}/8)`;
                }
            }

            function initCardSystem() {
                allCards = {
                    // Arena 1
                    'knight': { name: 'Knight', cost: 3, emoji: '‚öîÔ∏è', type: 'Melee', unitClass: Knight, placementRadius: 12, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { health: 500, damage: 65, hitSpeed: 1.2 } } },
                    'archer': { name: 'Archer', cost: 4, emoji: 'üèπ', type: 'Ranged', unitClass: Archer, placementRadius: 10, isFlying: false, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { health: 250, damage: 40, hitSpeed: 1 } } },
                    'giant': { name: 'Giant', cost: 5, emoji: 'üí™', type: 'Tank', unitClass: Giant, placementRadius: 18, isFlying: false, arena: 1, targets: 'Buildings',
                                stats: { 1: { health: 1000, damage: 60, hitSpeed: 1.5, speed: 0.6 } } }, // Slower speed, 1000 HP
                    'goblins': { name: 'Goblins', cost: 2, emoji: 'üë∫', type: 'Swarm', unitClass: Goblins, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1 } } },
                    'skeletons': { name: 'Skeletons', cost: 1, emoji: 'üíÄ', type: 'Swarm', unitClass: Skeletons, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { count: 3, health: 50, damage: 15, hitSpeed: 1 } } },
                    'tinyBot': { name: 'Tiny Bot', cost: 4, emoji: 'ü§ñ', type: 'Melee', unitClass: TinyBot, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { health: 700, damage: 250, hitSpeed: 1.8 } } },
                    'fireball': { name: 'Fireball', cost: 4, emoji: 'üî•', type: 'Spell', radius: 50, placementRadius: 50, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 250 } } },
                    'arrows': { name: 'Arrows', cost: 3, emoji: 'üéØ', type: 'Spell', radius: 80, placementRadius: 80, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 140 } } },
                    // Arena 2
                    'hut': { name: 'Goblin House', cost: 5, emoji: 'üè†', type: 'Building', unitClass: GoblinHut, placementRadius: 20, isFlying: false, arena: 2, targets: '-',
                                stats: { 1: { health: 800, spawn_speed: '5s', lifetime: '30s' } } },
                    'skeletonArmy': { name: 'Skeleton Group', cost: 3, emoji: '‚ò†Ô∏è', type: 'Swarm', unitClass: SkeletonArmy, placementRadius: 10, isFlying: false, arena: 2, targets: 'Ground',
                                stats: { 1: { count: 15, health: 50, damage: 15, hitSpeed: 1 } } },
                    'goblinGang': { name: 'Goblin Group', cost: 3, emoji: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', type: 'Swarm', unitClass: GoblinGang, placementRadius: 10, isFlying: false, arena: 2, targets: 'Air & Ground',
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1, spear_count: 3, spear_health: 60, spear_damage: 25, spear_hitSpeed: 1.2 } } },
                    // Arena 3
                    'fireDragon': { name: 'Fire Dragon', cost: 4, emoji: 'üê≤', type: 'Air', unitClass: FireDragon, placementRadius: 12, isFlying: true, arena: 3, targets: 'Air & Ground',
                                stats: { 1: { health: 800, damage: 120, hitSpeed: 1.5, splashRadius: 25 } } },
                    'barbarians': { name: 'Barbarians', cost: 5, emoji: 'üßî', type: 'Swarm', unitClass: Barbarians, placementRadius: 10, isFlying: false, arena: 3, targets: 'Ground',
                                stats: { 1: { count: 5, health: 300, damage: 60, hitSpeed: 1.4 } } },
                    'battleRam': { name: 'Battle Ram', cost: 4, emoji: 'üå≤', type: 'WinCon', unitClass: BattleRam, placementRadius: 10, isFlying: false, arena: 3, targets: 'Buildings',
                                stats: { 1: { health: 700, damage: 200, chargeSpeed: 2.5, barbLevel: 1 } } },
                    'barbarianHut': { name: 'Barbarian House', cost: 7, emoji: 'üèòÔ∏è', type: 'Building', unitClass: BarbarianHut, placementRadius: 20, isFlying: false, arena: 3, targets: '-',
                                stats: { 1: { health: 1000, spawn_speed: '10s', lifetime: '40s', barbLevel: 1 } } },
                    'tower': { name: 'Tower Upgrade', emoji: 'üëë' }
                };
                
                // --- NEW: Auto-calculate stats for levels 2-15 ---
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue;
                    const card = allCards[cardId];
                    for (let level = 2; level <= 15; level++) { // Cap at 15
                        if (!card.stats[level]) {
                            const prevStats = card.stats[level - 1];
                            const newStats = { ...prevStats };
                            // Increase health and damage by ~10% per level
                            if (newStats.health) newStats.health = Math.round(newStats.health * 1.1);
                            if (newStats.damage) newStats.damage = Math.round(newStats.damage * 1.1);
                            // Handle sub-unit stats
                            if (newStats.spear_health) newStats.spear_health = Math.round(newStats.spear_health * 1.1);
                            if (newStats.spear_damage) newStats.spear_damage = Math.round(newStats.spear_damage * 1.1);
                            // Update levels for spawner cards
                            if (cardId === 'battleRam' || cardId === 'barbarianHut') newStats.barbLevel = level;
                            card.stats[level] = newStats;
                        }
                    }
                }
            }

            // --- ERROR FIX: Added checks for card and card.stats ---
            function openCardModal(cardId) {
                const card = allCards[cardId];
                const cardData = cardCollection[cardId];
                if (!card) return; // Exit if card invalid
                
                const isLocked = (!cardData || cardData.count === 0) && card.arena > 1;
                const displayLevel = (cardData && cardData.level) ? cardData.level : 1;
                
                // --- FIX: Check if card.stats exists ---
                const stats = card.stats ? card.stats[displayLevel] : null;

                cardInfoDisplay.innerHTML = '';
                cardInfoDisplay.appendChild(createCardDOM(cardId, false));
                cardInfoName.textContent = card.name;
                cardInfoType.textContent = card.type || 'Special'; // Fallback
                cardInfoLevel.textContent = isLocked ? "Not Unlocked" : `Level ${displayLevel}`;
                
                cardInfoStats.innerHTML = `<div>Targets: <span>${card.targets || '-'}</span></div>`;
                if (card.isFlying) cardInfoStats.innerHTML += `<div>Placement: <span>Air & Ground</span></div>`;
                
                // --- FIX: Only loop stats if stats is not null ---
                if (stats) {
                    for (const [key, value] of Object.entries(stats)) { 
                        if (key !== 'barbLevel') cardInfoStats.innerHTML += `<div>${key.charAt(0).toUpperCase() + key.slice(1).replace('_', ' ')}: <span>${value}</span></div>`; 
                    }
                    if (card.type === 'Spell') { cardInfoStats.innerHTML += `<div>Radius: <span>${card.radius}</span></div>`; }
                    if (stats.damage && stats.hitSpeed) { const dps = (stats.damage / stats.hitSpeed).toFixed(1); cardInfoStats.innerHTML += `<div>DPS: <span>${dps}</span></div>`; }
                }

                cardInfoButtons.innerHTML = '';
                cardInfoProgressContainer.style.display = 'none';
                cardInfoButton.style.display = 'none';

                // --- FIX: Also check for !stats ---
                if (isLocked || !stats) {
                    if(isLocked) cardInfoLevel.textContent = `Unlocks in Arena ${card.arena}`;
                } else {
                    // Is unlocked and has stats: Show buttons and progress
                    const isInDeck = playerDeck.includes(cardId);
                    let addRemoveBtn = document.createElement('button');
                    addRemoveBtn.id = 'addRemoveBtn';
                    if (isInDeck) {
                        addRemoveBtn.textContent = 'Remove from Deck';
                        addRemoveBtn.className = 'modal-action-btn remove'; // Class renamed
                        addRemoveBtn.disabled = false;
                        addRemoveBtn.onclick = () => removeFromDeck(cardId);
                    } else {
                        addRemoveBtn.textContent = 'Add to Deck';
                        addRemoveBtn.className = 'modal-action-btn add'; // Class renamed
                        addRemoveBtn.onclick = () => addToDeck(cardId);
                        addRemoveBtn.disabled = playerDeck.length >= 8;
                        if (playerDeck.length >= 8) addRemoveBtn.textContent = 'Deck is Full (8/8)';
                    }
                    cardInfoButtons.appendChild(addRemoveBtn);
                    cardInfoProgressContainer.style.display = 'block';
                    cardInfoButton.style.display = 'block';
                    
                    const displayCount = cardData.count || 0;
                    const costs = upgradeCosts[displayLevel];
                    
                    if (costs) {
                        const progress = (displayCount / costs.cards);
                        cardInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                        cardInfoProgressText.textContent = `${displayCount} / ${costs.cards}`;
                        const canUpgrade = displayCount >= costs.cards && gold >= costs.gold;
                        cardInfoProgressBar.classList.toggle('can-upgrade', canUpgrade);
                        cardInfoButton.className = 'modal-action-btn upgrade'; // Class renamed
                        cardInfoButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                        cardInfoButton.disabled = !canUpgrade;
                        cardInfoButton.onclick = () => upgradeCard(cardId);
                    } else {
                        // Is max level
                        cardInfoProgressContainer.style.display = 'none';
                        cardInfoButton.className = 'modal-action-btn'; // Class renamed
                        cardInfoButton.textContent = 'Max Level (15)';
                        cardInfoButton.disabled = true;
                    }
                }
                cardInfoModal.style.display = 'flex';
            }

            function closeModal() { cardInfoModal.style.display = 'none'; }
            
            async function addToDeck(cardId) {
                if (playerDeck.length < 8) {
                    playerDeck.push(cardId);
                    renderDeckScreen();
                    openCardModal(cardId);
                    // await saveUserData(); // Guest mode doesn't auto-save
                }
            }
            async function removeFromDeck(cardId) {
                const index = playerDeck.indexOf(cardId);
                if (index > -1) {
                    playerDeck.splice(index, 1);
                    renderDeckScreen();
                    openCardModal(cardId);
                    // await saveUserData(); // Guest mode doesn't auto-save
                }
            }
            async function upgradeCard(cardId) {
                const cardData = cardCollection[cardId];
                const costs = upgradeCosts[cardData.level];
                if (costs && cardData.count >= costs.cards && gold >= costs.gold) {
                    cardData.count -= costs.cards;
                    gold -= costs.gold;
                    cardData.level++;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    renderDeckScreen();
                    openCardModal(cardId);
                    // await saveUserData(); // Guest mode doesn't auto-save
                }
            }

            function shuffleDeck(deck) {
                let shuffled = [...deck]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;
            }

            function startGameDecks() {
                // Player
                gameDeck = shuffleDeck(playerDeck);
                hand = [];
                discardPile = [];
                for (let i = 0; i < 4; i++) { hand.push(gameDeck.pop()); }
                nextCard = gameDeck.pop();
                renderHand();
                
                // AI
                const aiArenaLevel = getAILevel(); // This is 1, 2, or 3
                const aiStatLevel = (aiArenaLevel === 1) ? 1 : (aiArenaLevel === 2) ? 3 : 5; // This is 1, 3, or 5
                
                // AI gets cards from its arena level, NO tower card
                const aiArenaCards = getUnlockedCards(false, aiArenaLevel);
                
                // Build a random 8-card deck
                aiDeck = [];
                let availableCards = [...aiArenaCards];
                for (let i = 0; i < 8; i++) {
                    if (availableCards.length === 0) availableCards = [...aiArenaCards]; // Refill if needed
                    let cardIndex = Math.floor(Math.random() * availableCards.length);
                    aiDeck.push(availableCards.splice(cardIndex, 1)[0]);
                }
                
                aiDeck = shuffleDeck(aiDeck);
                aiHand = [];
                aiDiscardPile = [];
                for (let i = 0; i < 4; i++) { if(aiDeck.length > 0) aiHand.push(aiDeck.pop()); }
                if(aiDeck.length > 0) aiNextCard = aiDeck.pop();
            }
            
            // NEW: AI Play Card logic uses the same cycle
            function aiPlayCard(cardId) {
                if (!allCards[cardId]) return; // Safety check
                aiElixir -= allCards[cardId].cost;
                aiDiscardPile.push(cardId);
                const handIndex = aiHand.indexOf(cardId);
                if (handIndex > -1) { aiHand.splice(handIndex, 1); }
                if (aiNextCard) { aiHand.push(aiNextCard); }
                if (aiDeck.length === 0) { aiDeck = shuffleDeck(aiDiscardPile); aiDiscardPile = []; }
                aiNextCard = aiDeck.pop() || null;
            }

            function renderHand() {
                cardHandEl.innerHTML = '';
                hand.forEach((cardId, index) => {
                    const cardEl = createCardDOM(cardId, false, true);
                    cardEl.dataset.handIndex = index;
                    // Handle touch/mouse down for card selection
                    cardEl.addEventListener('mousedown', (e) => handleCardSelect(e, cardEl, cardId));
                    cardEl.addEventListener('touchstart', (e) => handleCardSelect(e, cardEl, cardId), { passive: false });
                    cardHandEl.appendChild(cardEl);
                });
                nextCardSlotEl.innerHTML = '';
                if (nextCard) {
                    nextCardSlotEl.appendChild(createCardDOM(nextCard, true, true));
                }
                updateCardUI();
            }
            
            function cancelPlacement() {
                isSpawningSpell = false;
                placementIndicator.style.display = 'none';
                placementOverlay.style.display = 'none'; // Hide red overlay
                selectedSpawningUnit = null;
                isDragging = false;
                startDragPos = { x: 0, y: 0 };
                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                updateCardUI();
            }

            function playCard(cardId, handIndex) {
                playerElixir -= allCards[cardId].cost;
                discardPile.push(cardId);
                hand.splice(handIndex, 1);
                hand.push(nextCard);
                if (gameDeck.length === 0) { gameDeck = shuffleDeck(discardPile); discardPile = []; }
                nextCard = gameDeck.pop();
                renderHand();
            }


            // ==============================================
            // GAME OBJECTS (CLASSES)
            // ==============================================
            class GameObject {
                constructor(x, y, radius, team, health) { this.x = x; this.y = y; this.radius = radius; this.team = team; this.health = health; this.maxHealth = health; this.id = Math.random(); }
                drawHealthBar(level) { 
                    const barWidth = this.radius * 2; 
                    const barHeight = 5; 
                    const barX = this.x - this.radius; 
                    const barY = this.y - this.radius - (this instanceof Tower ? 5 : 10); // Towers' bars are closer
                    
                    if (this.health < this.maxHealth) {
                        ctx.fillStyle = '#dc2626'; 
                        ctx.fillRect(barX, barY, barWidth, barHeight); 
                        ctx.fillStyle = '#16a34a'; 
                        ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight); 
                        ctx.strokeStyle = '#000'; 
                        ctx.strokeRect(barX, barY, barWidth, barHeight); 
                    }
                    
                    // Draw Level
                    if (level) {
                        ctx.font = 'bold 10px Inter';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = this.team === 'player' ? '#fff' : '#fde047'; // Player level white, AI yellow
                        
                        let textX = this.x;
                        let textY = barY - 2; // Above health bar
                        
                        if (this instanceof Tower) {
                             textY = this.y + this.radius + 12; // Below tower
                        }
                        
                        ctx.fillText(`Lvl ${level}`, textX, textY);
                    }
                }
                draw(color, emoji, level) { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                    ctx.fillStyle = color; 
                    ctx.fill(); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.stroke(); 
                    if (emoji) { 
                        ctx.font = `${this.radius * 1.5}px Arial`; 
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle'; 
                        ctx.fillText(emoji, this.x, this.y); 
                    } 
                    this.drawHealthBar(level); 
                }
                update() {}
            }

            class Tower extends GameObject {
                constructor(x, y, team, isKing = false, level = 1) {
                    const s = towerStats[level] || towerStats[1];
                    super(x, y, isKing ? 25 : 20, team, isKing ? s.kingHealth : s.princessHealth);
                    this.isKing = isKing;
                    this.level = level; // Store level
                    this.attackRange = 150;
                    this.attackDamage = s.damage;
                    this.attackCooldown = s.hitSpeed * 60;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.isActive = isKing ? false : true; // Princess towers are active by default
                    this.activationAnimation = 0;
                    this.dyingAnimationTimer = 0;
                }
                findTarget() { 
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) { return; } 
                    this.target = null; 
                    let closestDist = this.attackRange; 
                    for (const obj of gameObjects) { 
                        if (obj.team !== this.team && (obj instanceof Unit)) { 
                            const dist = getDistance(this, obj); 
                            if (dist < closestDist) { 
                                closestDist = dist; 
                                this.target = obj; 
                            } 
                        } 
                    } 
                }
                attack() { 
                    if (this.target) { 
                        gameObjects.push(new Projectile(this.x, this.y, this.target, this.team, this.attackDamage)); 
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                update() { 
                    if (this.health <= 0) return; 
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; } 
                    
                    let kingNeedsToActivate = false;
                    if (this.isKing) { 
                        const princessTowersDown = gameObjects.filter(t => t.team === this.team && !t.isKing && t.health > 0).length === 0; 
                        if (princessTowersDown || this.health < this.maxHealth) { 
                            if (!this.isActive) { 
                                this.isActive = true; 
                                this.activationAnimation = 30; 
                            } 
                            kingNeedsToActivate = true; 
                        } 
                        if (!kingNeedsToActivate) return; 
                    } 
                    
                    // Only active towers attack
                    if (this.isActive) {
                        this.findTarget(); 
                        if (this.target && this.cooldownTimer <= 0) { this.attack(); } 
                    }
                }
                draw() { 
                    ctx.save(); 
                    if (this.dyingAnimationTimer > 0) { 
                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 
                        const shakeX = (Math.random() - 0.5) * 4; 
                        const shakeY = (Math.random() - 0.5) * 4; 
                        ctx.translate(shakeX, shakeY); 
                    } 
                    const color = this.team === 'player' ? '#3b82f6' : '#ef4444'; 
                    const emoji = this.isKing ? 'üëë' : 'üë∏'; 
                    ctx.fillStyle = color; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.font = `${this.radius * 1.5}px Arial`; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    ctx.fillText(emoji, this.x, this.y); 
                    if (this.activationAnimation > 0) { 
                        this.activationAnimation--; 
                        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 * (this.activationAnimation / 30)})`; 
                        ctx.beginPath(); 
                        ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2); 
                        ctx.fill(); 
                    } 
                    this.drawHealthBar(this.level); // Pass level to health bar
                    ctx.restore(); 
                }
            }

            class Building extends GameObject {
                constructor(x, y, team, level = 1, cardId) {
                    const s = allCards[cardId].stats[level];
                    super(x, y, 20, team, s.health);
                    this.level = level; // Store level
                    this.maxLifetime = parseFloat(s.lifetime) * 60;
                    this.lifetime = this.maxLifetime;
                    this.dyingAnimationTimer = 0;
                    this.spawnTimer = 0;
                    this.spawnRate = parseFloat(s.spawn_speed) * 60;
                    this.spawnLevel = level;
                    this.cardId = cardId;
                    this.emoji = allCards[cardId].emoji;
                }
                update() { 
                    if (this.health <= 0) return; 
                    this.lifetime--; 
                    this.health = this.maxHealth * (this.lifetime / this.maxLifetime); 
                    if (this.lifetime <= 0) { this.health = 0; return; } 
                    this.spawnTimer--; 
                    if (this.spawnTimer <= 0) {
                        let unitToSpawn = null;
                        if (this.cardId === 'hut') unitToSpawn = Goblin;
                        if (this.cardId === 'barbarianHut') unitToSpawn = Barbarian;
                        
                        if (unitToSpawn) {
                            gameObjects.push(new unitToSpawn(this.x + (Math.random()*10-5), this.y + (Math.random()*10-5), this.team, this.spawnLevel));
                        }
                        this.spawnTimer = this.spawnRate; 
                    } 
                }
                draw() { 
                    ctx.save(); 
                    if (this.dyingAnimationTimer > 0) { 
                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 
                        const shakeX = (Math.random() - 0.5) * 4; 
                        const shakeY = (Math.random() - 0.5) * 4; 
                        ctx.translate(shakeX, shakeY); 
                    } 
                    const color = this.team === 'player' ? '#3b82f6' : '#ef4444'; 
                    ctx.fillStyle = color; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.font = `${this.radius * 1.5}px Arial`; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    ctx.fillText(this.emoji, this.x, this.y); 
                    this.drawHealthBar(this.level); // Pass level
                    ctx.restore(); 
                }
            }
            class GoblinHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'hut'); } }
            class BarbarianHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'barbarianHut'); } }


            class Unit extends GameObject {
                constructor(x, y, radius, team, health, speed, attackRange, attackDamage, attackCooldown, emoji, isFlying = false, targetsAir = false, level = 1) {
                    super(x, y, radius, team, health);
                    this.level = level; // Store level
                    this.speed = speed;
                    this.attackRange = attackRange;
                    this.attackDamage = attackDamage;
                    this.attackCooldown = attackCooldown * 60;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.emoji = emoji;
                    this.isFlying = isFlying;
                    this.targetsAir = targetsAir;
                    this.targetsBuildings = false; // NEW: Default to targeting anything
                }
                
                // NEW: Smarter findTarget logic
                findTarget() {
                    // 1. If I have a valid target, check if I should switch
                    if (this.target && this.target.health > 0) {
                        const distToCurrent = getDistance(this, this.target);
                        // If I'm melee and in range, don't switch
                        if (this.attackRange <= this.radius + this.target.radius + 5 && distToCurrent <= this.attackRange) {
                            return;
                        }

                        // If I'm building-focused, stick to it unless it's dead
                        if (this.targetsBuildings) {
                            return; 
                        }

                        // Check for *closer* enemies
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit)) { // Only check for units
                                if (!this.targetsAir && obj.isFlying) continue; // Can't target air
                                
                                const distToNew = getDistance(this, obj);
                                // NEW: Only switch if new target is in range AND closer than current target
                                if (distToNew < TROOP_AGGRO_RANGE && distToNew < distToCurrent) {
                                    this.target = obj;
                                    return; // Switched to new, closer target
                                }
                            }
                        }
                        return; // Keep current target
                    }

                    // 2. If I don't have a valid target, find one
                    this.target = null;
                    let closestDist = Infinity;
                    let newTarget = null;
                    
                    // 2a. Check for units in aggro range first
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Unit)) {
                            if (!this.targetsAir && obj.isFlying) continue;
                            const dist = getDistance(this, obj);
                            if (dist < TROOP_AGGRO_RANGE && dist < closestDist) {
                                closestDist = dist;
                                newTarget = obj;
                            }
                        }
                    }
                    if (newTarget) {
                        this.target = newTarget;
                        return;
                    }

                    // 2b. If no units in range, find closest tower
                    closestDist = Infinity;
                    let closestTower = null;
                    // Find closest tower in my lane
                    const myLaneX = (this.x < WIDTH / 2) ? LANE_LEFT_X : LANE_RIGHT_X;
                    
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower)) {
                            const dist = getDistance(this, obj);
                            // Prioritize tower in the same lane
                            let laneBonus = ( (obj.x < WIDTH / 2 && myLaneX < WIDTH / 2) || (obj.x > WIDTH / 2 && myLaneX > WIDTH / 2) ) ? 0 : 50;
                            
                            if (dist + laneBonus < closestDist) {
                                closestDist = dist + laneBonus;
                                closestTower = obj;
                            }
                        }
                    }
                    if(closestTower) {
                        this.target = closestTower;
                        return;
                    }
                }
                
                move() {
                    if (!this.target) return;
                    const dist = getDistance(this, this.target);
                    if (dist <= this.attackRange) { return; }
                    let targetX = this.target.x;
                    let targetY = this.target.y;
                    if (!this.isFlying) {
                        const needsToCross = (this.team === 'player' && this.y > RIVER_Y && this.target.y < RIVER_Y) || (this.team === 'ai' && this.y < RIVER_Y && this.target.y > RIVER_Y);
                        if (needsToCross) {
                            let bridgeX = (this.x < WIDTH / 2) ? LANE_LEFT_X : LANE_RIGHT_X;
                            if(this.target.x < WIDTH / 2) bridgeX = LANE_LEFT_X;
                            else bridgeX = LANE_RIGHT_X;
                            if ( (this.team === 'player' && this.y > (RIVER_Y + 10)) || (this.team === 'ai' && this.y < (RIVER_Y - 10)) ) {
                                targetX = bridgeX;
                                targetY = BRIDGE_Y;
                            }
                        }
                    }
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                }
                attack() { 
                    if (this.target && this.cooldownTimer <= 0) { 
                        if (this.attackRange <= this.radius + this.target.radius + 5) { // Melee
                            this.target.health -= this.attackDamage; 
                        } else { // Ranged
                            let projectileType = Projectile;
                            let damage = this.attackDamage;
                            let splash = 0;
                            if (this.emoji === 'üê≤') {
                                projectileType = FireballProjectile;
                                splash = allCards['fireDragon'].stats[this.level].splashRadius;
                            }
                            gameObjects.push(new projectileType(this.x, this.y, this.target, this.team, damage, splash)); 
                        } 
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    
                    this.findTarget(); // Always check for new targets
                    
                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    } else {
                        // No target, just move towards enemy side (if not building-focused)
                        if (!this.targetsBuildings) {
                            const angle = (this.team === 'player') ? -Math.PI / 2 : Math.PI / 2;
                            this.y += Math.sin(angle) * this.speed;
                        }
                    }
                }
                draw() { const color = this.team === 'player' ? '#60a5fa' : '#f87171'; super.draw(color, this.emoji, this.level); }
            }

            class Knight extends Unit { constructor(x, y, team, level = 1) { const s = allCards['knight'].stats[level]; super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, '‚öîÔ∏è', false, false, level); } }
            class Archer extends Unit { constructor(x, y, team, level = 1) { const s = allCards['archer'].stats[level]; super(x, y, 10, team, s.health, 1.2, 120, s.damage, s.hitSpeed, 'üèπ', false, true, level); } }
            class Giant extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['giant'].stats[level];
                    super(x, y, 18, team, s.health, s.speed, 30, s.damage, s.hitSpeed, 'üí™', false, false, level);
                    this.targetsBuildings = true; // NEW: Set building-only targeting
                    this.findTarget = () => { // NEW: Override findTarget
                        // 1. If target is valid, keep it
                        if (this.target && this.target.health > 0 && (this.target instanceof Tower || this.target instanceof Building)) {
                            return;
                        }
                        
                        // 2. Find new building/tower target
                        this.target = null;
                        let closestDist = Infinity;
                        let newTarget = null;
                        
                        // Check for towers first
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower)) {
                                const dist = getDistance(this, obj);
                                if (dist < closestDist) { 
                                    closestDist = dist; 
                                    newTarget = obj; 
                                }
                            }
                        }
                        
                        // If no towers, check for other buildings
                        if (!newTarget) {
                            for (const obj of gameObjects) {
                                if (obj.team !== this.team && (obj instanceof Building)) {
                                    const dist = getDistance(this, obj);
                                    if (dist < closestDist) { 
                                        closestDist = dist; 
                                        newTarget = obj; 
                                    }
                                }
                            }
                        }
                        
                        this.target = newTarget;
                    };
                }
            }
            class Goblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; super(x, y, 8, team, s.health, 1.5, 20, s.damage, s.hitSpeed, 'üë∫', false, false, level); } }
            class Skeleton extends Unit { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; super(x, y, 7, team, s.health, 1.6, 20, s.damage, s.hitSpeed, 'üíÄ', false, false, level); } }
            class TinyBot extends Unit { constructor(x, y, team, level = 1) { const s = allCards['tinyBot'].stats[level]; super(x, y, 10, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'ü§ñ', false, false, level); } }
            class Goblins { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class Skeletons { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            
            // --- NEW CARD CLASSES ---
            class SpearGoblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; super(x, y, 8, team, s.spear_health, 1.5, 100, s.spear_damage, s.spear_hitSpeed, 'üéØ', false, true, level); } }
            class GoblinGang { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } for (let i = 0; i < s.spear_count; i++) { gameObjects.push(new SpearGoblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } } }
            class SkeletonArmy { constructor(x, y, team, level = 1) { const s = allCards['skeletonArmy'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*30-15, y + Math.random()*30-15, team, level)); } } }
            class Barbarian extends Unit { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; super(x, y, 11, team, s.health, 1.1, 25, s.damage, s.hitSpeed, 'üßî', false, false, level); } }
            class Barbarians { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Barbarian(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class FireDragon extends Unit { constructor(x, y, team, level = 1) { const s = allCards['fireDragon'].stats[level]; super(x, y, 14, team, s.health, 1.2, 110, s.damage, s.hitSpeed, 'üê≤', true, true, level); } }
            class BattleRam extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['battleRam'].stats[level];
                    super(x, y, 15, team, s.health, 1.2, 25, s.damage, 1, 'üå≤', false, false, level);
                    this.barbLevel = s.barbLevel;
                    this.chargeTimer = 3 * 60;
                    this.isCharging = false;
                    this.didHit = false; // Flag to prevent double spawns
                    this.targetsBuildings = true; // NEW: Set building-only targeting
                    this.findTarget = () => { // NEW: Override findTarget (same as Giant)
                        if (this.target && this.target.health > 0 && (this.target instanceof Tower || this.target instanceof Building)) return;
                        this.target = null;
                        let closestDist = Infinity;
                        let newTarget = null;
                        for (const obj of gameObjects) { if (obj.team !== this.team && (obj instanceof Tower)) { const dist = getDistance(this, obj); if (dist < closestDist) { closestDist = dist; newTarget = obj; } } }
                        if (!newTarget) { for (const obj of gameObjects) { if (obj.team !== this.team && (obj instanceof Building)) { const dist = getDistance(this, obj); if (dist < closestDist) { closestDist = dist; newTarget = obj; } } } }
                        this.target = newTarget;
                    };
                }
                
                spawnBarbs() {
                    if (this.didHit) return; // Don't spawn twice
                    this.didHit = true;
                    gameObjects.push(new Barbarian(this.x + 5, this.y, this.team, this.barbLevel));
                    gameObjects.push(new Barbarian(this.x - 5, this.y, this.team, this.barbLevel));
                    this.health = 0; // Ram is destroyed
                }

                update() {
                    if (this.health <= 0 && !this.didHit) {
                        this.spawnBarbs(); // Spawn if killed by damage
                        return;
                    }
                    if (this.didHit) return; // Already spawned, do nothing
                    
                    if (this.chargeTimer > 0) { this.chargeTimer--; if(this.chargeTimer === 0) this.isCharging = true; }
                    if (this.isCharging) this.speed = 2.4; else this.speed = 1.2;
                    super.update(); // Run the base Unit's update (which calls findTarget, move, attack)
                }
                attack() { // Ram only attacks when it hits
                    if (this.target && this.cooldownTimer <= 0) { 
                        this.target.health -= this.attackDamage;
                        this.spawnBarbs(); // Spawn on hit
                    } 
                }
            }

            class Projectile extends GameObject {
                constructor(x, y, target, team, damage, splashRadius = 0) { 
                    super(x, y, 4, team, 1); 
                    this.target = target; 
                    this.damage = damage; 
                    this.speed = 5; 
                    this.splashRadius = splashRadius;
                }
                update() { 
                    if (!this.target || this.target.health <= 0) { this.health = 0; return; } 
                    const dist = getDistance(this, this.target); 
                    if (dist < this.speed) { 
                        // Hit target
                        this.target.health -= this.damage; 
                        
                        // Handle splash
                        if (this.splashRadius > 0) {
                            for (const obj of gameObjects) {
                                if (obj.team !== this.team && obj !== this.target && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                    if (getDistance(this.target, obj) < this.splashRadius) {
                                        obj.health -= this.damage; // Splash does full damage
                                    }
                                }
                            }
                        }
                        
                        this.health = 0; 
                        return; 
                    } 
                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); 
                    this.x += Math.cos(angle) * this.speed; 
                    this.y += Math.sin(angle) * this.speed; 
                }
                draw() { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                    ctx.fillStyle = this.team === 'player' ? '#a5f3fc' : '#fecaca'; 
                    ctx.fill(); 
                }
            }
            
            class FireballProjectile extends Projectile {
                draw() { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2); 
                    ctx.fillStyle = this.team === 'player' ? '#ffc107' : '#ff6f00'; 
                    ctx.fill(); 
                }
            }

            class Spell extends GameObject {
                constructor(x, y, team, damage, radius, emoji) {
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.animationTimer = 30;
                    this.maxAnimationTimer = 30;
                    this.hit = false;
                    this.emoji = emoji;
                }
                update() {
                    if (!this.hit) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    obj.health -= this.damage;
                                }
                            }
                        }
                        this.hit = true;
                    }
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / this.maxAnimationTimer;
                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;
                    if (this.emoji === 'üéØ') {
                        ctx.fillStyle = `rgba(139, 69, 19, ${alpha * 0.2})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `20px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = `rgba(101, 67, 33, ${alpha})`;
                        let yOffset = -this.radius + (this.radius * 2 * (1 - progress));
                        ctx.globalAlpha = alpha;
                        ctx.fillText('‚¨áÔ∏è', this.x - 20, this.y - 20 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x + 20, this.y - 10 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x, this.y + 20 + yOffset);
                        ctx.globalAlpha = 1;
                    } else if (this.emoji === 'üî•') {
                        ctx.fillStyle = `rgba(253, 224, 71, ${alpha * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `${this.radius * 2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.globalAlpha = alpha;
                        ctx.fillText(this.emoji, this.x, this.y);
                        ctx.globalAlpha = 1;
                    }
                }
            }


            // ==============================================
            // GAME LOGIC
            // ==============================================
            
            function getDistance(obj1, obj2) {
                const dx = obj1.x - obj2.x; const dy = obj1.y - obj2.y; return Math.sqrt(dx * dx + dy * dy);
            }

            function drawArena() {
                // River
                if (currentArenaTheme === 'arena-3') {
                    ctx.fillStyle = '#f45d22'; // Lava
                } else if (currentArenaTheme === 'arena-2') {
                    ctx.fillStyle = '#4a90e2'; // Lighter blue
                } else {
                    ctx.fillStyle = '#3b82f6'; // Default blue
                }
                ctx.fillRect(0, RIVER_Y - 10, WIDTH, 20);
                
                // Bridges
                ctx.fillStyle = '#a16207'; // Brown
                ctx.fillRect(LANE_LEFT_X - 25, RIVER_Y - 15, 50, 30);
                ctx.fillRect(LANE_RIGHT_X - 25, RIVER_Y - 15, 50, 30);
            }

            function getAILevel() {
                if (trophies > 500) return 3; if (trophies > 250) return 2; return 1;
            }

            function initGame() {
                gameObjects = [];
                playerElixir = 3;
                aiElixir = 3;
                selectedSpawningUnit = null;
                isSpawningSpell = false;
                gameRunning = true;
                aiThinkTimer = 0;
                gameTimer = REGULATION_TIME;
                isOvertime = false;
                isTieBreaker = false;
                tieBreakerTick = 0;
                
                // Reset spawn zones
                playerLeftTowerDestroyed = false;
                playerRightTowerDestroyed = false;
                aiLeftTowerDestroyed = false;
                aiRightTowerDestroyed = false;
                updatePlacementOverlay();
                
                messageOverlay.style.display = 'none';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';

                const aiArenaLevel = getAILevel();
                const aiStatLevel = (aiArenaLevel === 1) ? 1 : (aiArenaLevel === 2) ? 3 : 5;
                
                gameObjects.push(new Tower(LANE_LEFT_X, HEIGHT - 100, 'player', false, towerLevel));
                gameObjects.push(new Tower(LANE_RIGHT_X, HEIGHT - 100, 'player', false, towerLevel));
                gameObjects.push(new Tower(WIDTH / 2, HEIGHT - 50, 'player', true, towerLevel));
                gameObjects.push(new Tower(LANE_LEFT_X, 100, 'ai', false, aiStatLevel));
                gameObjects.push(new Tower(LANE_RIGHT_X, 100, 'ai', false, aiStatLevel));
                gameObjects.push(new Tower(WIDTH / 2, 50, 'ai', true, aiStatLevel));

                startGameDecks();
                updateCardUI();
            }

            function runAI() {
                const aiArenaLevel = getAILevel();
                const aiStatLevel = (aiArenaLevel === 1) ? 1 : (aiArenaLevel === 2) ? 3 : 5;
                
                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit && o.y < RIVER_Y + 50);
                if (playerUnits.length > 0) {
                    let bestCardId = null;
                    if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy) && aiHand.includes('arrows') && aiElixir >= allCards['arrows'].cost) {
                        bestCardId = 'arrows';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) {
                        bestCardId = 'tinyBot';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('barbarians') && aiElixir >= allCards['barbarians'].cost) {
                        bestCardId = 'barbarians';
                    } else if (playerUnits.some(u => u instanceof FireDragon) && aiHand.includes('archer') && aiElixir >= allCards['archer'].cost) {
                        bestCardId = 'archer';
                    } else if (aiHand.includes('goblins') && aiElixir >= allCards['goblins'].cost) {
                        bestCardId = 'goblins';
                    }
                    if (bestCardId) { spawnAIUnit(bestCardId, aiStatLevel, true); return; }
                }
                
                // Fallback: If elixir is high, play a card
                if (aiElixir > 7) {
                    let bestCardId = null;
                    if(aiHand.includes('giant') && aiElixir >= allCards['giant'].cost) { bestCardId = 'giant'; }
                    else if(aiHand.includes('barbarianHut') && aiElixir >= allCards['barbarianHut'].cost) { bestCardId = 'barbarianHut'; }
                    else if (aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) { bestCardId = 'tinyBot'; }
                    else {
                        // Play any random affordable unit
                        let affordableCards = aiHand.filter(id => allCards[id] && allCards[id].cost <= aiElixir && allCards[id].type !== 'Spell');
                        if (affordableCards.length > 0) {
                            bestCardId = affordableCards[Math.floor(Math.random() * affordableCards.length)];
                        }
                    }
                    if (bestCardId) { spawnAIUnit(bestCardId, aiStatLevel, false); return; }
                }

                if (aiElixir === MAX_ELIXIR && aiHand.includes('fireball') && Math.random() < 0.2) {
                    spawnAIUnit('fireball', aiStatLevel, false);
                    return;
                }
            }

            function spawnAIUnit(cardId, level, isDefensive = false) {
                const card = allCards[cardId];
                if (!card || card.cost > aiElixir) return;
                
                // Get AI's level for this card (currently just 'level')
                const cardLevel = level;
                
                if (card.type === 'Spell') {
                    let target = null;
                    const damage = card.stats[cardLevel].damage;
                    if (cardId === 'fireball') {
                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0 && o.health < 600);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Barbarian);
                    } else if (cardId === 'arrows') {
                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Skeleton || o instanceof SkeletonArmy || o instanceof GoblinGang));
                    }
                    if (target) {
                        gameObjects.push(new Spell(target.x, target.y, 'ai', damage, card.radius, card.emoji));
                        aiPlayCard(cardId);
                    }
                    return;
                }
                
                // Determine spawn Y
                let spawnY;
                if (isDefensive) {
                    // Spawn behind princess towers
                    spawnY = 150 + Math.random() * 50;
                } else {
                    // Spawn at the back
                    spawnY = 50 + Math.random() * 50;
                }
                
                // Determine spawn X (which lane)
                const spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;
                
                // Check if spawn is valid (not on top of another building)
                let canSpawn = true;
                if (card.type === 'Building') {
                    for (const obj of gameObjects) {
                        if (obj instanceof Tower || obj instanceof Building) {
                            const dist = getDistance({x: spawnX, y: spawnY}, obj);
                            if (dist < card.placementRadius + obj.radius) { 
                                canSpawn = false; 
                                break; 
                            }
                        }
                    }
                }
                
                if (canSpawn && card.unitClass) {
                    const newUnit = new card.unitClass(spawnX, spawnY, 'ai', cardLevel);
                    if (!card.type.includes('Swarm') && !card.type.includes('Building')) {
                        gameObjects.push(newUnit);
                    }
                    aiPlayCard(cardId);
                }
            }

            function updateCardUI() {
                const elixirInt = Math.floor(playerElixir);
                elixirBar.style.width = `${(playerElixir / MAX_ELIXIR) * 100}%`;
                elixirText.textContent = elixirInt;
                document.querySelectorAll('#cardHand .card-ui').forEach(cardEl => {
                    const cost = parseInt(cardEl.dataset.cost);
                    if (cost > elixirInt) { cardEl.classList.add('disabled'); }
                    else { cardEl.classList.remove('disabled'); }
                });
            }

            function updateTimerAndElixir() {
                const totalSeconds = Math.max(0, Math.floor(gameTimer / 60));
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                if (isOvertime) {
                    timerDisplay.classList.add('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 3 : BASE_ELIXIR_REGEN_RATE * 2;
                } else {
                    timerDisplay.classList.remove('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 2 : BASE_ELIXIR_REGEN_RATE;
                }
                if (playerElixir < MAX_ELIXIR) {
                    playerElixir += currentElixirRate;
                    playerElixir = Math.min(playerElixir, MAX_ELIXIR);
                }
                if (aiElixir < MAX_ELIXIR) {
                    aiElixir += currentElixirRate;
                    aiElixir = Math.min(aiElixir, MAX_ELIXIR);
                }
            }
            
            // NEW: Update function to check tower status
            function checkTowerStatus() {
                const aiLeft = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x < WIDTH / 2);
                const aiRight = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x > WIDTH / 2);
                
                if (aiLeft && aiLeft.health <= 0 && !aiLeftTowerDestroyed) {
                    aiLeftTowerDestroyed = true;
                    if(selectedSpawningUnit) updatePlacementOverlay(); // Update overlay if card is selected
                }
                if (aiRight && aiRight.health <= 0 && !aiRightTowerDestroyed) {
                    aiRightTowerDestroyed = true;
                    if(selectedSpawningUnit) updatePlacementOverlay(); // Update overlay if card is selected
                }
                
                // Can check player towers here too if AI gets spawn zones
            }
            
            // NEW: Update the clip-path of the red overlay
            function updatePlacementOverlay() {
                // Define the zones. 50% is the river. 30% is the new "far end" line.
                const farY = (PLAYER_NEW_SPAWN_LIMIT_Y / HEIGHT) * 100; // 30%
                const riverY = (RIVER_Y / HEIGHT) * 100; // 50%

                const leftDestroyed = aiLeftTowerDestroyed;
                const rightDestroyed = aiRightTowerDestroyed;

                let clipPathStr = '';
                if (!leftDestroyed && !rightDestroyed) {
                    // Block entire top half
                    clipPathStr = `polygon(0% 0%, 100% 0%, 100% ${riverY}%, 0% ${riverY}%)`;
                } else if (leftDestroyed && rightDestroyed) {
                    // Block only the far end
                    clipPathStr = `polygon(0% 0%, 100% 0%, 100% ${farY}%, 0% ${farY}%)`;
                } else if (leftDestroyed && !rightDestroyed) {
                    // Block full right half + far left half
                    clipPathStr = `polygon(0% 0%, 100% 0%, 100% ${riverY}%, 50% ${riverY}%, 50% ${farY}%, 0% ${farY}%)`;
                } else if (!leftDestroyed && rightDestroyed) {
                    // Block full left half + far right half
                    clipPathStr = `polygon(0% 0%, 100% 0%, 100% ${farY}%, 50% ${farY}%, 50% ${riverY}%, 0% ${riverY}%)`;
                }
                placementOverlay.style.clipPath = clipPathStr;
            }


            function checkGameOver() {
                const playerKing = gameObjects.find(t => t.team === 'player' && t.isKing);
                const aiKing = gameObjects.find(t => t.team === 'ai' && t.isKing);
                if (gameRunning && aiKing && aiKing.health <= 0) { showWinScreen(); }
                else if (gameRunning && playerKing && playerKing.health <= 0) { showLoseScreen(); }
            }

            function checkOvertime() {
                if (!gameRunning) return;
                const getTowerCount = (team) => { return gameObjects.filter(obj => obj.team === team && (obj instanceof Tower) && obj.health > 0).length; };
                const playerTowers = getTowerCount('player');
                const aiTowers = getTowerCount('ai');
                if (playerTowers === aiTowers) {
                    isOvertime = true;
                    gameTimer = OVERTIME_TIME;
                    currentElixirRate = BASE_ELIXIR_REGEN_RATE * 2;
                } else if (playerTowers > aiTowers) {
                    showWinScreen();
                } else {
                    showLoseScreen();
                }
            }

            function startTieBreaker() {
                if (!gameRunning) return;
                gameRunning = true; isTieBreaker = true; gameObjects = gameObjects.filter(obj => (obj instanceof Tower));
                messageText.textContent = 'TIEBREAKER!';
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                setTimeout(() => { if (isTieBreaker) messageOverlay.style.display = 'none'; }, 2000);
            }

            function tieBreakerLoop() {
                tieBreakerTick--;
                if (tieBreakerTick <= 0) {
                    tieBreakerTick = 10;
                    let playerKing = null;
                    let aiKing = null;
                    for (const obj of gameObjects) {
                        if (obj instanceof Tower) { obj.health -= 20; }
                        if (obj.isKing && obj.team === 'player') playerKing = obj;
                        if (obj.isKing && obj.team === 'ai') aiKing = obj;
                    }
                    if (aiKing && aiKing.health <= 0 && playerKing && playerKing.health > 0) {
                        isTieBreaker = false;
                        showWinScreen();
                    } else if (playerKing && playerKing.health <= 0) {
                        isTieBreaker = false;
                        showLoseScreen();
                    }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT); drawArena(); gameObjects.forEach(obj => obj.draw());
                if (isTieBreaker) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            async function showWinScreen() {
                if (!gameRunning) return;
                gameRunning = false;
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                trophies += 30;
                updateArena();
                trophyDisplay.textContent = `üèÜ ${trophies}`;
                gold += 50;
                goldDisplay.textContent = `üí∞ ${gold}`;
                if (trophyChests.length < 4) {
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                }
                messageText.textContent = 'You Win! (+30 üèÜ, +50 üí∞, üì¶)';
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                // await saveUserData(); // Guest mode doesn't auto-save
            }

            async function showLoseScreen(message = 'You Lose!') {
                if (!gameRunning) return;
                gameRunning = false;
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                const trophiesToLose = Math.min(30, trophies - currentArenaFloor);
                trophies -= trophiesToLose;
                trophyDisplay.textContent = `üèÜ ${trophies}`;
                messageText.textContent = `${message} (-${trophiesToLose} üèÜ)`;
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                // await saveUserData(); // Guest mode doesn't auto-save
            }

            function gameLoop(timestamp) {
                if (isTieBreaker) {
                    tieBreakerLoop();
                    return;
                }
                if (!gameRunning) {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;
                gameTimer--;
                updateTimerAndElixir();
                aiThinkTimer--;
                if (aiThinkTimer <= 0) {
                    runAI();
                    aiThinkTimer = 30 + Math.random() * 30; // Think every 0.5-1s
                }
                
                // Update objects
                gameObjects.forEach(obj => obj.update());
                
                // Check tower status for spawn zones
                checkTowerStatus();
                
                // Filter dead objects
                gameObjects = gameObjects.filter(obj => {
                    if (obj.health > 0) return true;
                    // Handle units/projectiles/spells
                    if (obj instanceof Unit || obj instanceof Projectile || obj instanceof Spell) { 
                        // Special case: Battle Ram needs to spawn barbs
                        if (obj instanceof BattleRam && !obj.didHit) {
                            obj.spawnBarbs();
                        }
                        return false; 
                    }
                    // Handle towers/buildings
                    if (obj instanceof Tower || obj instanceof Building) {
                        if (obj.isKing) { checkGameOver(); return true; }
                        if (obj.dyingAnimationTimer === 0) { obj.dyingAnimationTimer = 30; }
                        obj.dyingAnimationTimer--;
                        return obj.dyingAnimationTimer > 0;
                    }
                    return false;
                });
                
                updateCardUI();
                if (gameTimer <= 0) {
                    if (isOvertime) { startTieBreaker(); }
                    else { checkOvertime(); }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                drawArena();
                gameObjects.forEach(obj => obj.draw());
                if (gameRunning) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            // --- Event Listeners ---
            
            function getCanvasClickPos(e) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) { 
                    clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; 
                } else if (e.changedTouches && e.changedTouches.length > 0) { 
                    clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; 
                } else { 
                    clientX = e.clientX; clientY = e.clientY; 
                }
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                return { x, y };
            }

            function checkPlacement(x, y, radius, cardType) {
                // Check if in allowed zone
                let inAllowedZone = false;
                if (y > RIVER_Y) {
                    inAllowedZone = true; // Always allowed in player's base
                } else if (y > PLAYER_NEW_SPAWN_LIMIT_Y) { // Between river and "far end"
                    // Check enemy territory
                    if (aiLeftTowerDestroyed && x < WIDTH / 2) inAllowedZone = true;
                    if (aiRightTowerDestroyed && x > WIDTH / 2) inAllowedZone = true;
                }
                if (!inAllowedZone) return false;

                // Check for collision
                for (const obj of gameObjects) {
                    // NEW: Allow placing on troops, not buildings
                    if (obj instanceof Tower || obj instanceof Building) {
                        const dist = getDistance({x: x, y: y}, obj);
                        if (dist < radius + obj.radius) { return false; }
                    }
                }
                
                return true;
            }

            // --- NEW: Card Click/Drag Logic ---

            function handleCardSelect(e, cardEl, cardId) {
                e.preventDefault(); // Prevent scrolling/other actions
                if (!gameRunning) return;
                const card = allCards[cardId];
                if (card.cost > playerElixir) { console.log("Not enough elixir!"); return; }
                
                // Deselect if already selected
                if (selectedSpawningUnit && selectedSpawningUnit.id === cardId) {
                    cancelPlacement();
                    return;
                }

                // Start tracking for drag
                isDragging = false; // Not dragging *yet*
                let pos = (e.touches && e.touches[0]) ? e.touches[0] : e;
                startDragPos = { x: pos.clientX, y: pos.clientY };

                // Select the card
                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                placementOverlay.style.display = 'block'; // Show red overlay
                placementIndicator.innerHTML = '';
                
                selectedSpawningUnit = {
                    id: cardId, cost: card.cost, type: card.type, radius: card.radius || 0, placementRadius: card.placementRadius,
                    emoji: card.emoji, isFlying: card.isFlying, handIndex: cardEl.dataset.handIndex
                };
                
                if (card.type === 'Spell') {
                    isSpawningSpell = true;
                    spellRadius = card.radius;
                    placementIndicator.className = 'spell';
                    placementIndicator.style.width = `${card.radius * 2}px`;
                    placementIndicator.style.height = `${card.radius * 2}px`;
                } else {
                    isSpawningSpell = false;
                    placementRadius = card.placementRadius;
                    placementIndicator.className = '';
                    placementIndicator.style.width = `${placementRadius * 2}px`;
                    placementIndicator.style.height = `${placementRadius * 2}px`;
                    placementIndicator.innerHTML = card.emoji;
                }
                cardEl.classList.add('selected');
                
                // Update placement overlay based on destroyed towers
                updatePlacementOverlay();
                
                // Move indicator to initial touch/mouse position
                let initialPos = (e.touches && e.touches[0]) ? e.touches[0] : e;
                movePlacementIndicator(initialPos);
                // Show indicator, but hide if off-canvas
                const { x, y } = getCanvasClickPos(initialPos);
                if (x < 0 || x > WIDTH || y < 0 || y > HEIGHT) {
                     placementIndicator.style.display = 'none';
                } else {
                     placementIndicator.style.display = 'block';
                }
            }
            
            function handleDragMove(e) {
                if (!selectedSpawningUnit) return;
                e.preventDefault();
                
                let pos = (e.touches && e.touches[0]) ? e.touches[0] : e;
                
                // Check if we've moved enough to be "dragging"
                const dx = pos.clientX - startDragPos.x;
                const dy = pos.clientY - startDragPos.y;
                if (!isDragging && (dx*dx + dy*dy) > (DRAG_SENSITIVITY * DRAG_SENSITIVITY)) {
                    isDragging = true;
                }

                //if (isDragging) { // OLD logic: only move if dragging
                // NEW logic: always move indicator if a card is selected
                movePlacementIndicator(pos);
                //}
            }

            function movePlacementIndicator(e) {
                if (!selectedSpawningUnit) return;
                
                const { x, y } = getCanvasClickPos(e);
                
                // NEW: Hide indicator if off-canvas
                // Check raw clientX/Y against rect
                const rect = canvas.getBoundingClientRect();
                const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
                const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;

                if (isDragging && (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom)) {
                    placementIndicator.style.display = 'none';
                    canPlace = false; // Can't place off-canvas
                    return;
                }
                
                placementIndicator.style.display = 'block';
                const clampedX = Math.max(0, Math.min(WIDTH, x));
                const clampedY = Math.max(0, Math.min(HEIGHT, y));
                let radius = isSpawningSpell ? spellRadius : placementRadius;
                
                // FIX: Use top/left
                placementIndicator.style.left = `${clampedX}px`;
                placementIndicator.style.top = `${clampedY}px`;
                
                if (isSpawningSpell) {
                    canPlace = true; // Spells can be placed anywhere
                } else {
                    canPlace = checkPlacement(clampedX, clampedY, placementRadius, selectedSpawningUnit.type);
                }
                placementIndicator.classList.toggle('cant-place', !canPlace);
            }
            
            // Re-bind mouse/touch move to window to allow dragging off canvas
            window.addEventListener('mousemove', handleDragMove);
            window.addEventListener('touchmove', handleDragMove, { passive: false });


            function handlePlacement(e) {
                if (!selectedSpawningUnit || !gameRunning) {
                    cancelPlacement();
                    return;
                };
                
                // If we were dragging, or if it's a click-to-place on the canvas
                // NEW: Check if the event target is the canvas itself
                const isCanvasClick = e.target === canvas;

                if (isDragging || isCanvasClick) {
                    if (!canPlace) {
                        console.log("Cannot spawn there!");
                        cancelPlacement();
                        return;
                    }
                
                    const { x, y } = getCanvasClickPos(e);
                    const clampedX = Math.max(0, Math.min(WIDTH, x));
                    const clampedY = Math.max(0, Math.min(HEIGHT, y));
                    
                    const card = allCards[selectedSpawningUnit.id];
                    const level = cardCollection[selectedSpawningUnit.id] ? cardCollection[selectedSpawningUnit.id].level : 1;
                    
                    if (card.type === 'Spell') {
                        const damage = card.stats[level].damage;
                        gameObjects.push(new Spell(clampedX, clampedY, 'player', damage, card.radius, card.emoji));
                    } else {
                        const newUnit = new card.unitClass(clampedX, clampedY, 'player', level);
                        if (!card.type.includes('Swarm') && !card.type.includes('Building')) {
                            gameObjects.push(newUnit);
                        }
                    }
                    
                    playCard(selectedSpawningUnit.id, selectedSpawningUnit.handIndex);
                    cancelPlacement();
                } else if (!isDragging && e.target.closest('.card-ui')) {
                    // This was a "click" on a card, but not a drag.
                    // We already selected the card, so just wait for the canvas click.
                    // Do nothing here.
                } else {
                    // This was a click somewhere else (like the elixir bar)
                    cancelPlacement();
                }
            }

            // Use mouseup/touchend on the *window* to catch drags released off-canvas
            window.addEventListener('mouseup', handlePlacement);
            window.addEventListener('touchend', handlePlacement, { passive: false });
            
            // NEW: Add a click listener to the canvas for "click-to-place"
            canvas.addEventListener('click', (e) => {
                if (selectedSpawningUnit && !isDragging) {
                    handlePlacement(e);
                }
            });

            cardInfoCloseBtn.addEventListener('click', closeModal);
            
            // --- Init App ---
            initCardSystem(); // Define all cards
            // Use guest login by default
            // initGuestSession();
            // showScreen('menu');
            // onAuthStateChanged(auth, handleAuth); // Wait for user login
            
            // --- FIX: Only show login screen, let user choose ---
            showScreen('login');

        };

    </script>
</body>
</html>
