<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Royale</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Google Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            background-color: #2a623d; /* Arena green */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            display: block;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: background-color 0.5s ease; /* For arena theme change */
        }
        /* Arena Themes */
        canvas.arena-2 { background-color: #6abf82; }
        canvas.arena-3 { 
            background-color: #4a4a4a;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        #messageOverlay, #chestOpenOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            border-radius: 8px;
            z-index: 50;
            padding: 1rem;
        }
        #messageOverlay button, #chestOpenOverlay button, .login-btn, .debug-btn {
            font-size: 1rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            margin-top: 20px;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80%;
            max-width: 300px;
        }
        #messageOverlay button:hover, #chestOpenOverlay button:hover, .login-btn:hover, .debug-btn:hover {
            background-color: #4338ca;
        }
        .login-btn.google {
            background-color: #dc2626; /* red-600 */
        }
        .login-btn.google:hover {
            background-color: #b91c1c; /* red-700 */
        }
        .login-btn.guest {
            background-color: #6b7280; /* gray-500 */
        }
        .login-btn.guest:hover {
            background-color: #4b5563; /* gray-600 */
        }

        /* Hide screens by default */
        .screen {
            display: none;
            width: 100%;
            height: 100vh;
            overflow-y: auto;
        }
        /* Show the active screen */
        .screen.active {
            display: flex;
        }
        /* Loading Screen Animation */
        @keyframes pulse-king {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .animate-pulse-king {
            animation: pulse-king 2s infinite;
        }
        /* Bottom Nav */
        #bottomNav {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            max-width: 400px;
            margin: 0 auto;
            z-index: 20;
        }
        /* Card Style */
        .card-ui {
            width: 80px;
            height: 112px;
            background-color: #4b5563; /* gray-600 */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            padding: 4px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: white;
            cursor: pointer;
            user-select: none;
            border: 4px solid #374151; /* gray-700 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            overflow: hidden;
        }
        .card-ui.selected {
            border-color: #ec4899; /* pink-500 */
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 0 20px #ec4899;
        }
        .card-ui.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(80%);
        }
        .card-ui-small {
            width: 60px;
            height: 84px;
            border-radius: 6px;
        }
        .card-ui-name {
            font-size: 0.7rem;
            background-color: rgba(0,0,0,0.6);
            padding: 0 4px;
            border-radius: 4px;
            z-index: 2;
        }
        .card-ui-emoji {
            font-size: 2.5rem;
            line-height: 1;
            z-index: 2;
        }
         .card-ui-small .card-ui-emoji {
            font-size: 2rem;
        }
        .card-ui-type {
            font-size: 0.6rem;
            color: #d1d5db; /* gray-300 */
            z-index: 2;
        }
        .card-ui-cost {
            position: absolute;
            top: 2px;
            left: 2px;
            background-color: #7e22ce;
            border: 2px solid #a855f7;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            z-index: 3;
        }
        .card-ui-level {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 0.7rem;
            font-weight: 800;
            background-color: rgba(0,0,0,0.7);
            color: #fde047; /* yellow-300 */
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }
        .card-ui-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background-color: #1f2937; /* gray-800 */
            z-index: 1;
        }
        .card-ui-progress {
            height: 100%;
            background-color: #3b82f6; /* blue-500 */
            transition: width 0.3s;
        }
        .card-ui .can-upgrade {
            background-color: #fde047; /* yellow-300 */
        }
        /* NEW: Locked Card Styles */
        .card-ui-locked {
            filter: grayscale(100%);
            opacity: 0.6;
        }
        .card-ui-locked-arena {
            position: absolute;
            bottom: 4px;
            left: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            background-color: rgba(0,0,0,0.8);
            color: #fde047;
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }


        /* Card Info Modal */
        #cardInfoModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #cardInfoModalContent {
            background-color: #374151; /* gray-700 */
            border-radius: 12px;
            padding: 1.5rem;
            width: 90%;
            max-width: 350px;
            border: 4px solid #4b5563; /* gray-600 */
            position: relative;
        }
        #cardInfoCloseBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 2rem;
            line-height: 1;
            cursor: pointer;
            color: #9ca3af; /* gray-400 */
        }
        #cardInfoStats, #towerInfoStats {
            font-size: 0.9rem;
            color: #d1d5db; /* gray-300 */
        }
        #cardInfoStats span, #towerInfoStats span {
            color: white;
            font-weight: 600;
        }
        .modal-btn {
            width: 100%;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 0.75rem;
            margin-top: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-btn.add { background-color: #16a34a; color: white; }
        .modal-btn.remove { background-color: #dc2626; color: white; }
        .modal-btn.upgrade { background-color: #16a34a; color: white; }
        .modal-btn:disabled {
            background-color: #6b7280; /* gray-500 */
            color: #d1d5db; /* gray-300 */
            cursor: not-allowed;
        }
        #cardInfoProgressContainer, #towerInfoProgressContainer {
            width: 100%;
            background-color: #1f2937;
            border-radius: 5px;
            height: 20px;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }
        #cardInfoProgressBar, #towerInfoProgressBar {
            height: 100%;
            background-color: #3b82f6;
        }
        #cardInfoProgressText, #towerInfoProgressText {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
        }
        /* Troop Ghost & Spell Radius */
        #placementIndicator {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 20;
            font-size: 2rem;
            opacity: 0.7;
            text-align: center;
            line-height: 1;
            /* FIX: Use top/left instead of transform */
            transform: translate(-50%, -50%); /* Keep this for centering */
        }
        #placementIndicator.spell {
            border: 4px dashed white;
            background: rgba(255, 255, 255, 0.2);
        }
        #placementIndicator.cant-place {
            background: rgba(220, 38, 38, 0.4);
            border-color: #dc2626;
        }
        /* Chest Reward Styles */
        #chestRewardList {
            font-size: 1.2rem;
            margin-top: 1rem;
        }
        #chestRewardList div {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        /* In-Game Level Text */
        .game-level-indicator {
            position: absolute;
            font-size: 0.7rem;
            font-weight: 800;
            background-color: rgba(0,0,0,0.7);
            color: #fde047; /* yellow-300 */
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
            pointer-events: none;
        }
        .tower-level {
            font-size: 1.2rem;
            font-weight: bold;
            color: white;
            opacity: 0.4;
            text-shadow: 0 0 5px black;
        }

    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-2">
    
    <!-- 
    ========================================================
    SCREEN: LOGIN
    ========================================================
    -->
    <div id="loginScreen" class="screen active flex-col justify-center items-center">
        <div class="text-6xl">üëë</div>
        <h1 class="text-4xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-300">Sign in to save your progress!</p>
        <p id="loginError" class="text-lg mt-2 text-red-500 font-bold h-6"></p> 
        <button id="googleLoginBtn" class="login-btn google">
            <svg class="w-6 h-6 mr-3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"></path><path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"></path><path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z"></path><path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.574l6.19,5.238C42.018,36.341,44,30.606,44,24C44,22.659,43.862,21.35,43.611,20.083z"></path></svg>
            Sign in with Google
        </button>
        <!-- "Play as Guest (No Save)" button -->
        <button id="trueGuestLoginBtn" class="login-btn guest">
            Play as Guest (No Save)
        </button>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: LOADING
    ========================================================
    -->
    <div id="loadingScreen" class="screen flex-col justify-center items-center bg-gray-900">
        <div class="text-8xl animate-pulse-king">üëë</div>
        <h1 class="text-3xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-300">Loading...</p>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: MENU (HOME)
    ========================================================
    -->
    <div id="menuScreen" class="screen flex-col items-center p-4">
        <!-- Main Content Area -->
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <!-- Header -->
            <div class="flex justify-between items-center w-full">
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="goldDisplay" class="text-xl font-bold text-yellow-400">üí∞ 500</span>
                </div>
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="trophyDisplay" class="text-xl font-bold text-blue-400">üèÜ 0</span>
                </div>
            </div>
            
            <!-- Arena Display -->
            <div class="flex flex-col items-center my-8">
                <span id="arenaEmoji" class="text-8xl">üèûÔ∏è</span>
                <h2 id="arenaName" class="text-2xl font-bold mt-2">Arena 1: Emoji Valley</h2>
            </div>
            
            <!-- Battle Button -->
            <button id="battleButton" class="bg-red-600 hover:bg-red-700 text-white w-3/4 py-4 rounded-lg shadow-lg text-3xl font-extrabold transition transform hover:scale-105">
                BATTLE!
            </button>
            
            <!-- Chest Slots -->
            <div class="mt-8 w-full">
                <h3 class="text-xl font-bold text-center mb-2">Your Chests</h3>
                <div id="chestSlots" class="grid grid-cols-4 gap-2">
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                </div>
            </div>
        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-yellow-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <!-- NEW: Debug Button -->
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: DECK
    ========================================================
    -->
    <div id="deckScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 id="deckCount" class="text-2xl font-bold">Deck (0 / 8)</h1>
            <div id="deckCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Deck cards injected by JS -->
            </div>
            
            <hr class="border-gray-600 w-full my-4">
            
            <h2 class="text-2xl font-bold">Your Collection</h2>
            <div id="collectionCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Collection cards injected by JS -->
            </div>

            <!-- NEW: Locked Cards Section -->
            <hr class="border-gray-600 w-full my-4">
            <h2 class="text-2xl font-bold">Not Unlocked</h2>
            <div id="lockedCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Locked cards injected by JS -->
            </div>

        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-yellow-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: TOWER
    ========================================================
    -->
    <div id="towerScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Tower Power</h1>
            <p id="towerLevelDisplay" class="text-lg text-yellow-300 font-bold">Tower Level 1</p>
            <div class="text-8xl my-4">üëë</div>
            
            <!-- Stats -->
            <div class="bg-gray-800 p-4 rounded-lg mt-4 w-full space-y-2">
                <h3 class="text-xl font-bold text-center">Tower Stats</h3>
                <div id="towerInfoStats" class="grid grid-cols-2 gap-2">
                    <!-- Stats injected by JS -->
                </div>
            </div>
            
            <!-- Upgrade -->
            <div class="bg-gray-800 p-4 rounded-lg mt-8 w-full">
                <h3 class="text-xl font-bold text-center">Upgrade Tower</h3>
                <div id="towerInfoProgressContainer">
                    <div id="towerInfoProgressBar" style="width: 0%;"></div>
                    <div id="towerInfoProgressText">0 / 0</div>
                </div>
                <button id="towerUpgradeButton" class="modal-btn upgrade" disabled>
                    Upgrade
                </button>
            </div>
        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn active flex flex-col items-center text-yellow-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: DEBUG (NEW)
    ========================================================
    -->
    <div id="debugScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Debug Menu</h1>
            <p class="text-gray-400 text-center my-4">For testing only!</p>
            
            <button id="debugArena2" class="debug-btn bg-green-600 hover:bg-green-700">Jump to Arena 2 (250 üèÜ)</button>
            <button id="debugArena3" class="debug-btn bg-red-600 hover:bg-red-700">Jump to Arena 3 (500 üèÜ)</button>
            <button id="debugUnlockAll" class="debug-btn bg-blue-600 hover:bg-blue-700">Unlock All Cards</button>
            <button id="debugUpgradeAll" class="debug-btn bg-purple-600 hover:bg-purple-700">Upgrade All Cards +1 Lvl</button>
            <button id="debugGetChest" class="debug-btn bg-yellow-600 hover:bg-yellow-700">Get a Free Chest üì¶</button>
            <button id="debugAddGold" class="debug-btn bg-yellow-400 text-gray-900 hover:bg-yellow-300">Get 1000 Gold üí∞</button>
            <button id="debugReset" class="debug-btn bg-gray-600 hover:bg-gray-700">Reset Account (New User)</button>

        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn active flex flex-col items-center text-yellow-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>


    <!-- 
    ========================================================
    SCREEN: GAME
    ========================================================
    -->
    <div id="gameScreen" class="screen flex-col items-center p-2">
        <div id="gameContainer">
            <div id="timerDisplay" class="absolute top-2 left-1/2 -translate-x-1/2 text-2xl font-bold bg-black bg-opacity-50 px-4 py-1 rounded-lg z-10">2:00</div>
            <canvas id="gameCanvas" width="400" height="500"></canvas>
            <div id="messageOverlay">
                <span id="messageText"></span>
                <button id="startButton">Start Game</button>
                <button id="menuButton" class="bg-red-600 hover:bg-red-700">Back to Menu</button>
            </div>
            <!-- Placement "Ghost" Indicator -->
            <div id="placementIndicator"></div>
        </div>

        <!-- Card UI Bar -->
        <div class="bg-gray-800 p-4 shadow-inner w-full max-w-md mt-2 rounded-lg" style="padding-bottom: env(safe-area-inset-bottom, 1rem);">
            <div class="max-w-md mx-auto">
                <!-- Elixir Bar -->
                <div class="mb-4">
                    <div class="w-full bg-gray-700 rounded-full h-6 border-2 border-gray-900 shadow-inner">
                        <div id="elixirBar" class="bg-purple-500 h-full rounded-full transition-all duration-100 ease-linear text-right pr-2 font-bold" style="width: 30%;">
                            <span id="elixirText">3</span>
                        </div>
                    </div>
                </div>
                
                <!-- 4-Card Hand + Next Card -->
                <div class="flex justify-center items-end space-x-2">
                    <div class="flex flex-col items-center">
                        <span class="text-xs mb-1">NEXT</span>
                        <div id="nextCardSlot" class="card-ui-small"></div>
                    </div>
                    <div id="cardHand" class="flex justify-center space-x-2"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    CARD INFO MODAL
    ========================================================
    -->
    <div id="cardInfoModal">
        <div id="cardInfoModalContent">
            <span id="cardInfoCloseBtn">&times;</span>
            <div class="flex items-center space-x-4">
                <div id="cardInfoDisplay" class="flex-shrink-0"></div>
                <div>
                    <h2 id="cardInfoName" class="text-2xl font-bold">Card Name</h2>
                    <p id="cardInfoType" class->="text-lg text-gray-400">Card Type</p>
                    <p id="cardInfoLevel" class="text-lg font-bold text-yellow-300">Level 1</p>
                </div>
            </div>
            <hr class="border-gray-500 my-4">
            <div id="cardInfoStats" class="space-y-1"></div>
            <!-- NEW: Add/Remove Button container -->
            <div id="cardInfoButtons">
                <!-- Add/Remove button injected by JS -->
            </div>
            <div id="cardInfoProgressContainer">
                <div id="cardInfoProgressBar" style="width: 0%;"></div>
                <div id="cardInfoProgressText">0 / 0</div>
            </div>
            <button id="cardInfoButton" class="modal-btn"></button>
        </div>
    </div>
    
    <!-- 
    ========================================================
    CHEST OPENING MODAL
    ========================================================
    -->
    <div id="chestOpenOverlay">
        <h2 class="text-4xl font-bold">Chest Unlocked!</h2>
        <div class="text-7xl my-4">üì¶</div>
        <div id="chestRewardList">
            <!-- Rewards injected by JS -->
        </div>
        <button id="chestCloseButton">Awesome!</button>
    </div>


    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Config (User-Provided) ---
        // This is your project's config. It's safe to have here!
        const firebaseConfig = {
            apiKey: "AIzaSyCnaXKjDvPDXP2tF5ZmtB7naYjCuLGUsd4",
            authDomain: "emoji-royale-8fb68.firebaseapp.com",
            projectId: "emoji-royale-8fb68",
            storageBucket: "emoji-royale-8fb68.firebasestorage.app",
            messagingSenderId: "1021589049311",
            appId: "1:1021589049311:web:61ce6353950831e298be6a",
            measurementId: "G-FDQ9L0MQGM"
        };

        // --- Initialize Firebase (Combined Script) ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();
        // setLogLevel('debug'); // Uncomment for debugging Firestore

        // --- Firebase Globals ---
        const appId = "emoji-royale-8fb68"; // Use your actual project ID
        let userDocRef; // Reference to the user's document in Firestore
        let userId; // The user's unique ID
        
        // --- Global State ---
        let currentScreen = 'login'; // Start on login screen
        let trophies = 0;
        let gold = 500;
        let trophyChests = [];
        let allCards = {};
        let cardCollection = {};
        let playerDeck = [];
        let gameDeck = [];
        let hand = [];
        let nextCard = null;
        let discardPile = [];
        let aiDeck = [];
        let aiHand = [];
        let aiNextCard = null;
        let aiDiscardPile = [];
        let towerLevel = 1;
        let towerCardCount = 0;
        let isInitialAuthCheck = true; // --- FIX: Flag to stop auto-login ---
        
        // --- NEW: Level Cap at 15 ---
        const towerUpgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        const towerStats = {
            1: { kingHealth: 2000, princessHealth: 1000, damage: 50, hitSpeed: 1 },
            2: { kingHealth: 2200, princessHealth: 1100, damage: 55, hitSpeed: 1 },
            3: { kingHealth: 2420, princessHealth: 1210, damage: 60, hitSpeed: 1 },
            4: { kingHealth: 2662, princessHealth: 1331, damage: 66, hitSpeed: 1 },
            5: { kingHealth: 2928, princessHealth: 1464, damage: 72, hitSpeed: 1 },
            6: { kingHealth: 3220, princessHealth: 1610, damage: 79, hitSpeed: 1 },
            7: { kingHealth: 3542, princessHealth: 1771, damage: 87, hitSpeed: 1 },
            8: { kingHealth: 3896, princessHealth: 1948, damage: 96, hitSpeed: 1 },
            9: { kingHealth: 4285, princessHealth: 2142, damage: 105, hitSpeed: 1 },
            10: { kingHealth: 4713, princessHealth: 2356, damage: 116, hitSpeed: 1 },
            11: { kingHealth: 5184, princessHealth: 2591, damage: 128, hitSpeed: 1 },
            12: { kingHealth: 5702, princessHealth: 2850, damage: 141, hitSpeed: 1 },
            13: { kingHealth: 6272, princessHealth: 3135, damage: 155, hitSpeed: 1 },
            14: { kingHealth: 6899, princessHealth: 3448, damage: 170, hitSpeed: 1 },
            15: { kingHealth: 7589, princessHealth: 3793, damage: 187, hitSpeed: 1 },
        };

        let selectedSpawningUnit = null;
        let isSpawningSpell = false;
        let spellRadius = 0;
        let placementRadius = 0;
        let canPlace = false;
        const arenaFloors = { 0: "Arena 1: Emoji Valley", 250: "Arena 2: Laughing Village", 500: "Arena 3: Lava Town" };
        let currentArenaFloor = 0;
        let currentArenaTheme = 'arena-1'; // For canvas styling

        // --- NEW: Level Cap at 15 ---
        const upgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        let isDataSaved = true; // Flag to control saving

        // --- Start Game ---
        window.onload = () => {

            // --- Game Constants ---
            const WIDTH = 400; // Define constants first
            const HEIGHT = 500;
            const RIVER_Y = HEIGHT / 2;
            const BRIDGE_Y = RIVER_Y;
            const PLAYER_SPAWN_LIMIT_Y = RIVER_Y;
            const AI_SPAWN_LIMIT_Y = RIVER_Y;
            const LANE_LEFT_X = WIDTH / 4;
            const LANE_RIGHT_X = (WIDTH / 4) * 3;
            const MAX_ELIXIR = 10;
            const BASE_ELIXIR_REGEN_RATE = 0.008;
            const REGULATION_TIME = 120 * 60;
            const OVERTIME_TIME = 120 * 60;

            // --- Game State ---
            let gameObjects = [];
            let playerElixir = 3;
            let aiElixir = 3;
            let gameRunning = false;
            let gameLoopId = 0;
            let lastTime = 0;
            let aiThinkTimer = 0;
            let gameTimer = REGULATION_TIME;
            let isOvertime = false;
            let currentElixirRate = BASE_ELIXIR_REGEN_RATE;
            let isTieBreaker = false;
            let tieBreakerTick = 0;

            // --- DOM Elements ---
            const screens = document.querySelectorAll('.screen');
            const navButtons = document.querySelectorAll('.nav-btn');
            const loginScreen = document.getElementById('loginScreen');
            const googleLoginBtn = document.getElementById('googleLoginBtn');
            const trueGuestLoginBtn = document.getElementById('trueGuestLoginBtn'); // FIXED
            const loginError = document.getElementById('loginError'); 
            const loadingScreen = document.getElementById('loadingScreen');
            const menuScreen = document.getElementById('menuScreen');
            const gameScreen = document.getElementById('gameScreen');
            const deckScreen = document.getElementById('deckScreen');
            const towerScreen = document.getElementById('towerScreen');
            const debugScreen = document.getElementById('debugScreen'); // NEW
            const battleButton = document.getElementById('battleButton');
            const trophyDisplay = document.getElementById('trophyDisplay');
            const goldDisplay = document.getElementById('goldDisplay');
            const chestSlots = document.getElementById('chestSlots');
            const arenaName = document.getElementById('arenaName');
            const arenaEmoji = document.getElementById('arenaEmoji');
            const deckCardGrid = document.getElementById('deckCardGrid');
            const collectionCardGrid = document.getElementById('collectionCardGrid');
            const lockedCardGrid = document.getElementById('lockedCardGrid'); 
            const deckCount = document.getElementById('deckCount');
            const cardHandEl = document.getElementById('cardHand');
            const nextCardSlotEl = document.getElementById('nextCardSlot');
            const placementIndicator = document.getElementById('placementIndicator');
            const menuButton = document.getElementById('menuButton');
            const towerLevelDisplay = document.getElementById('towerLevelDisplay');
            const towerInfoStats = document.getElementById('towerInfoStats');
            const towerInfoProgressContainer = document.getElementById('towerInfoProgressContainer');
            const towerInfoProgressBar = document.getElementById('towerInfoProgressBar');
            const towerInfoProgressText = document.getElementById('towerInfoProgressText');
            const towerUpgradeButton = document.getElementById('towerUpgradeButton');
            const cardInfoModal = document.getElementById('cardInfoModal');
            const cardInfoCloseBtn = document.getElementById('cardInfoCloseBtn');
            const cardInfoDisplay = document.getElementById('cardInfoDisplay');
            const cardInfoName = document.getElementById('cardInfoName');
            const cardInfoType = document.getElementById('cardInfoType');
            const cardInfoLevel = document.getElementById('cardInfoLevel');
            const cardInfoStats = document.getElementById('cardInfoStats');
            const cardInfoButtons = document.getElementById('cardInfoButtons'); 
            const cardInfoProgressContainer = document.getElementById('cardInfoProgressContainer');
            const cardInfoProgressBar = document.getElementById('cardInfoProgressBar');
            const cardInfoProgressText = document.getElementById('cardInfoProgressText');
            const cardInfoButton = document.getElementById('cardInfoButton');
            const chestOpenOverlay = document.getElementById('chestOpenOverlay');
            const chestRewardList = document.getElementById('chestRewardList');
            const chestCloseButton = document.getElementById('chestCloseButton');
            // Debug Buttons
            const debugArena2 = document.getElementById('debugArena2');
            const debugArena3 = document.getElementById('debugArena3');
            const debugUnlockAll = document.getElementById('debugUnlockAll');
            const debugUpgradeAll = document.getElementById('debugUpgradeAll');
            const debugGetChest = document.getElementById('debugGetChest');
            const debugAddGold = document.getElementById('debugAddGold');
            const debugReset = document.getElementById('debugReset');

            // --- Game Elements (from gameScreen) ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const elixirBar = document.getElementById('elixirBar');
            const elixirText = document.getElementById('elixirText');
            const messageOverlay = document.getElementById('messageOverlay');
            const messageText = document.getElementById('messageText');
            const startButton = document.getElementById('startButton');
            const timerDisplay = document.getElementById('timerDisplay');


            // ==============================================
            // FIREBASE & USER DATA
            // ==============================================
            
            // --- FIX: This function handles the "stuck on loading" bug ---
            async function handleAuth(user) {
                if (user && !user.isAnonymous) { // Only Google Sign-in saves
                    userId = user.uid;
                    userDocRef = doc(db, 'artifacts', appId, 'users', userId);
                    isDataSaved = true;
                    showScreen('loading');
                    loadingScreen.querySelector('p').textContent = 'Loading Progress...';

                    let hasFinishedLoading = false;

                    // This function is the "gate." Only the first thing to call it wins.
                    const finishLoading = async (didError = false) => {
                        if (hasFinishedLoading) return; // Already done, stop.
                        hasFinishedLoading = true;
                        clearTimeout(loadingTimeout); // Stop the safety timer

                        if (didError) {
                            // If we got here from an error or timeout, we MUST start a new game
                            console.warn("Loading failed or timed out, starting new user session.");
                            await initNewUser(); // This just sets the local variables
                            await saveUserData(); // Asynchronously save the new data
                        }
                        
                        // If we got here with no error, the data is already loaded (or was new)
                        showScreen('menu');
                    };

                    // 1. The Safety Timer: If loading takes > 8s, force a new game
                    const loadingTimeout = setTimeout(() => {
                        finishLoading(true); 
                    }, 8000); // 8-second timeout

                    // 2. The Load Attempt
                    try {
                        await loadUserData(); // This function loads or inits/saves new user data
                        finishLoading(false); // Success!
                    } catch (error) {
                        console.error("Error in loadUserData, forcing new game session:", error);
                        finishLoading(true); // Error!
                    }
                    
                } else { // Not logged in or is anonymous
                    userId = null;
                    userDocRef = null;
                    isDataSaved = false;
                    showScreen('login');
                }
            }
            
            async function loadUserData() {
                if (!userDocRef) {
                    // This should not happen if handleAuth is working, but as a fallback:
                    await initNewUser();
                    await saveUserData();
                    return;
                }
                try {
                    const docSnap = await getDoc(userDocRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        trophies = data.trophies || 0;
                        gold = data.gold || 500;
                        towerLevel = data.towerLevel || 1;
                        towerCardCount = data.towerCardCount || 0;
                        trophyChests = data.trophyChests || [];
                        cardCollection = data.cardCollection || initNewUserCards(false); 
                        playerDeck = data.playerDeck || initNewUserCards(true); 
                    } else {
                        // This is a new user, set them up and save
                        await initNewUser();
                        await saveUserData();
                    }
                } catch (error) {
                    console.error("Error loading user data, will force new user:", error);
                    throw error; // Re-throw the error so handleAuth's catch block fires
                }
            }
            
            async function initNewUser() {
                // This function just sets local variables
                trophies = 0;
                gold = 500;
                towerLevel = 1;
                towerCardCount = 0;
                trophyChests = [];
                cardCollection = initNewUserCards(false);
                playerDeck = initNewUserCards(true);
            }

            // NEW: "Guest (No Save)" logic
            function initGuestSession() {
                trophies = 0;
                gold = 500;
                towerLevel = 1;
                towerCardCount = 0;
                trophyChests = [];
                cardCollection = initNewUserCards(false);
                playerDeck = initNewUserCards(true);
                
                // Disable saving
                userDocRef = null; 
                userId = null;
                isDataSaved = false; // Prevent save attempts
            }

            function initNewUserCards(deckOnly = false) {
                let newCollection = {};
                // Add all cards to collection with count 0 (except Arena 1)
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue;
                    newCollection[cardId] = { level: 1, count: 0 };
                }
                // Add Arena 1 cards with count 1
                for (const cardId in allCards) {
                    if (allCards[cardId].arena === 1) {
                        newCollection[cardId] = { level: 1, count: 1 };
                    }
                }
                if (deckOnly) {
                    // Return only the *IDs* of Arena 1 cards
                    return Object.keys(allCards).filter(id => allCards[id].arena === 1);
                }
                return newCollection;
            }

            async function saveUserData() {
                if (!userDocRef || !isDataSaved) return;
                isDataSaved = false;
                try {
                    const dataToSave = {
                        trophies,
                        gold,
                        towerLevel,
                        towerCardCount,
                        trophyChests,
                        cardCollection,
                        playerDeck,
                        lastSaved: new Date().toISOString()
                    };
                    await setDoc(userDocRef, dataToSave, { merge: true });
                } catch (error) {
                    console.error("Error saving user data:", error);
                }
                isDataSaved = true;
            }
            
            googleLoginBtn.addEventListener('click', async () => {
                loginError.textContent = '';
                try {
                    // This will trigger the onAuthStateChanged listener, which will call handleAuth
                    await signInWithPopup(auth, provider);
                } catch (error) {
                    if (error.code === 'auth/popup-blocked') {
                        loginError.textContent = 'Pop-up blocked! Please allow pop-ups.';
                    } else if (error.code === 'auth/unauthorized-domain') {
                        loginError.textContent = 'Sign-in domain not authorized.';
                    } else {
                        console.error("Google Sign-in error:", error);
                        loginError.textContent = 'Login failed. Please try again.';
                    } 
                }
            });
            
            // "Play as Guest (No Save)" button
            trueGuestLoginBtn.addEventListener('click', () => {
                loginError.textContent = ''; // Clear errors
                initGuestSession(); // Load default data, disable saving
                showScreen('loading');
                loadingScreen.querySelector('p').textContent = 'Starting Guest Game...';
                setTimeout(() => showScreen('menu'), 1000);
            });


            // ==============================================
            // SCREEN & NAVIGATION LOGIC
            // ==============================================
            function showScreen(screenId) {
                currentScreen = screenId;
                screens.forEach(s => { s.id === screenId + 'Screen' ? s.classList.add('active') : s.classList.remove('active'); });
                
                if (screenId === 'menu' || screenId === 'deck' || screenId === 'tower' || screenId === 'debug') {
                    navButtons.forEach(btn => { if (btn.dataset.screen === screenId) { btn.classList.add('text-yellow-400'); btn.classList.remove('text-gray-400'); } else { btn.classList.remove('text-yellow-400'); btn.classList.add('text-gray-400'); } });
                }
                
                if (screenId === 'deck') { renderDeckScreen(); }
                if (screenId === 'tower') { renderTowerScreen(); }
                if (screenId === 'menu') { updateArena(); trophyDisplay.textContent = `üèÜ ${trophies}`; goldDisplay.textContent = `üí∞ ${gold}`; renderChests(); updateBattleButtonState(); }
            }

            function updateArena() {
                let currentTrophyFloor = 0;
                let arenaDisplayName = "Arena 1: Emoji Valley";
                let emoji = "üèûÔ∏è";
                currentArenaTheme = 'arena-1';
                
                // Find the highest arena floor the player has reached
                for (const floor in arenaFloors) { if (trophies >= parseInt(floor)) { currentTrophyFloor = parseInt(floor); arenaDisplayName = arenaFloors[floor]; } }
                currentArenaFloor = currentTrophyFloor;
                
                if (arenaDisplayName.includes("Laughing Village")) {
                    emoji = "üèòÔ∏è";
                    currentArenaTheme = 'arena-2';
                } else if (arenaDisplayName.includes("Lava Town")) {
                    emoji = "üåã";
                    currentArenaTheme = 'arena-3';
                }
                arenaName.textContent = arenaDisplayName;
                arenaEmoji.textContent = emoji;
                canvas.className = currentArenaTheme;
            }

            function renderChests() {
                const slots = document.querySelectorAll('#chestSlots .chest-slot');
                slots.forEach((slot, index) => {
                    slot.innerHTML = '';
                    slot.onclick = null;
                    if (trophyChests[index]) {
                        slot.innerHTML = `üì¶`;
                        slot.classList.remove('text-gray-500', 'bg-gray-700');
                        slot.classList.add('bg-yellow-700', 'cursor-pointer');
                        slot.onclick = () => openChest(index);
                    } else {
                        slot.innerHTML = ``;
                        slot.classList.add('text-gray-500', 'bg-gray-700');
                        slot.classList.remove('bg-yellow-700', 'cursor-pointer');
                    }
                });
            }
            
            function openChest(index) {
                const chest = trophyChests[index];
                if (!chest) return;
                trophyChests.splice(index, 1);
                
                const rewardGold = 50 + Math.floor(Math.random() * 50);
                gold += rewardGold;
                let rewardsHTML = `<div><span class="text-3xl">üí∞</span> <span class="text-yellow-400">${rewardGold} Gold</span></div>`;
                
                const unlockedCards = getUnlockedCards(true); // Get list of cards this player *can* win
                const numCardStacks = 2 + Math.floor(Math.random() * 2);
                
                for(let i = 0; i < numCardStacks; i++) {
                    const cardId = unlockedCards[Math.floor(Math.random() * unlockedCards.length)];
                    const cardCount = 3 + Math.floor(Math.random() * 5);
                    
                    if (cardId === 'tower') {
                        towerCardCount += cardCount;
                        rewardsHTML += `<div><span class="text-3xl">üëë</span> ${cardCount}x Tower Cards</div>`;
                    } else {
                        // FIX: Ensure card exists in collection
                        if (!cardCollection[cardId]) {
                            cardCollection[cardId] = { level: 1, count: 0 };
                        }
                        cardCollection[cardId].count += cardCount;
                        rewardsHTML += `<div><span class="text-3xl">${allCards[cardId].emoji}</span> ${cardCount}x ${allCards[cardId].name}</div>`;
                    }
                }
                
                chestRewardList.innerHTML = rewardsHTML;
                chestOpenOverlay.style.display = 'flex';
                
                renderChests();
                updateArena();
                saveUserData();
            }
            chestCloseButton.addEventListener('click', () => {
                chestOpenOverlay.style.display = 'none';
            });

            navButtons.forEach(btn => { btn.addEventListener('click', () => { showScreen(btn.dataset.screen); }); });
            battleButton.addEventListener('click', () => {
                if (battleButton.disabled) return;
                menuScreen.classList.remove('active');
                loadingScreen.classList.add('active');
                loadingScreen.querySelector('p').textContent = 'Finding Opponent...';
                setTimeout(() => {
                    showScreen('game');
                    messageText.textContent = 'Get Ready!';
                    startButton.style.display = 'none';
                    menuButton.style.display = 'none';
                    messageOverlay.style.display = 'flex';
                    setTimeout(() => {
                        initGame();
                        lastTime = performance.now();
                        gameLoopId = requestAnimationFrame(gameLoop);
                    }, 1500);
                }, 2000);
            });
            menuButton.addEventListener('click', () => { showScreen('menu'); gameRunning = false; cancelAnimationFrame(gameLoopId); });

            // ==============================================
            // DEBUG MENU LOGIC (NEW)
            // ==============================================
            debugArena2.addEventListener('click', () => {
                trophies = 250;
                updateArena();
                saveUserData();
                showScreen('menu');
            });
            debugArena3.addEventListener('click', () => {
                trophies = 500;
                updateArena();
                saveUserData();
                showScreen('menu');
            });
            debugUnlockAll.addEventListener('click', () => {
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue;
                    if (!cardCollection[cardId]) {
                        cardCollection[cardId] = { level: 1, count: 1 };
                    } else if (cardCollection[cardId].count === 0) {
                        cardCollection[cardId].count = 1;
                    }
                }
                saveUserData();
                // Use a custom modal instead of alert
                showTemporaryMessage("All cards unlocked!");
            });
            debugUpgradeAll.addEventListener('click', () => {
                for (const cardId in cardCollection) {
                    const cardData = cardCollection[cardId];
                    if (cardData.count > 0 && cardData.level < 15) { // Only upgrade unlocked cards, cap at 15
                        cardData.level++;
                    }
                }
                if (towerLevel < 15) towerLevel++;
                saveUserData();
                showTemporaryMessage("All owned cards and tower upgraded +1 level!");
            });
            debugGetChest.addEventListener('click', () => {
                if (trophyChests.length < 4) {
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                    saveUserData();
                    showTemporaryMessage("Got a chest!");
                } else {
                    showTemporaryMessage("Chest slots are full!");
                }
            });
            debugAddGold.addEventListener('click', () => {
                gold += 1000;
                goldDisplay.textContent = `üí∞ ${gold}`;
                saveUserData();
                showTemporaryMessage("+1000 Gold!");
            });
            debugReset.addEventListener('click', () => {
                // Use a custom modal instead of confirm
                showCustomConfirm("Are you sure you want to reset all progress?", () => {
                    initNewUser(); // This saves
                    showScreen('menu');
                    showTemporaryMessage("Account reset!");
                });
            });

            // --- Custom Alert/Confirm Modals ---
            function showTemporaryMessage(text) {
                // A simple overlay message
                messageText.textContent = text;
                startButton.style.display = 'none';
                menuButton.style.display = 'none';
                messageOverlay.style.display = 'flex';
                setTimeout(() => {
                    if (currentScreen === 'game') {
                         messageOverlay.style.display = 'none';
                    }
                }, 1500);
            }

            function showCustomConfirm(text, onConfirm) {
                // Re-use message overlay for confirmation
                messageText.innerHTML = `${text}<div id="confirmButtons"></div>`;
                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = 'Yes, Reset';
                confirmBtn.className = 'modal-btn remove'; // Use red color
                confirmBtn.style.width = 'auto';
                confirmBtn.style.padding = '0.5rem 1rem';
                confirmBtn.style.fontSize = '1rem';
                
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.className = 'modal-btn'; // Use default color
                cancelBtn.style.backgroundColor = '#6b7280';
                cancelBtn.style.width = 'auto';
                cancelBtn.style.padding = '0.5rem 1rem';
                cancelBtn.style.fontSize = '1rem';

                document.getElementById('confirmButtons').append(confirmBtn, cancelBtn);
                
                confirmBtn.onclick = () => {
                    messageOverlay.style.display = 'none';
                    onConfirm();
                };
                cancelBtn.onclick = () => {
                    messageOverlay.style.display = 'none';
                };

                startButton.style.display = 'none';
                menuButton.style.display = 'none';
                messageOverlay.style.display = 'flex';
            }


            // ==============================================
            // CARD & DECK LOGIC
            // ==============================================

            function createCardDOM(cardId, isSmall = false, inHand = false) {
                const card = allCards[cardId];
                if (!card) return null;
                
                const cardData = cardCollection[cardId];
                // --- CARD LOCKING FIX ---
                const isLocked = (!cardData || cardData.count === 0) && card.arena > 1;
                
                const cardEl = document.createElement('div');
                cardEl.className = `card-ui ${isSmall ? 'card-ui-small' : ''}`;
                cardEl.dataset.unit = cardId;
                
                if (isLocked && !inHand) {
                    cardEl.classList.add('card-ui-locked');
                    cardEl.innerHTML = `
                        <div class="card-ui-cost">${card.cost}</div>
                        <span class="card-ui-name">${card.name}</span>
                        <span class="card-ui-emoji">${card.emoji}</span>
                        <span class="card-ui-type">${card.type}</span>
                        <div class="card-ui-locked-arena">Unlocks in Arena ${card.arena}</div>
                    `;
                    return cardEl;
                }

                const displayLevel = (cardData && cardData.level) ? cardData.level : 1;
                const displayCount = (cardData && cardData.count) ? cardData.count : 0;
                
                cardEl.dataset.cost = card.cost;
                cardEl.dataset.type = card.type;
                cardEl.dataset.emoji = card.emoji;
                cardEl.dataset.radius = card.placementRadius;
                if (card.radius) cardEl.dataset.spellRadius = card.radius;
                let progressBarHTML = '';
                let levelTextHTML = `<div class="card-ui-level">Lvl ${displayLevel}</div>`;
                if (!inHand) {
                    const costs = upgradeCosts[displayLevel];
                    let progress = 0;
                    let canUpgrade = false;
                    if (costs) {
                        progress = (displayCount / costs.cards) * 100;
                        if (displayCount >= costs.cards && gold >= costs.gold) { canUpgrade = true; }
                    } else { progress = 100; } // Max level
                    progressBarHTML = `<div class="card-ui-progress-bar"><div class="card-ui-progress ${canUpgrade ? 'can-upgrade' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>`;
                } else { levelTextHTML = ''; }
                cardEl.innerHTML = `<div class="card-ui-cost">${card.cost}</div><span class="card-ui-name">${card.name}</span><span class="card-ui-emoji">${card.emoji}</span><span class="card-ui-type">${card.type}</span>${levelTextHTML}${progressBarHTML}`;
                return cardEl;
            }

            // --- AI DECK FIX: Use player's arena, not AI level ---
            function getUnlockedCards(includeTower = false, forAIArena = 0) {
                const unlocked = [];
                // Use AI arena if provided, otherwise use player's trophies
                const arenaNum = forAIArena > 0 ? forAIArena : (currentArenaFloor === 0 ? 1 : (currentArenaFloor === 250 ? 2 : 3));
                
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; // Don't add 'tower' card to decks
                    if (allCards[cardId].arena <= arenaNum) {
                        unlocked.push(cardId);
                    }
                }
                if (includeTower) {
                    // This is for chest rewards only
                    unlocked.push('tower');
                }
                return unlocked;
            }

            function renderDeckScreen() {
                deckCardGrid.innerHTML = '';
                collectionCardGrid.innerHTML = '';
                lockedCardGrid.innerHTML = ''; 
                
                deckCount.textContent = `Deck (${playerDeck.length} / 8)`;
                
                // Render Deck
                playerDeck.forEach(cardId => { 
                    const cardEl = createCardDOM(cardId, true); 
                    cardEl.addEventListener('click', () => openCardModal(cardId)); 
                    deckCardGrid.appendChild(cardEl); 
                });
                
                // Render Collection & Locked Cards
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; 
                    
                    const cardData = cardCollection[cardId];
                    // --- CARD LOCKING FIX ---
                    const isLocked = (!cardData || cardData.count === 0) && allCards[cardId].arena > 1;
                    
                    const cardEl = createCardDOM(cardId, true);
                    cardEl.addEventListener('click', () => openCardModal(cardId));
                    
                    if (isLocked) {
                        lockedCardGrid.appendChild(cardEl);
                    } else {
                        collectionCardGrid.appendChild(cardEl);
                    }
                }
                
                updateBattleButtonState();
            }
            
            function renderTowerScreen() {
                towerLevelDisplay.textContent = `Tower Level ${towerLevel}`;
                const stats = towerStats[towerLevel] || towerStats[Object.keys(towerStats).length];
                const dps = (stats.damage / stats.hitSpeed).toFixed(1);
                
                towerInfoStats.innerHTML = `
                    <div>King Health: <span>${stats.kingHealth}</span></div>
                    <div>Princess Health: <span>${stats.princessHealth}</span></div>
                    <div>Damage: <span>${stats.damage}</span></div>
                    <div>Hit Speed: <span>${stats.hitSpeed}s</span></div>
                    <div class="col-span-2 text-center">DPS: <span>${dps}</span></div>
                `;
                
                const costs = towerUpgradeCosts[towerLevel];
                if (costs) {
                    towerInfoProgressContainer.style.display = 'block';
                    const progress = (towerCardCount / costs.cards);
                    towerInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                    towerInfoProgressText.textContent = `${towerCardCount} / ${costs.cards}`;
                    
                    const canUpgrade = towerCardCount >= costs.cards && gold >= costs.gold;
                    towerUpgradeButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                    towerUpgradeButton.disabled = !canUpgrade;
                } else {
                    towerInfoProgressContainer.style.display = 'none';
                    towerUpgradeButton.textContent = 'Max Level (15)';
                    towerUpgradeButton.disabled = true;
                }
            }
            towerUpgradeButton.addEventListener('click', () => {
                const costs = towerUpgradeCosts[towerLevel];
                if (costs && towerCardCount >= costs.cards && gold >= costs.gold) {
                    towerCardCount -= costs.cards;
                    gold -= costs.gold;
                    towerLevel++;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    renderTowerScreen();
                    saveUserData();
                }
            });


            function updateBattleButtonState() {
                if (playerDeck.length === 8) {
                    battleButton.disabled = false;
                    battleButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = 'BATTLE!';
                } else {
                    battleButton.disabled = true;
                    battleButton.classList.add('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = `Deck must have 8 cards (${playerDeck.length}/8)`;
                }
            }

            function initCardSystem() {
                allCards = {
                    // Arena 1
                    'knight': { name: 'Knight', cost: 3, emoji: '‚öîÔ∏è', type: 'Melee', unitClass: Knight, placementRadius: 12, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { health: 500, damage: 65, hitSpeed: 1.2 } } },
                    'archer': { name: 'Archer', cost: 4, emoji: 'üèπ', type: 'Ranged', unitClass: Archer, placementRadius: 10, isFlying: false, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { health: 250, damage: 40, hitSpeed: 1 } } },
                    'giant': { name: 'Giant', cost: 5, emoji: 'üí™', type: 'Tank', unitClass: Giant, placementRadius: 18, isFlying: false, arena: 1, targets: 'Buildings',
                                stats: { 1: { health: 2000, damage: 60, hitSpeed: 1.5, speed: 0.6 } } }, // SLOWED DOWN
                    'goblins': { name: 'Goblins', cost: 2, emoji: 'üë∫', type: 'Swarm', unitClass: Goblins, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1 } } },
                    'skeletons': { name: 'Skeletons', cost: 1, emoji: 'üíÄ', type: 'Swarm', unitClass: Skeletons, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { count: 3, health: 50, damage: 15, hitSpeed: 1 } } },
                    'tinyBot': { name: 'Tiny Bot', cost: 4, emoji: 'ü§ñ', type: 'Melee', unitClass: TinyBot, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { health: 700, damage: 250, hitSpeed: 1.8 } } },
                    'fireball': { name: 'Fireball', cost: 4, emoji: 'üî•', type: 'Spell', radius: 50, placementRadius: 50, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 250 } } },
                    'arrows': { name: 'Arrows', cost: 3, emoji: 'üéØ', type: 'Spell', radius: 80, placementRadius: 80, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 140 } } },
                    // Arena 2
                    'hut': { name: 'Goblin House', cost: 5, emoji: 'üè†', type: 'Building', unitClass: GoblinHut, placementRadius: 20, isFlying: false, arena: 2, targets: '-',
                                stats: { 1: { health: 800, spawn_speed: '5s', lifetime: '30s' } } },
                    'skeletonArmy': { name: 'Skeleton Group', cost: 3, emoji: '‚ò†Ô∏è', type: 'Swarm', unitClass: SkeletonArmy, placementRadius: 10, isFlying: false, arena: 2, targets: 'Ground',
                                stats: { 1: { count: 15, health: 50, damage: 15, hitSpeed: 1 } } },
                    'goblinGang': { name: 'Goblin Group', cost: 3, emoji: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', type: 'Swarm', unitClass: GoblinGang, placementRadius: 10, isFlying: false, arena: 2, targets: 'Air & Ground',
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1, spear_count: 3, spear_health: 60, spear_damage: 25, spear_hitSpeed: 1.2 } } },
                    // Arena 3
                    'fireDragon': { name: 'Fire Dragon', cost: 4, emoji: 'üê≤', type: 'Air', unitClass: FireDragon, placementRadius: 12, isFlying: true, arena: 3, targets: 'Air & Ground',
                                stats: { 1: { health: 800, damage: 120, hitSpeed: 1.5, splashRadius: 25 } } }, // Added splashRadius
                    'barbarians': { name: 'Barbarians', cost: 5, emoji: 'üßî', type: 'Swarm', unitClass: Barbarians, placementRadius: 10, isFlying: false, arena: 3, targets: 'Ground',
                                stats: { 1: { count: 5, health: 300, damage: 60, hitSpeed: 1.4 } } },
                    'battleRam': { name: 'Battle Ram', cost: 4, emoji: 'üå≤', type: 'WinCon', unitClass: BattleRam, placementRadius: 10, isFlying: false, arena: 3, targets: 'Buildings',
                                stats: { 1: { health: 700, damage: 200, chargeSpeed: 2.5, barbLevel: 1 } } },
                    'barbarianHut': { name: 'Barbarian House', cost: 7, emoji: 'üèòÔ∏è', type: 'Building', unitClass: BarbarianHut, placementRadius: 20, isFlying: false, arena: 3, targets: '-',
                                stats: { 1: { health: 1000, spawn_speed: '10s', lifetime: '40s', barbLevel: 1 } } },
                    'tower': { name: 'Tower Upgrade', emoji: 'üëë' }
                };
                
                // --- NEW: Auto-calculate stats for levels 2-15 ---
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue;
                    const card = allCards[cardId];
                    for (let level = 2; level <= 15; level++) { // Cap at 15
                        if (!card.stats[level]) {
                            const prevStats = card.stats[level - 1];
                            const newStats = { ...prevStats };
                            // Increase health and damage by ~10% per level
                            if (newStats.health) newStats.health = Math.round(newStats.health * 1.1);
                            if (newStats.damage) newStats.damage = Math.round(newStats.damage * 1.1);
                            // Handle sub-unit stats
                            if (newStats.spear_health) newStats.spear_health = Math.round(newStats.spear_health * 1.1);
                            if (newStats.spear_damage) newStats.spear_damage = Math.round(newStats.spear_damage * 1.1);
                            // Update levels for spawner cards
                            if (cardId === 'battleRam' || cardId === 'barbarianHut') newStats.barbLevel = level;
                            card.stats[level] = newStats;
                        }
                    }
                }
            }

            // --- ERROR FIX: Added checks for card and card.stats ---
            function openCardModal(cardId) {
                const card = allCards[cardId];
                const cardData = cardCollection[cardId];
                if (!card) return; // Exit if card invalid
                
                const isLocked = (!cardData || cardData.count === 0) && card.arena > 1;
                const displayLevel = (cardData && cardData.level) ? cardData.level : 1;
                
                // --- FIX: Check if card.stats exists ---
                const stats = card.stats ? card.stats[displayLevel] : null;

                cardInfoDisplay.innerHTML = '';
                cardInfoDisplay.appendChild(createCardDOM(cardId, false));
                cardInfoName.textContent = card.name;
                cardInfoType.textContent = card.type || 'Special'; // Fallback
                cardInfoLevel.textContent = isLocked ? "Not Unlocked" : `Level ${displayLevel}`;
                
                cardInfoStats.innerHTML = `<div>Targets: <span>${card.targets || '-'}</span></div>`;
                if (card.isFlying) cardInfoStats.innerHTML += `<div>Placement: <span>Air & Ground</span></div>`;
                
                // --- FIX: Only loop stats if stats is not null ---
                if (stats) {
                    for (const [key, value] of Object.entries(stats)) { 
                        if (key !== 'barbLevel' && key !== 'speed' && key !== 'splashRadius') cardInfoStats.innerHTML += `<div>${key.charAt(0).toUpperCase() + key.slice(1).replace('_', ' ')}: <span>${value}</span></div>`; 
                    }
                    if (card.type === 'Spell') { cardInfoStats.innerHTML += `<div>Radius: <span>${card.radius}</span></div>`; }
                    if (stats.damage && stats.hitSpeed) { const dps = (stats.damage / stats.hitSpeed).toFixed(1); cardInfoStats.innerHTML += `<div>DPS: <span>${dps}</span></div>`; }
                    if (stats.splashRadius) { cardInfoStats.innerHTML += `<div>Splash Radius: <span>${stats.splashRadius}</span></div>`; }
                }

                cardInfoButtons.innerHTML = '';
                cardInfoProgressContainer.style.display = 'none';
                cardInfoButton.style.display = 'none';

                // --- FIX: Also check for !stats ---
                if (isLocked || !stats) {
                    if(isLocked) cardInfoLevel.textContent = `Unlocks in Arena ${card.arena}`;
                } else {
                    // Is unlocked and has stats: Show buttons and progress
                    const isInDeck = playerDeck.includes(cardId);
                    let addRemoveBtn = document.createElement('button');
                    addRemoveBtn.id = 'addRemoveBtn';
                    if (isInDeck) {
                        addRemoveBtn.textContent = 'Remove from Deck';
                        addRemoveBtn.className = 'modal-btn remove';
                        addRemoveBtn.disabled = false;
                        addRemoveBtn.onclick = () => removeFromDeck(cardId);
                    } else {
                        addRemoveBtn.textContent = 'Add to Deck';
                        addRemoveBtn.className = 'modal-btn add';
                        addRemoveBtn.onclick = () => addToDeck(cardId);
                        addRemoveBtn.disabled = playerDeck.length >= 8;
                        if (playerDeck.length >= 8) addRemoveBtn.textContent = 'Deck is Full (8/8)';
                    }
                    cardInfoButtons.appendChild(addRemoveBtn);
                    cardInfoProgressContainer.style.display = 'block';
                    cardInfoButton.style.display = 'block';
                    
                    const displayCount = cardData.count || 0;
                    const costs = upgradeCosts[displayLevel];
                    
                    if (costs) {
                        const progress = (displayCount / costs.cards);
                        cardInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                        cardInfoProgressText.textContent = `${displayCount} / ${costs.cards}`;
                        const canUpgrade = displayCount >= costs.cards && gold >= costs.gold;
                        cardInfoProgressBar.classList.toggle('can-upgrade', canUpgrade);
                        cardInfoButton.className = 'modal-btn upgrade';
                        cardInfoButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                        cardInfoButton.disabled = !canUpgrade;
                        cardInfoButton.onclick = () => upgradeCard(cardId);
                    } else {
                        // Is max level
                        cardInfoProgressContainer.style.display = 'none';
                        cardInfoButton.className = 'modal-btn';
                        cardInfoButton.textContent = 'Max Level (15)';
                        cardInfoButton.disabled = true;
                    }
                }
                cardInfoModal.style.display = 'flex';
            }

            function closeModal() { cardInfoModal.style.display = 'none'; }
            
            async function addToDeck(cardId) {
                if (playerDeck.length < 8) {
                    playerDeck.push(cardId);
                    renderDeckScreen();
                    openCardModal(cardId);
                    await saveUserData();
                }
            }
            async function removeFromDeck(cardId) {
                const index = playerDeck.indexOf(cardId);
                if (index > -1) {
                    playerDeck.splice(index, 1);
                    renderDeckScreen();
                    openCardModal(cardId);
                    await saveUserData();
                }
            }
            async function upgradeCard(cardId) {
                const cardData = cardCollection[cardId];
                const costs = upgradeCosts[cardData.level];
                if (costs && cardData.count >= costs.cards && gold >= costs.gold) {
                    cardData.count -= costs.cards;
                    gold -= costs.gold;
                    cardData.level++;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    renderDeckScreen();
                    openCardModal(cardId);
                    await saveUserData();
                }
            }

            function shuffleDeck(deck) {
                let shuffled = [...deck]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;
            }

            function startGameDecks() {
                // Player
                gameDeck = shuffleDeck(playerDeck);
                hand = [];
                discardPile = [];
                for (let i = 0; i < 4; i++) { hand.push(gameDeck.pop()); }
                nextCard = gameDeck.pop();
                renderHand();
                
                // AI
                const aiArenaLevel = getAIArenaLevel(); // 1, 2, or 3
                const aiCards = getUnlockedCards(false, aiArenaLevel); // AI deck based on its "arena"
                
                // --- AI DECK FIX: Build a random 8-card deck ---
                let aiFullDeck = shuffleDeck(aiCards);
                aiDeck = [];
                for(let i=0; i < 8; i++) {
                    if(aiFullDeck.length === 0) aiFullDeck = shuffleDeck(aiCards); // Refill if not enough cards
                    aiDeck.push(aiFullDeck.pop());
                }
                
                let aiShuffledGameDeck = shuffleDeck(aiDeck);
                aiHand = [];
                aiDiscardPile = [];
                for (let i = 0; i < 4; i++) { if(aiShuffledGameDeck.length > 0) aiHand.push(aiShuffledGameDeck.pop()); }
                if(aiShuffledGameDeck.length > 0) aiNextCard = aiShuffledGameDeck.pop();
                aiDiscardPile = aiShuffledGameDeck; // Put remaining 3 cards in discard
            }
            
            function aiPlayCard(cardId) {
                if (!allCards[cardId]) return; // Safety check
                aiElixir -= allCards[cardId].cost;
                
                const handIndex = aiHand.indexOf(cardId);
                if (handIndex > -1) { 
                    aiDiscardPile.push(aiHand.splice(handIndex, 1)[0]);
                }
                
                aiHand.push(aiNextCard);
                
                if (aiDeck.length === 0) { 
                    aiDeck = shuffleDeck(aiDiscardPile); 
                    aiDiscardPile = []; 
                }
                aiNextCard = aiDeck.pop() || null;
            }

            function renderHand() {
                cardHandEl.innerHTML = '';
                hand.forEach((cardId, index) => {
                    const cardEl = createCardDOM(cardId, false, true);
                    cardEl.dataset.handIndex = index;
                    cardEl.addEventListener('click', () => selectCard(cardEl, cardId));
                    cardHandEl.appendChild(cardEl);
                });
                nextCardSlotEl.innerHTML = '';
                if (nextCard) {
                    nextCardSlotEl.appendChild(createCardDOM(nextCard, true, true));
                }
                updateCardUI();
            }

            function selectCard(cardEl, cardId) {
                if (!gameRunning) return;
                const card = allCards[cardId];
                if (card.cost > playerElixir) { console.log("Not enough elixir!"); return; }
                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                placementIndicator.style.display = 'block';
                placementIndicator.innerHTML = '';
                selectedSpawningUnit = {
                    id: cardId, cost: card.cost, type: card.type, radius: card.radius || 0, placementRadius: card.placementRadius,
                    emoji: card.emoji, isFlying: card.isFlying, handIndex: cardEl.dataset.handIndex
                };
                if (card.type === 'Spell') {
                    isSpawningSpell = true;
                    spellRadius = card.radius;
                    placementIndicator.className = 'spell';
                    placementIndicator.style.width = `${card.radius * 2}px`;
                    placementIndicator.style.height = `${card.radius * 2}px`;
                } else {
                    isSpawningSpell = false;
                    placementRadius = card.placementRadius;
                    placementIndicator.className = '';
                    placementIndicator.style.width = `${placementRadius * 2}px`;
                    placementIndicator.style.height = `${placementRadius * 2}px`;
                    placementIndicator.innerHTML = card.emoji;
                }
                cardEl.classList.add('selected');
            }

            function playCard(cardId, handIndex) {
                playerElixir -= allCards[cardId].cost;
                discardPile.push(cardId);
                hand.splice(handIndex, 1);
                hand.push(nextCard);
                if (gameDeck.length === 0) { gameDeck = shuffleDeck(discardPile); discardPile = []; }
                nextCard = gameDeck.pop();
                renderHand();
            }


            // ==============================================
            // GAME OBJECTS (CLASSES)
            // ==============================================
            class GameObject {
                constructor(x, y, radius, team, health) { this.x = x; this.y = y; this.radius = radius; this.team = team; this.health = health; this.maxHealth = health; this.id = Math.random(); }
                drawHealthBar(level) { 
                    if (this.health < this.maxHealth) { 
                        const barWidth = this.radius * 2; 
                        const barHeight = 5; 
                        const barX = this.x - this.radius; 
                        const barY = this.y - this.radius - (level ? 18 : 10); // Move up if level is shown
                        ctx.fillStyle = '#dc2626'; 
                        ctx.fillRect(barX, barY, barWidth, barHeight); 
                        ctx.fillStyle = '#16a34a'; 
                        ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight); 
                        ctx.strokeStyle = '#000'; 
                        ctx.strokeRect(barX, barY, barWidth, barHeight); 
                    } 
                    if (level) {
                        ctx.font = `800 10px Inter`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = '#fde047'; // yellow-300
                        ctx.fillText(`Lvl ${level}`, this.x, this.y - this.radius - (level ? 18 : 10) - 2);
                    }
                }
                draw(color, emoji, level) { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                    ctx.fillStyle = color; ctx.fill(); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.stroke(); 
                    if (emoji) { 
                        ctx.font = `${this.radius * 1.5}px Arial`; 
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle'; 
                        ctx.fillText(emoji, this.x, this.y); 
                    } 
                    this.drawHealthBar(level); 
                }
                update() {}
            }

            class Tower extends GameObject {
                constructor(x, y, team, isKing = false, level = 1) {
                    const s = towerStats[level] || towerStats[1];
                    super(x, y, isKing ? 25 : 20, team, isKing ? s.kingHealth : s.princessHealth);
                    this.isKing = isKing;
                    this.level = level;
                    this.attackRange = 150;
                    this.attackDamage = s.damage;
                    this.attackCooldown = s.hitSpeed * 60;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.isActive = false;
                    this.activationAnimation = 0;
                    this.dyingAnimationTimer = 0;
                }
                findTarget() { if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) { return; } this.target = null; let closestDist = this.attackRange; for (const obj of gameObjects) { if (obj.team !== this.team && (obj instanceof Unit)) { const dist = getDistance(this, obj); if (dist < closestDist) { closestDist = dist; this.target = obj; } } } }
                attack() { if (this.target) { gameObjects.push(new Projectile(this.x, this.y, this.target, this.team, this.attackDamage)); this.cooldownTimer = this.attackCooldown; } }
                update() { if (this.health <= 0) return; if (this.cooldownTimer > 0) { this.cooldownTimer--; } let kingNeedsToActivate = false; if (this.isKing) { const princessTowersDown = gameObjects.filter(t => t.team === this.team && !t.isKing && t.health > 0).length === 0; if (princessTowersDown || this.health < this.maxHealth) { if (!this.isActive) { this.isActive = true; this.activationAnimation = 30; } kingNeedsToActivate = true; } if (!kingNeedsToActivate) return; } this.findTarget(); if (this.target && this.cooldownTimer <= 0) { this.attack(); } }
                draw() { 
                    ctx.save(); 
                    // Draw Level Text Behind Tower
                    ctx.font = `bold 1.2rem Inter`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillText(this.level, this.x, this.y + 2);

                    if (this.dyingAnimationTimer > 0) { ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); const shakeX = (Math.random() - 0.5) * 4; const shakeY = (Math.random() - 0.5) * 4; ctx.translate(shakeX, shakeY); } 
                    const color = this.team === 'player' ? '#3b82f6' : '#ef4444'; 
                    const emoji = this.isKing ? 'üëë' : 'üë∏'; 
                    ctx.fillStyle = color; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.font = `${this.radius * 1.5}px Arial`; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    ctx.fillText(emoji, this.x, this.y); 
                    if (this.activationAnimation > 0) { this.activationAnimation--; ctx.fillStyle = `rgba(255, 255, 0, ${0.5 * (this.activationAnimation / 30)})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2); ctx.fill(); } 
                    this.drawHealthBar(); // Don't pass level, it's drawn behind
                    ctx.restore(); 
                }
            }

            class Building extends GameObject {
                constructor(x, y, team, level = 1, cardId) {
                    const s = allCards[cardId].stats[level];
                    super(x, y, 20, team, s.health);
                    this.level = level;
                    this.maxLifetime = parseFloat(s.lifetime) * 60;
                    this.lifetime = this.maxLifetime;
                    this.dyingAnimationTimer = 0;
                    this.spawnTimer = 0;
                    this.spawnRate = parseFloat(s.spawn_speed) * 60;
                    this.spawnLevel = level;
                    this.cardId = cardId;
                    this.emoji = allCards[cardId].emoji;
                }
                update() { 
                    if (this.health <= 0) return; 
                    this.lifetime--; 
                    this.health = this.maxHealth * (this.lifetime / this.maxLifetime); 
                    if (this.lifetime <= 0) { this.health = 0; return; } 
                    this.spawnTimer--; 
                    if (this.spawnTimer <= 0) {
                        let unitToSpawn = null;
                        if (this.cardId === 'hut') unitToSpawn = Goblin;
                        if (this.cardId === 'barbarianHut') unitToSpawn = Barbarian;
                        
                        if (unitToSpawn) {
                            gameObjects.push(new unitToSpawn(this.x + (Math.random()*10-5), this.y + (Math.random()*10-5), this.team, this.spawnLevel));
                        }
                        this.spawnTimer = this.spawnRate; 
                    } 
                }
                draw() { 
                    ctx.save(); 
                    if (this.dyingAnimationTimer > 0) { ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); const shakeX = (Math.random() - 0.5) * 4; const shakeY = (Math.random() - 0.5) * 4; ctx.translate(shakeX, shakeY); } 
                    const color = this.team === 'player' ? '#3b82f6' : '#ef4444'; 
                    ctx.fillStyle = color; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.font = `${this.radius * 1.5}px Arial`; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    ctx.fillText(this.emoji, this.x, this.y); 
                    this.drawHealthBar(this.level); // Pass level to show
                    ctx.restore(); 
                }
            }
            class GoblinHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'hut'); } }
            class BarbarianHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'barbarianHut'); } }


            class Unit extends GameObject {
                constructor(x, y, radius, team, health, speed, attackRange, attackDamage, attackCooldown, emoji, isFlying = false, targetsAir = false, level = 1) {
                    super(x, y, radius, team, health);
                    this.speed = speed;
                    this.attackRange = attackRange;
                    this.attackDamage = attackDamage;
                    this.attackCooldown = attackCooldown * 60;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.emoji = emoji;
                    this.isFlying = isFlying;
                    this.targetsAir = targetsAir;
                    this.level = level;
                    this.splashRadius = 0; // Default no splash
                }
                findTarget() {
                    let closestDist = Infinity;
                    let newTarget = null;
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                            if (!this.targetsAir && obj.isFlying) continue; // Can't target air
                            
                            const dist = getDistance(this, obj);
                            if (dist < closestDist) {
                                closestDist = dist;
                                newTarget = obj;
                            }
                        }
                    }
                    this.target = newTarget;
                }
                move() {
                    if (!this.target) return;
                    const dist = getDistance(this, this.target);
                    if (dist <= this.attackRange) { return; }
                    let targetX = this.target.x;
                    let targetY = this.target.y;
                    if (!this.isFlying) {
                        const needsToCross = (this.team === 'player' && this.y > RIVER_Y && this.target.y < RIVER_Y) || (this.team === 'ai' && this.y < RIVER_Y && this.target.y > RIVER_Y);
                        if (needsToCross) {
                            let bridgeX = (this.x < WIDTH / 2) ? LANE_LEFT_X : LANE_RIGHT_X;
                            if(this.target.x < WIDTH / 2) bridgeX = LANE_LEFT_X;
                            else bridgeX = LANE_RIGHT_X;
                            if ( (this.team === 'player' && this.y > (RIVER_Y + 10)) || (this.team === 'ai' && this.y < (RIVER_Y - 10)) ) {
                                targetX = bridgeX;
                                targetY = BRIDGE_Y;
                            }
                        }
                    }
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                }
                attack() { 
                    if (this.target && this.cooldownTimer <= 0) { 
                        if (this.attackRange <= this.radius + this.target.radius + 5) { // Melee
                            this.target.health -= this.attackDamage; 
                            if(this.splashRadius > 0) this.doSplash();
                        } else { // Ranged
                            let projectileType = Projectile;
                            if (this.splashRadius > 0) projectileType = FireballProjectile; // Use fireball for any splash
                            gameObjects.push(new projectileType(this.x, this.y, this.target, this.team, this.attackDamage, this.splashRadius)); 
                        } 
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                doSplash() {
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && obj.id !== this.target.id && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                            if (getDistance(this.target, obj) < this.splashRadius) {
                                obj.health -= this.attackDamage; // For now, splash does full damage
                            }
                        }
                    }
                }
                update() {
                    if (this.health <= 0) {
                        // BATTLE RAM FIX: Check if this unit is a BattleRam and spawn barbs
                        if (this.spawnOnDeath) this.spawnOnDeath();
                        return;
                    }
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                    } else {
                        this.findTarget();
                        this.move();
                        if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        }
                    }
                }
                draw() { const color = this.team === 'player' ? '#60a5fa' : '#f87171'; super.draw(color, this.emoji, this.level); }
            }

            class Knight extends Unit { constructor(x, y, team, level = 1) { const s = allCards['knight'].stats[level]; super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, '‚öîÔ∏è', false, false, level); } }
            class Archer extends Unit { constructor(x, y, team, level = 1) { const s = allCards['archer'].stats[level]; super(x, y, 10, team, s.health, 1.2, 120, s.damage, s.hitSpeed, 'üèπ', false, true, level); } }
            class Giant extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['giant'].stats[level];
                    super(x, y, 18, team, s.health, s.speed, 30, s.damage, s.hitSpeed, 'üí™', false, false, level);
                    this.findTarget = () => {
                        let closestDist = Infinity;
                        let newTarget = null;
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower || obj instanceof Building)) {
                                const dist = getDistance(this, obj);
                                if (dist < closestDist) { closestDist = dist; newTarget = obj; }
                            }
                        }
                        this.target = newTarget;
                    };
                }
            }
            class Goblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; super(x, y, 8, team, s.health, 1.5, 20, s.damage, s.hitSpeed, 'üë∫', false, false, level); } }
            class Skeleton extends Unit { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; super(x, y, 7, team, s.health, 1.6, 20, s.damage, s.hitSpeed, 'üíÄ', false, false, level); } }
            class TinyBot extends Unit { constructor(x, y, team, level = 1) { const s = allCards['tinyBot'].stats[level]; super(x, y, 10, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'ü§ñ', false, false, level); } }
            class Goblins { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class Skeletons { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            
            // --- NEW CARD CLASSES ---
            class SpearGoblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; super(x, y, 8, team, s.spear_health, 1.5, 100, s.spear_damage, s.spear_hitSpeed, 'üéØ', false, true, level); } }
            class GoblinGang { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } for (let i = 0; i < s.spear_count; i++) { gameObjects.push(new SpearGoblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } } }
            class SkeletonArmy { constructor(x, y, team, level = 1) { const s = allCards['skeletonArmy'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*30-15, y + Math.random()*30-15, team, level)); } } }
            class Barbarian extends Unit { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; super(x, y, 11, team, s.health, 1.1, 25, s.damage, s.hitSpeed, 'üßî', false, false, level); } }
            class Barbarians { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Barbarian(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class FireDragon extends Unit { 
                constructor(x, y, team, level = 1) { 
                    const s = allCards['fireDragon'].stats[level]; 
                    super(x, y, 14, team, s.health, 1.2, 110, s.damage, s.hitSpeed, 'üê≤', true, true, level); 
                    this.splashRadius = s.splashRadius;
                } 
            }
            class BattleRam extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['battleRam'].stats[level];
                    super(x, y, 15, team, s.health, 1.2, 25, s.damage, 1, 'üå≤', false, false, level);
                    this.barbLevel = s.barbLevel;
                    this.chargeTimer = 3 * 60;
                    this.isCharging = false;
                    this.findTarget = () => { let closestDist = Infinity; let newTarget = null; for (const obj of gameObjects) { if (obj.team !== this.team && (obj instanceof Tower || obj instanceof Building)) { const dist = getDistance(this, obj); if (dist < closestDist) { closestDist = dist; newTarget = obj; } } } this.target = newTarget; };
                    // --- BATTLE RAM FIX: Add spawnOnDeath function ---
                    this.spawnOnDeath = () => {
                        gameObjects.push(new Barbarian(this.x + 5, this.y, this.team, this.barbLevel));
                        gameObjects.push(new Barbarian(this.x - 5, this.y, this.team, this.barbLevel));
                    };
                }
                update() {
                    // Check for death first
                    if (this.health <= 0) {
                        if (this.spawnOnDeath) {
                            this.spawnOnDeath();
                            this.spawnOnDeath = null; // Spawn only once
                        }
                        return;
                    }
                    // Normal update logic
                    if (this.chargeTimer > 0) { this.chargeTimer--; if(this.chargeTimer === 0) this.isCharging = true; }
                    if (this.isCharging) this.speed = 2.4; else this.speed = 1.2;
                    super.update(); // Run the parent Unit's update (findTarget, move, attack)
                }
                attack() { // Ram only attacks when it hits
                    if (this.target && this.cooldownTimer <= 0) { 
                        this.target.health -= this.attackDamage;
                        this.health = 0; // Ram breaks *after* dealing damage
                        // The spawn logic will now be caught at the start of the *next* update() frame
                    } 
                }
            }

            class Projectile extends GameObject {
                constructor(x, y, target, team, damage, splashRadius = 0) { 
                    super(x, y, 4, team, 1); 
                    this.target = target; 
                    this.damage = damage; 
                    this.speed = 5; 
                    this.splashRadius = splashRadius;
                }
                update() { 
                    if (!this.target || this.target.health <= 0) { this.health = 0; return; } 
                    const dist = getDistance(this, this.target); 
                    if (dist < this.speed) { 
                        this.target.health -= this.damage; 
                        if (this.splashRadius > 0) {
                            for (const obj of gameObjects) {
                                if (obj.team !== this.team && obj.id !== this.target.id && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                    if (getDistance(this.target, obj) < this.splashRadius) {
                                        obj.health -= this.damage; // Splash does full damage
                                    }
                                }
                            }
                        }
                        this.health = 0; 
                        return; 
                    } 
                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); 
                    this.x += Math.cos(angle) * this.speed; 
                    this.y += Math.sin(angle) * this.speed; 
                }
                draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.team === 'player' ? '#a5f3fc' : '#fecaca'; ctx.fill(); }
            }
            class FireballProjectile extends Projectile {
                draw() { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius * (this.splashRadius > 0 ? 2.5 : 2), 0, Math.PI * 2); // Bigger if splash
                    ctx.fillStyle = this.team === 'player' ? '#ffc107' : '#ff6f00'; 
                    ctx.fill(); 
                }
            }

            class Spell extends GameObject {
                constructor(x, y, team, damage, radius, emoji) {
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.animationTimer = 30;
                    this.maxAnimationTimer = 30;
                    this.hit = false;
                    this.emoji = emoji;
                }
                update() {
                    if (!this.hit) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    obj.health -= this.damage;
                                }
                            }
                        }
                        this.hit = true;
                    }
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / this.maxAnimationTimer;
                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;
                    if (this.emoji === 'üéØ') {
                        ctx.fillStyle = `rgba(139, 69, 19, ${alpha * 0.2})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `20px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = `rgba(101, 67, 33, ${alpha})`;
                        let yOffset = -this.radius + (this.radius * 2 * (1 - progress));
                        ctx.globalAlpha = alpha;
                        ctx.fillText('‚¨áÔ∏è', this.x - 20, this.y - 20 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x + 20, this.y - 10 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x, this.y + 20 + yOffset);
                        ctx.globalAlpha = 1;
                    } else if (this.emoji === 'üî•') {
                        ctx.fillStyle = `rgba(253, 224, 71, ${alpha * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `${this.radius * 2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.globalAlpha = alpha;
                        ctx.fillText(this.emoji, this.x, this.y);
                        ctx.globalAlpha = 1;
                    }
                }
            }


            // ==============================================
            // GAME LOGIC
            // ==============================================
            
            function getDistance(obj1, obj2) {
                const dx = obj1.x - obj2.x; const dy = obj1.y - obj2.y; return Math.sqrt(dx * dx + dy * dy);
            }

            function drawArena() {
                // River
                if (currentArenaTheme === 'arena-3') {
                    ctx.fillStyle = '#f45d22'; // Lava
                } else if (currentArenaTheme === 'arena-2') {
                    ctx.fillStyle = '#4a90e2'; // Lighter blue
                } else {
                    ctx.fillStyle = '#3b82f6'; // Default blue
                }
                ctx.fillRect(0, RIVER_Y - 10, WIDTH, 20);
                
                // Bridges
                ctx.fillStyle = '#a16207'; // Brown
                ctx.fillRect(LANE_LEFT_X - 25, RIVER_Y - 15, 50, 30);
                ctx.fillRect(LANE_RIGHT_X - 25, RIVER_Y - 15, 50, 30);

                // Spawnable Area
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(10, RIVER_Y, WIDTH - 20, (HEIGHT - 10) - RIVER_Y);
                ctx.setLineDash([]);
            }

            // --- AI LEVEL FIX: Return stat level ---
            function getAIStatLevel() {
                if (trophies >= 500) return 5; 
                if (trophies >= 250) return 3; 
                return 1;
            }
            // --- AI LEVEL FIX: Return arena level ---
            function getAIArenaLevel() {
                if (trophies >= 500) return 3; 
                if (trophies >= 250) return 2; 
                return 1;
            }

            function initGame() {
                gameObjects = [];
                playerElixir = 3;
                aiElixir = 3;
                selectedSpawningUnit = null;
                isSpawningSpell = false;
                gameRunning = true;
                aiThinkTimer = 0;
                gameTimer = REGULATION_TIME;
                isOvertime = false;
                isTieBreaker = false;
                tieBreakerTick = 0;
                
                messageOverlay.style.display = 'none';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';

                const aiLevel = getAIStatLevel(); // Get AI *stat* level (1, 3, or 5)
                gameObjects.push(new Tower(LANE_LEFT_X, HEIGHT - 100, 'player', false, towerLevel));
                gameObjects.push(new Tower(LANE_RIGHT_X, HEIGHT - 100, 'player', false, towerLevel));
                gameObjects.push(new Tower(WIDTH / 2, HEIGHT - 50, 'player', true, towerLevel));
                gameObjects.push(new Tower(LANE_LEFT_X, 100, 'ai', false, aiLevel));
                gameObjects.push(new Tower(LANE_RIGHT_X, 100, 'ai', false, aiLevel));
                gameObjects.push(new Tower(WIDTH / 2, 50, 'ai', true, aiLevel));

                startGameDecks();
                updateCardUI();
            }

            function runAI() {
                const aiLevel = getAIStatLevel();
                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit && o.y < RIVER_Y + 50);
                
                // 1. Defensive Logic
                if (playerUnits.length > 0) {
                    let bestCardId = null;
                    if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof GoblinGang) && aiHand.includes('arrows') && aiElixir >= allCards['arrows'].cost) {
                        bestCardId = 'arrows';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) {
                        bestCardId = 'tinyBot';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('barbarians') && aiElixir >= allCards['barbarians'].cost) {
                        bestCardId = 'barbarians';
                    } else if (playerUnits.some(u => u instanceof FireDragon) && aiHand.includes('archer') && aiElixir >= allCards['archer'].cost) {
                        bestCardId = 'archer';
                    } else if (aiHand.includes('goblins') && aiElixir >= allCards['goblins'].cost) {
                        bestCardId = 'goblins';
                    }
                    if (bestCardId) { spawnAIUnit(bestCardId, aiLevel, true); return; }
                }
                
                // 2. Offensive Logic
                if (aiElixir > 8) {
                    let bestCardId = null;
                    if(aiHand.includes('giant') && aiElixir >= allCards['giant'].cost) { bestCardId = 'giant'; }
                    else if(aiHand.includes('barbarianHut') && aiElixir >= allCards['barbarianHut'].cost) { bestCardId = 'barbarianHut'; }
                    else if (aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) { bestCardId = 'tinyBot'; }
                    if (bestCardId) { spawnAIUnit(bestCardId, aiLevel, false); return; }
                }
                
                // 3. Spell Logic
                if (aiElixir === MAX_ELIXIR && aiHand.includes('fireball') && Math.random() < 0.2) {
                    spawnAIUnit('fireball', aiLevel, false);
                    return;
                }

                // 4. --- AI BRAIN FIX ---
                // If elixir is high and no "smart" move was found, play *any* card
                if (aiElixir >= 7) {
                    // Find any playable card
                    let fallbackCardId = aiHand.find(cardId => allCards[cardId] && allCards[cardId].cost <= aiElixir);
                    if (fallbackCardId) {
                        spawnAIUnit(fallbackCardId, aiLevel, false); // Play it offensively
                        return;
                    }
                }
            }

            function spawnAIUnit(cardId, level, isDefensive = false) {
                const card = allCards[cardId];
                if (!card || card.cost > aiElixir) return;
                if (card.type === 'Spell') {
                    let target = null;
                    const damage = card.stats[level].damage;
                    if (cardId === 'fireball') {
                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0 && o.health < 600);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Barbarian);
                    } else if (cardId === 'arrows') {
                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Skeleton || o instanceof SkeletonArmy || o instanceof GoblinGang));
                    }
                    if (target) {
                        gameObjects.push(new Spell(target.x, target.y, 'ai', damage, card.radius, card.emoji));
                        aiPlayCard(cardId);
                    }
                    return;
                }
                const spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;
                const spawnY = isDefensive ? (RIVER_Y - 20) : (50 + Math.random() * (RIVER_Y - 100));
                let spawnRadius = card.placementRadius;
                let canSpawn = true;
                for (const obj of gameObjects) {
                    const dist = getDistance({x: spawnX, y: spawnY}, obj);
                    if (dist < spawnRadius + obj.radius) { canSpawn = false; break; }
                }
                if (canSpawn && card.unitClass) {
                    const newUnit = new card.unitClass(spawnX, spawnY, 'ai', level);
                    // --- BUILDING SPAWN FIX ---
                    if (card.type.includes('Swarm')) {
                        // Swarm class handles its own object pushing
                    } else if (card.type.includes('Building')) {
                        gameObjects.push(newUnit); // Push the building
                    }
                    else {
                        gameObjects.push(newUnit); // Push single unit
                    }
                    aiPlayCard(cardId);
                }
            }

            function updateCardUI() {
                const elixirInt = Math.floor(playerElixir);
                elixirBar.style.width = `${(playerElixir / MAX_ELIXIR) * 100}%`;
                elixirText.textContent = elixirInt;
                document.querySelectorAll('#cardHand .card-ui').forEach(cardEl => {
                    const cost = parseInt(cardEl.dataset.cost);
                    if (cost > elixirInt) { cardEl.classList.add('disabled'); }
                    else { cardEl.classList.remove('disabled'); }
                });
            }

            function updateTimerAndElixir() {
                const totalSeconds = Math.max(0, Math.floor(gameTimer / 60));
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                if (isOvertime) {
                    timerDisplay.classList.add('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 3 : BASE_ELIXIR_REGEN_RATE * 2;
                } else {
                    timerDisplay.classList.remove('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 2 : BASE_ELIXIR_REGEN_RATE;
                }
                if (playerElixir < MAX_ELIXIR) {
                    playerElixir += currentElixirRate;
                    playerElixir = Math.min(playerElixir, MAX_ELIXIR);
                }
                if (aiElixir < MAX_ELIXIR) {
                    aiElixir += currentElixirRate;
                    aiElixir = Math.min(aiElixir, MAX_ELIXIR);
                }
            }

            function checkGameOver() {
                const playerKing = gameObjects.find(t => t.team === 'player' && t.isKing);
                const aiKing = gameObjects.find(t => t.team === 'ai' && t.isKing);
                if (gameRunning && aiKing && aiKing.health <= 0) { showWinScreen(); }
                else if (gameRunning && playerKing && playerKing.health <= 0) { showLoseScreen(); }
            }

            function checkOvertime() {
                if (!gameRunning) return;
                const getTowerCount = (team) => { return gameObjects.filter(obj => obj.team === team && (obj instanceof Tower) && obj.health > 0).length; };
                const playerTowers = getTowerCount('player');
                const aiTowers = getTowerCount('ai');
                if (playerTowers === aiTowers) {
                    isOvertime = true;
                    gameTimer = OVERTIME_TIME;
                    currentElixirRate = BASE_ELIXIR_REGEN_RATE * 2;
                } else if (playerTowers > aiTowers) {
                    showWinScreen();
                } else {
                    showLoseScreen();
                }
            }

            function startTieBreaker() {
                if (!gameRunning) return;
                gameRunning = true; isTieBreaker = true; gameObjects = gameObjects.filter(obj => (obj instanceof Tower));
                messageText.textContent = 'TIEBREAKER!';
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                setTimeout(() => { if (isTieBreaker) messageOverlay.style.display = 'none'; }, 2000);
            }

            function tieBreakerLoop() {
                tieBreakerTick--;
                if (tieBreakerTick <= 0) {
                    tieBreakerTick = 10;
                    let playerKing = null;
                    let aiKing = null;
                    for (const obj of gameObjects) {
                        if (obj instanceof Tower) { obj.health -= 20; }
                        if (obj.isKing && obj.team === 'player') playerKing = obj;
                        if (obj.isKing && obj.team === 'ai') aiKing = obj;
                    }
                    if (aiKing && aiKing.health <= 0 && playerKing && playerKing.health > 0) {
                        isTieBreaker = false;
                        showWinScreen();
                    } else if (playerKing && playerKing.health <= 0) {
                        isTieBreaker = false;
                        showLoseScreen();
                    }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT); drawArena(); gameObjects.forEach(obj => obj.draw());
                if (isTieBreaker) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            async function showWinScreen() {
                if (!gameRunning) return;
                gameRunning = false;
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                trophies += 30;
                updateArena();
                trophyDisplay.textContent = `üèÜ ${trophies}`;
                gold += 50;
                goldDisplay.textContent = `üí∞ ${gold}`;
                if (trophyChests.length < 4) {
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                }
                messageText.textContent = 'You Win! (+30 üèÜ, +50 üí∞, üì¶)';
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                await saveUserData();
            }

            async function showLoseScreen(message = 'You Lose!') {
                if (!gameRunning) return;
                gameRunning = false;
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                const trophiesToLose = Math.min(30, trophies - currentArenaFloor);
                trophies -= trophiesToLose;
                trophyDisplay.textContent = `üèÜ ${trophies}`;
                messageText.textContent = `${message} (-${trophiesToLose} üèÜ)`;
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                await saveUserData();
            }

            function gameLoop(timestamp) {
                if (isTieBreaker) {
                    tieBreakerLoop();
                    return;
                }
                if (!gameRunning) {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;
                gameTimer--;
                updateTimerAndElixir();
                aiThinkTimer--;
                if (aiThinkTimer <= 0) {
                    runAI();
                    aiThinkTimer = 30 + Math.random() * 30; // Think every 0.5-1s
                }
                gameObjects.forEach(obj => obj.update());
                
                // --- BATTLE RAM FIX: Check for dead units with spawnOnDeath ---
                let newObjects = [];
                gameObjects = gameObjects.filter(obj => {
                    if (obj.health > 0) return true;

                    // If unit is dead, check if it needs to spawn something
                    if (obj.spawnOnDeath) {
                        obj.spawnOnDeath();
                        obj.spawnOnDeath = null; // Ensure it only spawns once
                    }

                    if (obj instanceof Unit || obj instanceof Projectile || obj instanceof Spell) { return false; }
                    if (obj instanceof Tower || obj instanceof Building) {
                        if (obj.isKing) { checkGameOver(); return true; }
                        if (obj.dyingAnimationTimer === 0) { obj.dyingAnimationTimer = 30; }
                        obj.dyingAnimationTimer--;
                        return obj.dyingAnimationTimer > 0;
                    }
                    return false;
                });
                
                updateCardUI();
                if (gameTimer <= 0) {
                    if (isOvertime) { startTieBreaker(); }
                    else { checkOvertime(); }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                drawArena();
                gameObjects.forEach(obj => obj.draw());
                if (gameRunning) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            // --- Event Listeners ---
            
            function getCanvasClickPos(e) {
                const rect = canvas.getBoundingClientRect();
                let clickX, clickY;
                if (e.touches && e.touches.length > 0) { clickX = e.touches[0].clientX; clickY = e.touches[0].clientY; }
                else if (e.changedTouches && e.changedTouches.length > 0) { clickX = e.changedTouches[0].clientX; clickY = e.changedTouches[0].clientY; }
                else { clickX = e.clientX; clickY = e.clientY; }
                const x = clickX - rect.left;
                const y = clickY - rect.top;
                return { x, y };
            }

            function checkPlacement(x, y, radius) {
                if (y < RIVER_Y || y > HEIGHT - 10) { return false; }
                for (const obj of gameObjects) {
                    const dist = getDistance({x: x, y: y}, obj);
                    if (dist < radius + obj.radius) { return false; }
                }
                return true;
            }

            function movePlacementIndicator(e) {
                if (!selectedSpawningUnit) return;
                const { x, y } = getCanvasClickPos(e);
                const clampedX = Math.max(0, Math.min(WIDTH, x));
                const clampedY = Math.max(0, Math.min(HEIGHT, y));
                let radius = isSpawningSpell ? spellRadius : placementRadius;
                
                // FIX: Use top/left
                placementIndicator.style.left = `${clampedX}px`;
                placementIndicator.style.top = `${clampedY}px`;
                
                if (isSpawningSpell) {
                    canPlace = true;
                } else {
                    canPlace = checkPlacement(clampedX, clampedY, placementRadius);
                }
                placementIndicator.classList.toggle('cant-place', !canPlace);
            }
            
            canvas.addEventListener('mousemove', movePlacementIndicator);
            canvas.addEventListener('touchmove', (e) => {
                if (!selectedSpawningUnit) return;
                e.preventDefault();
                movePlacementIndicator(e);
            }, { passive: false });


            const spawnOnCanvas = (e) => {
                if (!selectedSpawningUnit || !gameRunning || !canPlace) {
                    if(!canPlace && selectedSpawningUnit) console.log("Cannot spawn there!");
                    isSpawningSpell = false;
                    placementIndicator.style.display = 'none';
                    selectedSpawningUnit = null;
                    document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                    updateCardUI();
                    return;
                };
                
                const { x, y } = getCanvasClickPos(e);
                const clampedX = Math.max(0, Math.min(WIDTH, x));
                const clampedY = Math.max(0, Math.min(HEIGHT, y));
                
                const card = allCards[selectedSpawningUnit.id];
                const level = cardCollection[selectedSpawningUnit.id] ? cardCollection[selectedSpawningUnit.id].level : 1;
                
                if (card.type === 'Spell') {
                    const damage = card.stats[level].damage;
                    gameObjects.push(new Spell(clampedX, clampedY, 'player', damage, card.radius, card.emoji));
                    playCard(selectedSpawningUnit.id, selectedSpawningUnit.handIndex);
                } else {
                    const newUnit = new card.unitClass(clampedX, clampedY, 'player', level);
                    // --- BUILDING SPAWN FIX ---
                    if (card.type.includes('Swarm')) {
                        // Swarm class handles its own object pushing
                    } else if (card.type.includes('Building')) {
                        gameObjects.push(newUnit); // Push the building
                    }
                    else {
                        gameObjects.push(newUnit); // Push single unit
                    }
                    playCard(selectedSpawningUnit.id, selectedSpawningUnit.handIndex);
                }

                isSpawningSpell = false;
                placementIndicator.style.display = 'none';
                selectedSpawningUnit = null;
                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                updateCardUI();
            }
            
            canvas.addEventListener('click', spawnOnCanvas);
            canvas.addEventListener('touchend', (e) => {
                if (!selectedSpawningUnit) return;
                e.preventDefault();
                spawnOnCanvas(e);
            }, { passive: false });

            cardInfoCloseBtn.addEventListener('click', closeModal);
            
            // --- Init App ---
            initCardSystem(); // Define all cards
            
            // --- FIX: Stop auto-login ---
            onAuthStateChanged(auth, (user) => {
                if (isInitialAuthCheck) {
                    isInitialAuthCheck = false; // Stop the first auto-login check
                    return; // Do nothing, stay on login screen
                }
                // This will only run *after* the user clicks "Sign in with Google"
                handleAuth(user);
            });
        };

    </script>
</body>
</html>
