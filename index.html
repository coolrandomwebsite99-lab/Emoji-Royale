<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Royale</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Google Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            background-color: #2a623d; /* Arena green */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            display: block;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            /* cursor: pointer; */ /* Removed to allow for better drag detection */
            transition: background-color 0.5s ease; /* For arena theme change */
        }
        /* Arena Themes */
        canvas.arena-2 { background-color: #6abf82; }
        canvas.arena-3 { 
            background-color: #4a4a4a;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        #messageOverlay, #chestOpenOverlay, #debugPasswordOverlay, #saveKeyOverlay, #loadKeyOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            border-radius: 8px;
            z-index: 50;
            padding: 1rem;
        }
        #messageOverlay button, #chestOpenOverlay button, .login-btn, .debug-btn, #debugPasswordOverlay button,
        #saveKeyOverlay button, #loadKeyOverlay button {
            font-size: 1rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            margin-top: 20px;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80%;
            max-width: 300px;
        }
        #messageOverlay button:hover, #chestOpenOverlay button:hover, .login-btn:hover, .debug-btn:hover, #debugPasswordOverlay button:hover,
        #saveKeyOverlay button:hover, #loadKeyOverlay button:hover {
            background-color: #4338ca;
        }
        .login-btn.google {
            background-color: #dc2626; /* red-600 */
        }
        .login-btn.google:hover {
            background-color: #b91c1c; /* red-700 */
        }
        .login-btn.guest {
            background-color: #6b7280; /* gray-500 */
        }
        .login-btn.guest:hover {
            background-color: #4b5563; /* gray-600 */
        }
        /* Key input/output */
        #debugPasswordInput, #saveKeyOutput, #loadKeyInput {
            font-size: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 2px solid #6b7280;
            background-color: #1f2937;
            color: white;
            margin-top: 20px;
            width: 80%;
            max-width: 300px;
            text-align: center;
        }
        #saveKeyOutput {
            font-size: 0.9rem;
            font-family: monospace;
            word-break: break-all;
            height: 120px;
            resize: none;
        }
        #loadKeyInput {
            height: 120px;
            resize: none;
        }
        .cancel-btn, #saveKeyCloseBtn, #loadKeyCloseBtn {
            background-color: #dc2626 !important; /* red-600 */
        }
        .cancel-btn:hover, #saveKeyCloseBtn:hover, #loadKeyCloseBtn:hover {
            background-color: #b91c1c !important; /* red-700 */
        }
        #generateKeyBtn:disabled {
            background-color: #6b7280;
            cursor: not-allowed;
        }
        #copyKeyBtn {
            background-color: #16a34a; /* green-600 */
        }
        #copyKeyBtn:hover {
            background-color: #15803d; /* green-700 */
        }

        /* Hide screens by default */
        .screen {
            display: none;
            width: 100%;
            height: 100vh;
            overflow-y: auto;
        }
        /* Show the active screen */
        .screen.active {
            display: flex;
        }
        /* Loading Screen Animation */
        @keyframes pulse-king {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .animate-pulse-king {
            animation: pulse-king 2s infinite;
        }
        /* Bottom Nav */
        #bottomNav {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            max-width: 400px;
            margin: 0 auto;
            z-index: 20;
        }
        /* Card Style */
        .card-ui {
            width: 80px;
            height: 112px;
            background-color: #4b5563; /* gray-600 */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            padding: 4px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: white;
            cursor: pointer;
            user-select: none;
            border: 4px solid #374151; /* gray-700 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            overflow: hidden;
            transition: transform 0.1s, border-color 0.1s, box-shadow 0.1s;
        }
        .card-ui.selected {
            border-color: #ec4899; /* pink-500 */
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 0 20px #ec4899;
        }
        .card-ui.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(80%);
        }
        .card-ui-small {
            width: 60px;
            height: 84px;
            border-radius: 6px;
        }
        .card-ui-name {
            font-size: 0.7rem;
            background-color: rgba(0,0,0,0.6);
            padding: 0 4px;
            border-radius: 4px;
            z-index: 2;
        }
        .card-ui-emoji {
            font-size: 2.5rem;
            line-height: 1;
            z-index: 2;
        }
         .card-ui-small .card-ui-emoji {
            font-size: 2rem;
        }
        .card-ui-type {
            font-size: 0.6rem;
            color: #d1d5db; /* gray-300 */
            z-index: 2;
        }
        .card-ui-cost {
            position: absolute;
            top: 2px;
            left: 2px;
            background-color: #7e22ce;
            border: 2px solid #a855f7;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            z-index: 3;
        }
        .card-ui-level {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 0.7rem;
            font-weight: 800;
            background-color: rgba(0,0,0,0.7);
            color: #fde047; /* yellow-300 */
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }
        .card-ui-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background-color: #1f2937; /* gray-800 */
            z-index: 1;
        }
        .card-ui-progress {
            height: 100%;
            background-color: #3b82f6; /* blue-500 */
            transition: width 0.3s;
        }
        .card-ui .can-upgrade {
            background-color: #fde047; /* yellow-300 */
        }
        /* NEW: Locked Card Styles */
        .card-ui-locked {
            filter: grayscale(100%);
            opacity: 0.6;
        }
        .card-ui-locked-arena {
            position: absolute;
            bottom: 4px;
            left: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            background-color: rgba(0,0,0,0.8);
            color: #fde047;
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }


        /* Card Info Modal */
        #cardInfoModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #cardInfoModalContent {
            background-color: #374151; /* gray-700 */
            border-radius: 12px;
            padding: 1.5rem;
            width: 90%;
            max-width: 350px;
            border: 4px solid #4b5563; /* gray-600 */
            position: relative;
        }
        #cardInfoCloseBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 2rem;
            line-height: 1;
            cursor: pointer;
            color: #9ca3af; /* gray-400 */
        }
        #cardInfoStats, #towerInfoStats {
            font-size: 0.9rem;
            color: #d1d5db; /* gray-300 */
        }
        #cardInfoStats span, #towerInfoStats span {
            color: white;
            font-weight: 600;
        }
        .modal-btn {
            width: 100%;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 0.75rem;
            margin-top: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-btn.add { background-color: #16a34a; color: white; }
        .modal-btn.remove { background-color: #dc2626; color: white; }
        .modal-btn.upgrade { background-color: #16a34a; color: white; }
        .modal-btn:disabled {
            background-color: #6b7280; /* gray-500 */
            color: #d1d5db; /* gray-300 */
            cursor: not-allowed;
        }
        #cardInfoProgressContainer, #towerInfoProgressContainer {
            width: 100%;
            background-color: #1f2937;
            border-radius: 5px;
            height: 20px;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }
        #cardInfoProgressBar, #towerInfoProgressBar {
            height: 100%;
            background-color: #3b82f6;
        }
        #cardInfoProgressText, #towerInfoProgressText {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
        }
        /* Troop Ghost & Spell Radius */
        #placementIndicator {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 20;
            font-size: 2rem;
            opacity: 0.7;
            text-align: center;
            line-height: 1;
            /* FIX: Use top/left instead of transform */
            transform: translate(-50%, -50%); /* Keep this for centering */
        }
        #placementIndicator.spell {
            border: 4px dashed white;
            background: rgba(255, 255, 255, 0.2);
        }
        #placementIndicator.cant-place {
            background: rgba(220, 38, 38, 0.4);
            border-color: #dc2626;
        }
        /* Chest Reward Styles */
        #chestRewardList {
            font-size: 1.2rem;
            margin-top: 1rem;
        }
        #chestRewardList div {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        /* Red 'Can't Place' Overlay */
        #placementOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(220, 38, 38, 0.2),
                rgba(220, 38, 38, 0.2) 10px,
                rgba(220, 38, 38, 0.3) 10px,
                rgba(220, 38, 38, 0.3) 20px
            );
            z-index: 10;
            pointer-events: none;
            display: none;
            /* Clip-path to cut out the player's area */
            /* This will be updated dynamically by JS */
            clip-path: path('M0 0 L400 0 L400 250 L0 250 Z'); /* Default: Block top half */
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-2">
    
    <!-- 
    ========================================================
    SCREEN: LOGIN (FIXED)
    ========================================================
    -->
    <div id="loginScreen" class="screen active flex-col justify-center items-center">
        <div class="text-6xl">üëë</div>
        <h1 class="text-4xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-300">Save your progress!</p>
        <p id="loginError" class="text-lg mt-2 text-red-500 font-bold h-6"></p> 
        
        <!-- REMOVED Google Sign in for now -->
        <!-- <button id="googleLoginBtn" class="login-btn google"> ... </button> -->
        
        <!-- NEW: Load from Key Button -->
        <button id="loadKeyBtn" class="login-btn guest">
            Enter Save Key
        </button>
        
        <!-- "Play as Guest (No Save)" button -->
        <button id="trueGuestLoginBtn" class="login-btn guest">
            Play as Guest (No Save)
        </button>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: LOADING
    ========================================================
    -->
    <div id="loadingScreen" class="screen flex-col justify-center items-center bg-gray-900">
        <div class="text-8xl animate-pulse-king">üëë</div>
        <h1 class="text-3xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-300">Loading...</p>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: MENU (HOME)
    ========================================================
    -->
    <div id="menuScreen" class="screen flex-col items-center p-4">
        <!-- Main Content Area -->
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <!-- Header -->
            <div class="flex justify-between items-center w-full">
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="goldDisplay" class="text-xl font-bold text-yellow-400">üí∞ 500</span>
                </div>
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="trophyDisplay" class="text-xl font-bold text-blue-400">üèÜ 0</span>
                </div>
            </div>
            
            <!-- Arena Display -->
            <div class="flex flex-col items-center my-8">
                <span id="arenaEmoji" class="text-8xl">üèûÔ∏è</span>
                <h2 id="arenaName" class="text-2xl font-bold mt-2">Arena 1: Emoji Valley</h2>
            </div>
            
            <!-- Battle Button -->
            <button id="battleButton" class="bg-red-600 hover:bg-red-700 text-white w-3/4 py-4 rounded-lg shadow-lg text-3xl font-extrabold transition transform hover:scale-105">
                BATTLE!
            </button>
            
            <!-- Chest Slots -->
            <div class="mt-8 w-full">
                <h3 class="text-xl font-bold text-center mb-2">Your Chests</h3>
                <div id="chestSlots" class="grid grid-cols-4 gap-2">
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                </div>
            </div>
            
            <!-- NEW: Save Data Button -->
            <button id="saveDataBtn" class="login-btn bg-blue-600 hover:bg-blue-700 mt-8">
                Save Data
            </button>
        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-yellow-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <!-- NEW: Debug Button -->
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: DECK
    ========================================================
    -->
    <div id="deckScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 id="deckCount" class="text-2xl font-bold">Deck (0 / 8)</h1>
            <div id="deckCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Deck cards injected by JS -->
            </div>
            
            <hr class="border-gray-600 w-full my-4">
            
            <h2 class="text-2xl font-bold">Your Collection</h2>
            <div id="collectionCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Collection cards injected by JS -->
            </div>

            <!-- NEW: Locked Cards Section -->
            <hr class="border-gray-600 w-full my-4">
            <h2 class="text-2xl font-bold">Not Unlocked</h2>
            <div id="lockedCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Locked cards injected by JS -->
            </div>

        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-yellow-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: TOWER
    ========================================================
    -->
    <div id="towerScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Tower Power</h1>
            <p id="towerLevelDisplay" class="text-lg text-yellow-300 font-bold">Tower Level 1</p>
            <div class="text-8xl my-4">üëë</div>
            
            <!-- Stats -->
            <div class="bg-gray-800 p-4 rounded-lg mt-4 w-full space-y-2">
                <h3 class="text-xl font-bold text-center">Tower Stats</h3>
                <div id="towerInfoStats" class="grid grid-cols-2 gap-2">
                    <!-- Stats injected by JS -->
                </div>
            </div>
            
            <!-- Upgrade -->
            <div class="bg-gray-800 p-4 rounded-lg mt-8 w-full">
                <h3 class="text-xl font-bold text-center">Upgrade Tower</h3>
                <div id="towerInfoProgressContainer">
                    <div id="towerInfoProgressBar" style="width: 0%;"></div>
                    <div id="towerInfoProgressText">0 / 0</div>
                </div>
                <button id="towerUpgradeButton" class="modal-btn upgrade" disabled>
                    Upgrade
                </button>
            </div>
        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn active flex flex-col items-center text-yellow-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: DEBUG (NEW)
    ========================================================
    -->
    <div id="debugScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Debug Menu</h1>
            <p class="text-gray-400 text-center my-4">For testing only!</p>
            
            <button id="debugArena2" class="debug-btn bg-green-600 hover:bg-green-700">Jump to Arena 2 (250 üèÜ)</button>
            <button id="debugArena3" class="debug-btn bg-red-600 hover:bg-red-700">Jump to Arena 3 (500 üèÜ)</button>
            <button id="debugUnlockAll" class="debug-btn bg-blue-600 hover:bg-blue-700">Unlock All Cards</button>
            <button id="debugUpgradeAll" class="debug-btn bg-purple-600 hover:bg-purple-700">Upgrade All Cards +1 Lvl</button>
            <button id="debugGetChest" class="debug-btn bg-yellow-600 hover:bg-yellow-700">Get a Free Chest üì¶</button>
            <button id="debugAddGold" class="debug-btn bg-yellow-400 text-gray-900 hover:bg-yellow-300">Get 1000 Gold üí∞</button>
            <button id="debugReset" class="debug-btn bg-gray-600 hover:bg-gray-700">Reset Account (New User)</button>

        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn active flex flex-col items-center text-yellow-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>


    <!-- 
    ========================================================
    SCREEN: GAME
    ========================================================
    -->
    <div id="gameScreen" class="screen flex-col items-center p-2">
        <div id="gameContainer">
            <div id="timerDisplay" class="absolute top-2 left-1/2 -translate-x-1/2 text-2xl font-bold bg-black bg-opacity-50 px-4 py-1 rounded-lg z-10">2:00</div>
            <!-- NEW: Placement Overlay -->
            <div id="placementOverlay"></div>
            <canvas id="gameCanvas" width="400" height="500"></canvas>
            <div id="messageOverlay">
                <span id="messageText"></span>
                <button id="startButton">Start Game</button>
                <button id="menuButton" class="bg-red-600 hover:bg-red-700">Back to Menu</button>
            </div>
            <!-- Placement "Ghost" Indicator -->
            <div id="placementIndicator"></div>
        </div>

        <!-- Card UI Bar -->
        <div class="bg-gray-800 p-4 shadow-inner w-full max-w-md mt-2 rounded-lg" style="padding-bottom: env(safe-area-inset-bottom, 1rem);">
            <div class="max-w-md mx-auto">
                <!-- Elixir Bar -->
                <div class="mb-4">
                    <div class="w-full bg-gray-700 rounded-full h-6 border-2 border-gray-900 shadow-inner">
                        <div id="elixirBar" class="bg-purple-500 h-full rounded-full transition-all duration-100 ease-linear text-right pr-2 font-bold" style="width: 30%;">
                            <span id="elixirText">3</span>
                        </div>
                    </div>
                </div>
                
                <!-- 4-Card Hand + Next Card -->
                <div class="flex justify-center items-end space-x-2">
                    <div class="flex flex-col items-center">
                        <span class="text-xs mb-1">NEXT</span>
                        <div id="nextCardSlot" class="card-ui-small"></div>
                    </div>
                    <div id="cardHand" class="flex justify-center space-x-2"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    CARD INFO MODAL
    ========================================================
    -->
    <div id="cardInfoModal">
        <div id="cardInfoModalContent">
            <span id="cardInfoCloseBtn">&times;</span>
            <div class="flex items-center space-x-4">
                <div id="cardInfoDisplay" class="flex-shrink-0"></div>
                <div>
                    <h2 id="cardInfoName" class="text-2xl font-bold">Card Name</h2>
                    <p id="cardInfoType" class="text-lg text-gray-400">Card Type</p>
                    <p id="cardInfoLevel" class="text-lg font-bold text-yellow-300">Level 1</p>
                </div>
            </div>
            <hr class="border-gray-500 my-4">
            <div id="cardInfoStats" class="space-y-1"></div>
            <!-- NEW: Add/Remove Button container -->
            <div id="cardInfoButtons">
                <!-- Add/Remove button injected by JS -->
            </div>
            <div id="cardInfoProgressContainer">
                <div id="cardInfoProgressBar" style="width: 0%;"></div>
                <div id="cardInfoProgressText">0 / 0</div>
            </div>
            <button id="cardInfoButton" class="modal-btn"></button>
        </div>
    </div>
    
    <!-- 
    ========================================================
    CHEST OPENING MODAL
    ========================================================
    -->
    <div id="chestOpenOverlay">
        <h2 class="text-4xl font-bold">Chest Unlocked!</h2>
        <div class="text-7xl my-4">üì¶</div>
        <div id="chestRewardList">
            <!-- Rewards injected by JS -->
        </div>
        <button id="chestCloseButton">Awesome!</button>
    </div>

    <!-- 
    ========================================================
    DEBUG PASSWORD MODAL (NEW)
    ========================================================
    -->
    <div id="debugPasswordOverlay">
        <h2 class="text-2xl font-bold">Enter Debug Password</h2>
        <input type="password" id="debugPasswordInput" placeholder="Password">
        <button id="debugPasswordSubmit">Enter</button>
        <button id="debugPasswordCancel" class="cancel-btn">Cancel</button>
    </div>

    <!-- 
    ========================================================
    SAVE KEY MODAL (NEW)
    ========================================================
    -->
    <div id="saveKeyOverlay">
        <h2 class="text-2xl font-bold">Your Save Key</h2>
        <p class="text-sm font-normal text-gray-300 mt-2">Copy this key and save it somewhere safe!</p>
        <textarea id="saveKeyOutput" readonly></textarea>
        <button id="generateKeyBtn">Generate New Key</button>
        <button id="copyKeyBtn">Copy to Clipboard</button>
        <button id="saveKeyCloseBtn" class="cancel-btn">Close</button>
    </div>

    <!-- 
    ========================================================
    LOAD KEY MODAL (NEW)
    ========================================================
    -->
    <div id="loadKeyOverlay">
        <h2 class="text-2xl font-bold">Load Save Key</h2>
        <p class="text-sm font-normal text-gray-300 mt-2">Paste your save key below to load your progress.</p>
        <textarea id="loadKeyInput" placeholder="Paste your save key here..."></textarea>
        <button id="loadKeySubmit">Load Progress</button>
        <button id="loadKeyCloseBtn" class="cancel-btn">Cancel</button>
    </div>


    <!-- 
    ========================================================
    MAIN SCRIPT
    ========================================================
    -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Your web app's Firebase configuration
        // This is still needed for the *option* of Google Sign-In, even if button is hidden
        const firebaseConfig = {
          apiKey: "AIzaSyCnaXKjDvPDXP2tF5ZmtB7naYjCuLGUsd4",
          authDomain: "emoji-royale-8fb68.firebaseapp.com",
          projectId: "emoji-royale-8fb68",
          storageBucket: "emoji-royale-8fb68.firebasestorage.app",
          messagingSenderId: "1021589049311",
          appId: "1:1021589049311:web:61ce6353950831e298be6a",
          measurementId: "G-FDQ9L0MQGM"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();
        // setLogLevel('debug'); // Uncomment for debugging Firestore
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Use __app_id
        let userDocRef; // Reference to the user's document in Firestore
        let userId; // The user's unique ID
        
        // --- Global State ---
        let currentScreen = 'login'; // Start on login screen
        let trophies = 0;
        let gold = 500;
        let trophyChests = [];
        let allCards = {};
        let cardCollection = {};
        let playerDeck = [];
        let gameDeck = [];
        let hand = [];
        let nextCard = null;
        let discardPile = [];
        let aiDeck = [];
        let aiHand = [];
        let aiNextCard = null;
        let aiDiscardPile = [];
        let towerLevel = 1;
        let towerCardCount = 0;
        // --- NEW: Level Cap at 15 ---
        const towerUpgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        const towerStats = {
            1: { kingHealth: 2000, princessHealth: 1000, damage: 50, hitSpeed: 1 },
            2: { kingHealth: 2200, princessHealth: 1100, damage: 55, hitSpeed: 1 },
            3: { kingHealth: 2420, princessHealth: 1210, damage: 60, hitSpeed: 1 },
            4: { kingHealth: 2662, princessHealth: 1331, damage: 66, hitSpeed: 1 },
            5: { kingHealth: 2928, princessHealth: 1464, damage: 72, hitSpeed: 1 },
            6: { kingHealth: 3220, princessHealth: 1610, damage: 79, hitSpeed: 1 },
            7: { kingHealth: 3542, princessHealth: 1771, damage: 87, hitSpeed: 1 },
            8: { kingHealth: 3896, princessHealth: 1948, damage: 96, hitSpeed: 1 },
            9: { kingHealth: 4285, princessHealth: 2142, damage: 105, hitSpeed: 1 },
            10: { kingHealth: 4713, princessHealth: 2356, damage: 116, hitSpeed: 1 },
            11: { kingHealth: 5184, princessHealth: 2591, damage: 128, hitSpeed: 1 },
            12: { kingHealth: 5702, princessHealth: 2850, damage: 141, hitSpeed: 1 },
            13: { kingHealth: 6272, princessHealth: 3135, damage: 155, hitSpeed: 1 },
            14: { kingHealth: 6899, princessHealth: 3448, damage: 170, hitSpeed: 1 },
            15: { kingHealth: 7589, princessHealth: 3793, damage: 187, hitSpeed: 1 },
        };

        let selectedSpawningUnit = null;
        let isSpawningSpell = false;
        let spellRadius = 0;
        let placementRadius = 0;
        let canPlace = false;
        const arenaFloors = { 0: "Arena 1: Emoji Valley", 250: "Arena 2: Laughing Village", 500: "Arena 3: Lava Town" };
        let currentArenaFloor = 0;
        let currentArenaTheme = 'arena-1'; // For canvas styling

        // --- NEW: Level Cap at 15 ---
        const upgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        let isDataSaved = true; // Flag to control saving (for *this* session, not related to keys)
        let isInitialAuthCheck = true; // Flag to stop auto-login
        let loadTimeout; // Timer for stuck loads
        let isLoading = false; // Flag to prevent double-loads
        
        let generateKeyCooldown; // Timer for save key generation

        // --- Start Game ---
        window.onload = () => {

            // --- Game Constants ---
            const WIDTH = 400; // Define constants first
            const HEIGHT = 500;
            const RIVER_Y = HEIGHT / 2;
            const BRIDGE_Y = RIVER_Y;
            const PLAYER_SPAWN_LIMIT_Y = RIVER_Y;
            const AI_SPAWN_LIMIT_Y = RIVER_Y;
            // NEW: Define new spawn line
            const AI_SPAWN_LINE_FAR = HEIGHT * 0.30; // 30% from the top
            
            const LANE_LEFT_X = WIDTH / 4;
            const LANE_RIGHT_X = (WIDTH / 4) * 3;
            const MAX_ELIXIR = 10;
            const BASE_ELIXIR_REGEN_RATE = 0.008;
            const REGULATION_TIME = 120 * 60;
            const OVERTIME_TIME = 120 * 60;
            
            // NEW: Drag sensitivity
            const DRAG_SENSITIVITY = 10; // Pixels to move before it's a "drag"

            // --- Game State ---
            let gameObjects = [];
            let playerElixir = 3;
            let aiElixir = 3;
            let gameRunning = false;
            let gameLoopId = 0;
            let lastTime = 0;
            let aiThinkTimer = 0;
            let gameTimer = REGULATION_TIME;
            let isOvertime = false;
            let currentElixirRate = BASE_ELIXIR_REGEN_RATE;
            let isTieBreaker = false;
            let tieBreakerTick = 0;
            // NEW: Track destroyed towers for spawn zones
            let playerLeftTowerDestroyed = false;
            let playerRightTowerDestroyed = false;
            let aiLeftTowerDestroyed = false;
            let aiRightTowerDestroyed = false;
            
            // NEW: Click/Drag state
            let isDraggingCard = false;
            let cardClickStartPos = null;

            // --- DOM Elements ---
            const screens = document.querySelectorAll('.screen');
            const navButtons = document.querySelectorAll('.nav-btn');
            const loginScreen = document.getElementById('loginScreen');
            // const googleLoginBtn = document.getElementById('googleLoginBtn'); // Removed
            const trueGuestLoginBtn = document.getElementById('trueGuestLoginBtn'); // FIXED
            const loginError = document.getElementById('loginError'); 
            const loadingScreen = document.getElementById('loadingScreen');
            const menuScreen = document.getElementById('menuScreen');
            const gameScreen = document.getElementById('gameScreen');
            const deckScreen = document.getElementById('deckScreen');
            const towerScreen = document.getElementById('towerScreen');
            const debugScreen = document.getElementById('debugScreen'); // NEW
            const battleButton = document.getElementById('battleButton');
            const trophyDisplay = document.getElementById('trophyDisplay');
            const goldDisplay = document.getElementById('goldDisplay');
            const chestSlots = document.getElementById('chestSlots');
            const arenaName = document.getElementById('arenaName');
            const arenaEmoji = document.getElementById('arenaEmoji');
            const deckCardGrid = document.getElementById('deckCardGrid');
            const collectionCardGrid = document.getElementById('collectionCardGrid');
            const lockedCardGrid = document.getElementById('lockedCardGrid'); 
            const deckCount = document.getElementById('deckCount');
            const cardHandEl = document.getElementById('cardHand');
            const nextCardSlotEl = document.getElementById('nextCardSlot');
            const placementIndicator = document.getElementById('placementIndicator');
            const placementOverlay = document.getElementById('placementOverlay'); // NEW
            const menuButton = document.getElementById('menuButton');
            const towerLevelDisplay = document.getElementById('towerLevelDisplay');
            const towerInfoStats = document.getElementById('towerInfoStats');
            const towerInfoProgressContainer = document.getElementById('towerInfoProgressContainer');
            const towerInfoProgressBar = document.getElementById('towerInfoProgressBar');
            const towerInfoProgressText = document.getElementById('towerInfoProgressText');
            const towerUpgradeButton = document.getElementById('towerUpgradeButton');
            const cardInfoModal = document.getElementById('cardInfoModal');
            const cardInfoCloseBtn = document.getElementById('cardInfoCloseBtn');
            const cardInfoDisplay = document.getElementById('cardInfoDisplay');
            const cardInfoName = document.getElementById('cardInfoName');
            const cardInfoType = document.getElementById('cardInfoType');
            const cardInfoLevel = document.getElementById('cardInfoLevel');
            const cardInfoStats = document.getElementById('cardInfoStats');
            const cardInfoButtons = document.getElementById('cardInfoButtons'); 
            const cardInfoProgressContainer = document.getElementById('cardInfoProgressContainer');
            const cardInfoProgressBar = document.getElementById('cardInfoProgressBar');
            const cardInfoProgressText = document.getElementById('cardInfoProgressText');
            const cardInfoButton = document.getElementById('cardInfoButton');
            const chestOpenOverlay = document.getElementById('chestOpenOverlay');
            const chestRewardList = document.getElementById('chestRewardList');
            const chestCloseButton = document.getElementById('chestCloseButton');
            // Debug Buttons
            const debugArena2 = document.getElementById('debugArena2');
            const debugArena3 = document.getElementById('debugArena3');
            const debugUnlockAll = document.getElementById('debugUnlockAll');
            const debugUpgradeAll = document.getElementById('debugUpgradeAll');
            const debugGetChest = document.getElementById('debugGetChest');
            const debugAddGold = document.getElementById('debugAddGold');
            const debugReset = document.getElementById('debugReset');
            // Debug Password
            const debugPasswordOverlay = document.getElementById('debugPasswordOverlay');
            const debugPasswordInput = document.getElementById('debugPasswordInput');
            const debugPasswordSubmit = document.getElementById('debugPasswordSubmit');
            const debugPasswordCancel = document.getElementById('debugPasswordCancel');
            // Save/Load Keys (NEW)
            const saveDataBtn = document.getElementById('saveDataBtn');
            const saveKeyOverlay = document.getElementById('saveKeyOverlay');
            const saveKeyOutput = document.getElementById('saveKeyOutput');
            const generateKeyBtn = document.getElementById('generateKeyBtn');
            const copyKeyBtn = document.getElementById('copyKeyBtn');
            const saveKeyCloseBtn = document.getElementById('saveKeyCloseBtn');
            const loadKeyBtn = document.getElementById('loadKeyBtn');
            const loadKeyOverlay = document.getElementById('loadKeyOverlay');
            const loadKeyInput = document.getElementById('loadKeyInput');
            const loadKeySubmit = document.getElementById('loadKeySubmit');
            const loadKeyCloseBtn = document.getElementById('loadKeyCloseBtn');


            // --- Game Elements (from gameScreen) ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const elixirBar = document.getElementById('elixirBar');
            const elixirText = document.getElementById('elixirText');
            const messageOverlay = document.getElementById('messageOverlay');
            const messageText = document.getElementById('messageText');
            const startButton = document.getElementById('startButton');
            const timerDisplay = document.getElementById('timerDisplay');


            // ==============================================
            // FIREBASE & USER DATA (NOW OPTIONAL)
            // ==============================================
            
            // This is the function that runs after a Google login attempt
            async function handleAuth(user) {
                // This 'if' block stops the auto-login on page load
                if (isInitialAuthCheck) {
                    isInitialAuthCheck = false;
                    return;
                }
                
                // If the login was real (not auto), and not a guest
                if (user && !user.isAnonymous) {
                    // Prevent this from running twice if it's already loading
                    if (isLoading) return;
                    isLoading = true;

                    userId = user.uid;
                    userDocRef = doc(db, 'artifacts', appId, 'users', userId);
                    isDataSaved = true; // This means "save to firebase"
                    
                    showScreen('loading');
                    loadingScreen.querySelector('p').textContent = 'Loading Progress...';
                    
                    // Clear any old timer
                    clearTimeout(loadTimeout);
                    
                    // --- NEW: The 8-second "failsafe" timer ---
                    loadTimeout = setTimeout(() => {
                        console.warn("Firebase load took too long! (8s)");
                        // If it's still loading, force it to stop and start a new game
                        if (isLoading) {
                            isLoading = false;
                            isDataSaved = false; // Disable saving to prevent overwrite
                            initNewUser(); // Load a blank game locally
                            showScreen('menu'); // Go to menu
                        }
                    }, 8000); // 8 seconds

                    try {
                        await loadUserData();
                    } catch (error) {
                        console.error("Error in loadUserData:", error);
                        initNewUser(); // If loading fails, start a new game
                    } finally {
                        // This code runs *only if* loading finishes *before* the 8-second timer
                        if (isLoading) {
                            clearTimeout(loadTimeout); // Cancel the failsafe timer
                            isLoading = false;
                            showScreen('menu'); // Go to menu normally
                        }
                    }

                } else {
                    // Not logged in or is anonymous
                    userId = null;
                    userDocRef = null;
                    isDataSaved = false; // Don't save to firebase
                    isLoading = false;
                    showScreen('login');
                }
            }
            
            async function loadUserData() {
                if (!userDocRef) return;
                try {
                    const docSnap = await getDoc(userDocRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        loadDataFromSave(data); // Use the new function to load
                    } else {
                        // This is a new account, so just init, don't save yet
                        initNewUser();
                    }
                } catch (error) {
                    console.error("Error loading user data:", error);
                    // If loading fails, just start a new game locally
                    isDataSaved = false; // Disable saving
                    initNewUser();
                }
            }
            
            function initNewUser() {
                trophies = 0;
                gold = 500;
                towerLevel = 1;
                towerCardCount = 0;
                trophyChests = [];
                cardCollection = initNewUserCards(false);
                playerDeck = initNewUserCards(true);
                // We don't save here, we let the game save after a win/loss
            }

            // NEW: "Guest (No Save)" logic
            function initGuestSession() {
                initNewUser(); // Load default data
                
                // Disable saving
                userDocRef = null; 
                userId = null;
                isDataSaved = false; // Prevent save attempts
            }

            function initNewUserCards(deckOnly = false) {
                let newCollection = {};
                
                // Add all cards to collection with count 0 (except Arena 1)
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; // FIX: Don't add 'tower' to collection
                    newCollection[cardId] = { level: 1, count: 0 };
                }
                
                // Add Arena 1 cards with count 1
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; // FIX: Don't add 'tower' to collection
                    if (allCards[cardId].arena === 1) {
                        newCollection[cardId] = { level: 1, count: 1 };
                    }
                }
                
                if (deckOnly) {
                    // FIX: Filter out 'tower' from starting deck
                    return Object.keys(allCards).filter(id => allCards[id].arena === 1 && id !== 'tower');
                }
                return newCollection;
            }

            async function saveUserData() {
                // This function now *only* saves to Firebase if logged in
                if (!userDocRef || !isDataSaved) return;
                
                // Prevent multiple save calls from stacking up
                isDataSaved = false; 
                
                try {
                    const dataToSave = generateSaveObject(); // Use new function
                    dataToSave.lastSaved = new Date().toISOString();
                    await setDoc(userDocRef, dataToSave, { merge: true });
                } catch (error) {
                    console.error("Error saving user data:", error);
                }
                
                // Allow saving again
                isDataSaved = true; 
            }
            
            /*
            // This event listener is removed as the button is
            googleLoginBtn.addEventListener('click', async () => {
                loginError.textContent = '';
                try {
                    // This will trigger the onAuthStateChanged listener
                    await signInWithPopup(auth, provider);
                } catch (error) {
                    isLoading = false; // Make sure loading stops on fail
                    if (error.code === 'auth/unauthorized-domain') {
                        loginError.textContent = 'Google Sign-in is not set up.';
                    } else if (error.code === 'auth/popup-blocked') {
                        loginError.textContent = 'Pop-up blocked! Please allow pop-ups.';
                    } else {
                        loginError.textContent = 'Could not sign in. Please try again.';
                    } 
                }
            });
            */
            
            // "Play as Guest (No Save)" button
            trueGuestLoginBtn.addEventListener('click', () => {
                loginError.textContent = ''; // Clear errors
                initGuestSession(); // Load default data, disable saving
                showScreen('loading');
                loadingScreen.querySelector('p').textContent = 'Starting Guest Game...';
                setTimeout(() => showScreen('menu'), 1000); // Short delay
            });

            // ==============================================
            // NEW: SAVE KEY LOGIC
            // ==============================================

            function generateSaveObject() {
                // Gathers all current game data into an object
                return {
                    trophies,
                    gold,
                    towerLevel,
                    towerCardCount,
                    trophyChests,
                    cardCollection,
                    playerDeck,
                    version: 1 // For future-proofing
                };
            }
            
            function loadDataFromSave(data) {
                // Loads game data from a provided object
                trophies = data.trophies || 0;
                gold = data.gold || 500;
                towerLevel = data.towerLevel || 1;
                towerCardCount = data.towerCardCount || 0;
                trophyChests = data.trophyChests || [];
                cardCollection = data.cardCollection || initNewUserCards(false); 
                playerDeck = data.playerDeck || initNewUserCards(true); 
                // Ensure no 'tower' card in deck (fix for old saves)
                if (playerDeck.includes('tower')) {
                    playerDeck = playerDeck.filter(id => id !== 'tower');
                }
                if (cardCollection['tower']) {
                    delete cardCollection['tower'];
                }
            }
            
            saveDataBtn.addEventListener('click', () => {
                saveKeyOverlay.style.display = 'flex';
                saveKeyOutput.value = 'Click "Generate New Key" to get your code.';
            });
            saveKeyCloseBtn.addEventListener('click', () => {
                saveKeyOverlay.style.display = 'none';
            });
            
            generateKeyBtn.addEventListener('click', () => {
                // Generate the save object
                const saveData = generateSaveObject();
                // Compress and encode
                const jsonString = JSON.stringify(saveData);
                const encodedString = btoa(jsonString); // Base64 encode
                
                saveKeyOutput.value = encodedString;
                
                // Start 30-second cooldown
                generateKeyBtn.disabled = true;
                let secondsLeft = 30;
                generateKeyBtn.textContent = `Wait... (${secondsLeft}s)`;
                
                clearTimeout(generateKeyCooldown);
                generateKeyCooldown = setInterval(() => {
                    secondsLeft--;
                    generateKeyBtn.textContent = `Wait... (${secondsLeft}s)`;
                    if (secondsLeft <= 0) {
                        clearInterval(generateKeyCooldown);
                        generateKeyBtn.disabled = false;
                        generateKeyBtn.textContent = 'Generate New Key';
                    }
                }, 1000);
            });
            
            copyKeyBtn.addEventListener('click', () => {
                if (saveKeyOutput.value && saveKeyOutput.value !== 'Click "Generate New Key" to get your code.') {
                    navigator.clipboard.writeText(saveKeyOutput.value).then(() => {
                        copyKeyBtn.textContent = 'Copied!';
                        setTimeout(() => copyKeyBtn.textContent = 'Copy to Clipboard', 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        copyKeyBtn.textContent = 'Failed to copy!';
                        setTimeout(() => copyKeyBtn.textContent = 'Copy to Clipboard', 2000);
                    });
                }
            });
            
            loadKeyBtn.addEventListener('click', () => {
                loadKeyOverlay.style.display = 'flex';
                loadKeyInput.value = '';
                loginError.textContent = '';
            });
            loadKeyCloseBtn.addEventListener('click', () => {
                loadKeyOverlay.style.display = 'none';
            });
            
            loadKeySubmit.addEventListener('click', () => {
                try {
                    const encodedString = loadKeyInput.value.trim();
                    if (!encodedString) {
                        loginError.textContent = 'Key cannot be empty.';
                        return;
                    }
                    const jsonString = atob(encodedString); // Base64 decode
                    const saveData = JSON.parse(jsonString);
                    
                    if (!saveData || saveData.version !== 1) {
                         throw new Error('Invalid or outdated key.');
                    }
                    
                    // Load the data
                    loadDataFromSave(saveData);
                    
                    // Disable Firebase saving for this session
                    isDataSaved = false;
                    userDocRef = null;
                    userId = null;
                    
                    // Go to loading screen, then menu
                    loadKeyOverlay.style.display = 'none';
                    showScreen('loading');
                    loadingScreen.querySelector('p').textContent = 'Loading Progress...';
                    setTimeout(() => showScreen('menu'), 1000);
                    
                } catch (error) {
                    console.error("Failed to load key:", error);
                    loginError.textContent = 'Invalid or corrupt save key!';
                    loadKeyOverlay.style.display = 'none';
                    showScreen('login');
                }
            });


            // ==============================================
            // SCREEN & NAVIGATION LOGIC
            // ==============================================
            function showScreen(screenId) {
                currentScreen = screenId;
                screens.forEach(s => { s.id === screenId + 'Screen' ? s.classList.add('active') : s.classList.remove('active'); });
                
                if (screenId === 'menu' || screenId === 'deck' || screenId === 'tower' || screenId === 'debug') {
                    navButtons.forEach(btn => { if (btn.dataset.screen === screenId) { btn.classList.add('text-yellow-400'); btn.classList.remove('text-gray-400'); } else { btn.classList.remove('text-yellow-400'); btn.classList.add('text-gray-400'); } });
                }
                
                if (screenId === 'deck') { renderDeckScreen(); }
                if (screenId === 'tower') { renderTowerScreen(); }
                if (screenId === 'menu') { updateArena(); trophyDisplay.textContent = `üèÜ ${trophies}`; goldDisplay.textContent = `üí∞ ${gold}`; renderChests(); updateBattleButtonState(); }
            }

            // NEW: Handle Debug password
            function showDebugPassword() {
                debugPasswordInput.value = '';
                debugPasswordOverlay.style.display = 'flex';
                debugPasswordInput.focus();
            }
            debugPasswordSubmit.addEventListener('click', () => {
                if (debugPasswordInput.value.toUpperCase() === 'GEOMETRIC') {
                    debugPasswordOverlay.style.display = 'none';
                    showScreen('debug');
                } else {
                    debugPasswordInput.value = '';
                    debugPasswordInput.placeholder = 'Wrong! Try again.';
                }
            });
            debugPasswordCancel.addEventListener('click', () => {
                debugPasswordOverlay.style.display = 'none';
            });


            function updateArena() {
                let currentTrophyFloor = 0;
                let arenaDisplayName = "Arena 1: Emoji Valley";
                let emoji = "üèûÔ∏è";
                currentArenaTheme = 'arena-1';
                
                for (const floor in arenaFloors) { if (trophies >= parseInt(floor)) { currentTrophyFloor = parseInt(floor); arenaDisplayName = arenaFloors[floor]; } }
                currentArenaFloor = currentTrophyFloor;
                
                if (arenaDisplayName.includes("Laughing Village")) {
                    emoji = "üèòÔ∏è";
                    currentArenaTheme = 'arena-2';
                } else if (arenaDisplayName.includes("Lava Town")) {
                    emoji = "üåã";
                    currentArenaTheme = 'arena-3';
                }
                arenaName.textContent = arenaDisplayName;
                arenaEmoji.textContent = emoji;
                canvas.className = currentArenaTheme;
            }

            function renderChests() {
                const slots = document.querySelectorAll('#chestSlots .chest-slot');
                slots.forEach((slot, index) => {
                    slot.innerHTML = '';
                    slot.onclick = null;
                    if (trophyChests[index]) {
                        slot.innerHTML = `üì¶`;
                        slot.classList.remove('text-gray-500', 'bg-gray-700');
                        slot.classList.add('bg-yellow-700', 'cursor-pointer');
                        slot.onclick = () => openChest(index);
                    } else {
                        slot.innerHTML = ``;
                        slot.classList.add('text-gray-500', 'bg-gray-700');
                        slot.classList.remove('bg-yellow-700', 'cursor-pointer');
                    }
                });
            }
            
            function openChest(index) {
                const chest = trophyChests[index];
                if (!chest) return;
                trophyChests.splice(index, 1);
                
                const rewardGold = 50 + Math.floor(Math.random() * 50);
                gold += rewardGold;
                let rewardsHTML = `<div><span class="text-3xl">üí∞</span> <span class="text-yellow-400">${rewardGold} Gold</span></div>`;
                
                const unlockedCards = getUnlockedCards(true); // Get list of cards this player *can* win
                const numCardStacks = 2 + Math.floor(Math.random() * 2);
                
                for(let i = 0; i < numCardStacks; i++) {
                    const cardId = unlockedCards[Math.floor(Math.random() * unlockedCards.length)];
                    const cardCount = 3 + Math.floor(Math.random() * 5);
                    
                    if (cardId === 'tower') {
                        towerCardCount += cardCount;
                        rewardsHTML += `<div><span class="text-3xl">üëë</span> ${cardCount}x Tower Cards</div>`;
                    } else {
                        // FIX: Ensure card exists in collection
                        if (!cardCollection[cardId]) {
                            cardCollection[cardId] = { level: 1, count: 0 };
                        }
                        cardCollection[cardId].count += cardCount;
                        rewardsHTML += `<div><span class="text-3xl">${allCards[cardId].emoji}</span> ${cardCount}x ${allCards[cardId].name}</div>`;
                    }
                }
                
                chestRewardList.innerHTML = rewardsHTML;
                chestOpenOverlay.style.display = 'flex';
                
                renderChests();
                updateArena();
                saveUserData(); // This will save to Firebase *if* logged in
            }
            chestCloseButton.addEventListener('click', () => {
                chestOpenOverlay.style.display = 'none';
            });

            navButtons.forEach(btn => { 
                btn.addEventListener('click', () => { 
                    if (btn.dataset.screen === 'debug') {
                        showDebugPassword();
                    } else {
                        showScreen(btn.dataset.screen); 
                    }
                }); 
            });
            battleButton.addEventListener('click', () => {
                if (battleButton.disabled) return;
                menuScreen.classList.remove('active');
                loadingScreen.classList.add('active');
                loadingScreen.querySelector('p').textContent = 'Finding Opponent...';
                setTimeout(() => {
                    showScreen('game');
                    messageText.textContent = 'Get Ready!';
                    startButton.style.display = 'none';
                    menuButton.style.display = 'none';
                    messageOverlay.style.display = 'flex';
                    setTimeout(() => {
                        initGame();
                        lastTime = performance.now();
                        gameLoopId = requestAnimationFrame(gameLoop);
                    }, 1500);
                }, 2000);
            });
            menuButton.addEventListener('click', () => { showScreen('menu'); gameRunning = false; cancelAnimationFrame(gameLoopId); });

            // ==============================================
            // DEBUG MENU LOGIC (NEW)
            // ==============================================
            debugArena2.addEventListener('click', () => {
                trophies = 250;
                updateArena();
                saveUserData();
                showScreen('menu');
            });
            debugArena3.addEventListener('click', () => {
                trophies = 500;
                updateArena();
                saveUserData();
                showScreen('menu');
            });
            debugUnlockAll.addEventListener('click', () => {
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue;
                    if (!cardCollection[cardId]) {
                        cardCollection[cardId] = { level: 1, count: 1 };
                    } else if (cardCollection[cardId].count === 0) {
                        cardCollection[cardId].count = 1;
                    }
                }
                saveUserData();
                // Use a custom modal later, for now, just log
                console.log('All cards unlocked!');
            });
            debugUpgradeAll.addEventListener('click', () => {
                for (const cardId in cardCollection) {
                    const cardData = cardCollection[cardId];
                    if (cardData.count > 0 && cardData.level < 15) { // Only upgrade unlocked cards, cap at 15
                        cardData.level++;
                    }
                }
                if (towerLevel < 15) towerLevel++;
                saveUserData();
                console.log('All owned cards and tower upgraded +1 level!');
            });
            debugGetChest.addEventListener('click', () => {
                if (trophyChests.length < 4) {
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                    saveUserData();
                    console.log('Got a chest!');
                } else {
                    console.log('Chest slots are full!');
                }
            });
            debugAddGold.addEventListener('click', () => {
                gold += 1000;
                goldDisplay.textContent = `üí∞ ${gold}`;
                saveUserData();
                console.log('+1000 Gold!');
            });
            debugReset.addEventListener('click', () => {
                // Use a custom modal later
                if (true) { // Replaced confirm()
                    initNewUser(); // This saves
                    saveUserData(); // Force save
                    showScreen('menu');
                    console.log('Account reset!');
                }
            });


            // ==============================================
            // CARD & DECK LOGIC
            // ==============================================

            function createCardDOM(cardId, isSmall = false, inHand = false) {
                const card = allCards[cardId];
                if (!card) return null;
                
                const cardData = cardCollection[cardId];
                // --- CARD LOCKING FIX ---
                const isLocked = (!cardData || cardData.count === 0) && card.arena > 1;
                
                const cardEl = document.createElement('div');
                cardEl.className = `card-ui ${isSmall ? 'card-ui-small' : ''}`;
                cardEl.dataset.unit = cardId;
                
                if (isLocked && !inHand) {
                    cardEl.classList.add('card-ui-locked');
                    cardEl.innerHTML = `
                        <div class="card-ui-cost">${card.cost}</div>
                        <span class="card-ui-name">${card.name}</span>
                        <span class="card-ui-emoji">${card.emoji}</span>
                        <span class="card-ui-type">${card.type}</span>
                        <div class="card-ui-locked-arena">Unlocks in Arena ${card.arena}</div>
                    `;
                    return cardEl;
                }

                const displayLevel = (cardData && cardData.level) ? cardData.level : 1;
                const displayCount = (cardData && cardData.count) ? cardData.count : 0;
                
                cardEl.dataset.cost = card.cost;
                cardEl.dataset.type = card.type;
                cardEl.dataset.emoji = card.emoji;
                cardEl.dataset.radius = card.placementRadius;
                if (card.radius) cardEl.dataset.spellRadius = card.radius;
                let progressBarHTML = '';
                let levelTextHTML = `<div class="card-ui-level">Lvl ${displayLevel}</div>`;
                if (!inHand) {
                    const costs = upgradeCosts[displayLevel];
                    let progress = 0;
                    let canUpgrade = false;
                    if (costs) {
                        progress = (displayCount / costs.cards) * 100;
                        if (displayCount >= costs.cards && gold >= costs.gold) { canUpgrade = true; }
                    } else { progress = 100; } // Max level
                    progressBarHTML = `<div class="card-ui-progress-bar"><div class="card-ui-progress ${canUpgrade ? 'can-upgrade' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>`;
                } else { levelTextHTML = ''; }
                cardEl.innerHTML = `<div class="card-ui-cost">${card.cost}</div><span class="card-ui-name">${card.name}</span><span class="card-ui-emoji">${card.emoji}</span><span class="card-ui-type">${card.type}</span>${levelTextHTML}${progressBarHTML}`;
                return cardEl;
            }

            function getUnlockedCards(includeTower = false, aiLevel = 0) {
                const unlocked = [];
                // Use AI level if provided, otherwise use player's trophies
                const arenaNum = aiLevel > 0 ? aiLevel : (currentArenaFloor === 0 ? 1 : (currentArenaFloor === 250 ? 2 : 3));
                
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; // FIX: Never include tower in this list
                    if (allCards[cardId].arena <= arenaNum) {
                        unlocked.push(cardId);
                    }
                }
                if (includeTower) {
                    unlocked.push('tower');
                }
                return unlocked;
            }

            function renderDeckScreen() {
                deckCardGrid.innerHTML = '';
                collectionCardGrid.innerHTML = '';
                lockedCardGrid.innerHTML = ''; 
                
                deckCount.textContent = `Deck (${playerDeck.length} / 8)`;
                
                // Render Deck
                playerDeck.forEach(cardId => { 
                    const cardEl = createCardDOM(cardId, true); 
                    cardEl.addEventListener('click', () => openCardModal(cardId)); 
                    deckCardGrid.appendChild(cardEl); 
                });
                
                // Render Collection & Locked Cards
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; // FIX: Don't show 'tower' in collection
                    
                    const cardData = cardCollection[cardId];
                    // --- CARD LOCKING FIX ---
                    const isLocked = (!cardData || cardData.count === 0) && allCards[cardId].arena > 1;
                    
                    const cardEl = createCardDOM(cardId, true);
                    cardEl.addEventListener('click', () => openCardModal(cardId));
                    
                    if (isLocked) {
                        lockedCardGrid.appendChild(cardEl);
                    } else {
                        collectionCardGrid.appendChild(cardEl);
                    }
                }
                
                updateBattleButtonState();
            }
            
            function renderTowerScreen() {
                towerLevelDisplay.textContent = `Tower Level ${towerLevel}`;
                const stats = towerStats[towerLevel] || towerStats[Object.keys(towerStats).length];
                const dps = (stats.damage / stats.hitSpeed).toFixed(1);
                
                towerInfoStats.innerHTML = `
                    <div>King Health: <span>${stats.kingHealth}</span></div>
                    <div>Princess Health: <span>${stats.princessHealth}</span></div>
                    <div>Damage: <span>${stats.damage}</span></div>
                    <div>Hit Speed: <span>${stats.hitSpeed}s</span></div>
                    <div class="col-span-2 text-center">DPS: <span>${dps}</span></div>
                `;
                
                const costs = towerUpgradeCosts[towerLevel];
                if (costs) {
                    towerInfoProgressContainer.style.display = 'block';
                    const progress = (towerCardCount / costs.cards);
                    towerInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                    towerInfoProgressText.textContent = `${towerCardCount} / ${costs.cards}`;
                    
                    const canUpgrade = towerCardCount >= costs.cards && gold >= costs.gold;
                    towerUpgradeButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                    towerUpgradeButton.disabled = !canUpgrade;
                } else {
                    towerInfoProgressContainer.style.display = 'none';
                    towerUpgradeButton.textContent = 'Max Level (15)';
                    towerUpgradeButton.disabled = true;
                }
            }
            towerUpgradeButton.addEventListener('click', () => {
                const costs = towerUpgradeCosts[towerLevel];
                if (costs && towerCardCount >= costs.cards && gold >= costs.gold) {
                    towerCardCount -= costs.cards;
                    gold -= costs.gold;
                    towerLevel++;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    renderTowerScreen();
                    saveUserData();
                }
            });


            function updateBattleButtonState() {
                if (playerDeck.length === 8) {
                    battleButton.disabled = false;
                    battleButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = 'BATTLE!';
                } else {
                    battleButton.disabled = true;
                    battleButton.classList.add('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = `Deck must have 8 cards (${playerDeck.length}/8)`;
                }
            }

            function initCardSystem() {
                allCards = {
                    // Arena 1
                    'knight': { name: 'Knight', cost: 3, emoji: '‚öîÔ∏è', type: 'Melee', unitClass: Knight, placementRadius: 12, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { health: 500, damage: 65, hitSpeed: 1.2 } } },
                    'archer': { name: 'Archer', cost: 4, emoji: 'üèπ', type: 'Ranged', unitClass: Archer, placementRadius: 10, isFlying: false, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { health: 250, damage: 40, hitSpeed: 1 } } },
                    'giant': { name: 'Giant', cost: 5, emoji: 'üí™', type: 'Tank', unitClass: Giant, placementRadius: 18, isFlying: false, arena: 1, targets: 'Buildings',
                                stats: { 1: { health: 1000, damage: 60, hitSpeed: 1.5, speed: 0.6 } } }, // NERFED
                    'goblins': { name: 'Goblins', cost: 2, emoji: 'üë∫', type: 'Swarm', unitClass: Goblins, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1 } } },
                    'skeletons': { name: 'Skeletons', cost: 1, emoji: 'üíÄ', type: 'Swarm', unitClass: Skeletons, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { count: 3, health: 10, damage: 2, hitSpeed: 1.2 } } }, // NERFED
                    'tinyBot': { name: 'Tiny Bot', cost: 4, emoji: 'ü§ñ', type: 'Melee', unitClass: TinyBot, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground',
                                stats: { 1: { health: 700, damage: 250, hitSpeed: 1.8 } } },
                    'fireball': { name: 'Fireball', cost: 4, emoji: 'üî•', type: 'Spell', radius: 50, placementRadius: 50, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 250 } } },
                    'arrows': { name: 'Arrows', cost: 3, emoji: 'üéØ', type: 'Spell', radius: 80, placementRadius: 80, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 140 } } },
                    // Arena 2
                    'hut': { name: 'Goblin House', cost: 5, emoji: 'üè†', type: 'Building', unitClass: GoblinHut, placementRadius: 20, isFlying: false, arena: 2, targets: '-',
                                stats: { 1: { health: 800, spawn_speed: '5s', lifetime: '30s' } } },
                    'skeletonArmy': { name: 'Skeleton Group', cost: 3, emoji: '‚ò†Ô∏è', type: 'Swarm', unitClass: SkeletonArmy, placementRadius: 10, isFlying: false, arena: 2, targets: 'Ground',
                                stats: { 1: { count: 15, health: 10, damage: 2, hitSpeed: 1.2 } } }, // NERFED
                    'goblinGang': { name: 'Goblin Group', cost: 3, emoji: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', type: 'Swarm', unitClass: GoblinGang, placementRadius: 10, isFlying: false, arena: 2, targets: 'Air & Ground',
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1, spear_count: 3, spear_health: 60, spear_damage: 25, spear_hitSpeed: 1.2 } } },
                    // Arena 3
                    'fireDragon': { name: 'Fire Dragon', cost: 4, emoji: 'üê≤', type: 'Air', unitClass: FireDragon, placementRadius: 12, isFlying: true, arena: 3, targets: 'Air & Ground',
                                stats: { 1: { health: 800, damage: 120, hitSpeed: 1.5, splashRadius: 25 } } },
                    'barbarians': { name: 'Barbarians', cost: 5, emoji: 'üßî', type: 'Swarm', unitClass: Barbarians, placementRadius: 10, isFlying: false, arena: 3, targets: 'Ground',
                                stats: { 1: { count: 5, health: 300, damage: 60, hitSpeed: 1.4 } } },
                    'battleRam': { name: 'Battle Ram', cost: 4, emoji: 'üå≤', type: 'WinCon', unitClass: BattleRam, placementRadius: 10, isFlying: false, arena: 3, targets: 'Buildings',
                                stats: { 1: { health: 700, damage: 200, chargeSpeed: 2.5, barbLevel: 1 } } },
                    'barbarianHut': { name: 'Barbarian House', cost: 7, emoji: 'üèòÔ∏è', type: 'Building', unitClass: BarbarianHut, placementRadius: 20, isFlying: false, arena: 3, targets: '-',
                                stats: { 1: { health: 1000, spawn_speed: '10s', lifetime: '40s', barbLevel: 1 } } },
                    'tower': { name: 'Tower Upgrade', emoji: 'üëë' }
                };
                
                // --- NEW: Auto-calculate stats for levels 2-15 ---
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue;
                    const card = allCards[cardId];
                    for (let level = 2; level <= 15; level++) { // Cap at 15
                        if (!card.stats[level]) {
                            const prevStats = card.stats[level - 1];
                            const newStats = { ...prevStats };
                            // Increase health and damage by ~10% per level
                            if (newStats.health) newStats.health = Math.round(newStats.health * 1.1);
                            if (newStats.damage) newStats.damage = Math.round(newStats.damage * 1.1);
                            // Handle sub-unit stats
                            if (newStats.spear_health) newStats.spear_health = Math.round(newStats.spear_health * 1.1);
                            if (newStats.spear_damage) newStats.spear_damage = Math.round(newStats.spear_damage * 1.1);
                            // Update levels for spawner cards
                            if (cardId === 'battleRam' || cardId === 'barbarianHut') newStats.barbLevel = level;
                            card.stats[level] = newStats;
                        }
                    }
                }
            }

            // --- ERROR FIX: Added checks for card and card.stats ---
            function openCardModal(cardId) {
                const card = allCards[cardId];
                const cardData = cardCollection[cardId];
                if (!card) return; // Exit if card invalid
                
                const isLocked = (!cardData || cardData.count === 0) && card.arena > 1;
                const displayLevel = (cardData && cardData.level) ? cardData.level : 1;
                
                // --- FIX: Check if card.stats exists ---
                const stats = card.stats ? card.stats[displayLevel] : null;

                cardInfoDisplay.innerHTML = '';
                cardInfoDisplay.appendChild(createCardDOM(cardId, false));
                cardInfoName.textContent = card.name;
                cardInfoType.textContent = card.type || 'Special'; // Fallback
                cardInfoLevel.textContent = isLocked ? "Not Unlocked" : `Level ${displayLevel}`;
                
                cardInfoStats.innerHTML = `<div>Targets: <span>${card.targets || '-'}</span></div>`;
                if (card.isFlying) cardInfoStats.innerHTML += `<div>Placement: <span>Air & Ground</span></div>`;
                
                // --- FIX: Only loop stats if stats is not null ---
                if (stats) {
                    for (const [key, value] of Object.entries(stats)) { 
                        if (key !== 'barbLevel') cardInfoStats.innerHTML += `<div>${key.charAt(0).toUpperCase() + key.slice(1).replace('_', ' ')}: <span>${value}</span></div>`; 
                    }
                    if (card.type === 'Spell') { cardInfoStats.innerHTML += `<div>Radius: <span>${card.radius}</span></div>`; }
                    if (stats.damage && stats.hitSpeed) { const dps = (stats.damage / stats.hitSpeed).toFixed(1); cardInfoStats.innerHTML += `<div>DPS: <span>${dps}</span></div>`; }
                }

                cardInfoButtons.innerHTML = '';
                cardInfoProgressContainer.style.display = 'none';
                cardInfoButton.style.display = 'none';

                // --- FIX: Also check for !stats ---
                if (isLocked || !stats) {
                    if(isLocked) cardInfoLevel.textContent = `Unlocks in Arena ${card.arena}`;
                } else {
                    // Is unlocked and has stats: Show buttons and progress
                    const isInDeck = playerDeck.includes(cardId);
                    let addRemoveBtn = document.createElement('button');
                    addRemoveBtn.id = 'addRemoveBtn';
                    if (isInDeck) {
                        addRemoveBtn.textContent = 'Remove from Deck';
                        addRemoveBtn.className = 'modal-btn remove';
                        addRemoveBtn.disabled = false;
                        addRemoveBtn.onclick = () => removeFromDeck(cardId);
                    } else {
                        addRemoveBtn.textContent = 'Add to Deck';
                        addRemoveBtn.className = 'modal-btn add';
                        addRemoveBtn.onclick = () => addToDeck(cardId);
                        addRemoveBtn.disabled = playerDeck.length >= 8;
                        if (playerDeck.length >= 8) addRemoveBtn.textContent = 'Deck is Full (8/8)';
                    }
                    cardInfoButtons.appendChild(addRemoveBtn);
                    cardInfoProgressContainer.style.display = 'block';
                    cardInfoButton.style.display = 'block';
                    
                    const displayCount = cardData.count || 0;
                    const costs = upgradeCosts[displayLevel];
                    
                    if (costs) {
                        const progress = (displayCount / costs.cards);
                        cardInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                        cardInfoProgressText.textContent = `${displayCount} / ${costs.cards}`;
                        const canUpgrade = displayCount >= costs.cards && gold >= costs.gold;
                        cardInfoProgressBar.classList.toggle('can-upgrade', canUpgrade);
                        cardInfoButton.className = 'modal-btn upgrade';
                        cardInfoButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                        cardInfoButton.disabled = !canUpgrade;
                        cardInfoButton.onclick = () => upgradeCard(cardId);
                    } else {
                        // Is max level
                        cardInfoProgressContainer.style.display = 'none';
                        cardInfoButton.className = 'modal-btn';
                        cardInfoButton.textContent = 'Max Level (15)';
                        cardInfoButton.disabled = true;
                    }
                }
                cardInfoModal.style.display = 'flex';
            }

            function closeModal() { cardInfoModal.style.display = 'none'; }
            
            async function addToDeck(cardId) {
                if (playerDeck.length < 8) {
                    playerDeck.push(cardId);
                    renderDeckScreen();
                    openCardModal(cardId);
                    await saveUserData();
                }
            }
            async function removeFromDeck(cardId) {
                const index = playerDeck.indexOf(cardId);
                if (index > -1) {
                    playerDeck.splice(index, 1);
                    renderDeckScreen();
                    openCardModal(cardId);
                    await saveUserData();
                }
            }
            async function upgradeCard(cardId) {
                const cardData = cardCollection[cardId];
                const costs = upgradeCosts[cardData.level];
                if (costs && cardData.count >= costs.cards && gold >= costs.gold) {
                    cardData.count -= costs.cards;
                    gold -= costs.gold;
                    cardData.level++;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    renderDeckScreen();
                    openCardModal(cardId);
                    await saveUserData();
                }
            }

            function shuffleDeck(deck) {
                let shuffled = [...deck]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;
            }

            function startGameDecks() {
                // Player
                gameDeck = shuffleDeck(playerDeck);
                hand = [];
                discardPile = [];
                for (let i = 0; i < 4; i++) { hand.push(gameDeck.pop()); }
                nextCard = gameDeck.pop();
                renderHand();
                
                // AI
                const aiArenaLevel = getAILevel(); // This is 1, 2, or 3
                const aiStatLevel = (aiArenaLevel === 1) ? 1 : (aiArenaLevel === 2) ? 3 : 5; // This is 1, 3, or 5
                
                // AI gets cards from its arena level, NO tower card
                const aiArenaCards = getUnlockedCards(false, aiArenaLevel);
                
                // Build a random 8-card deck
                aiDeck = [];
                let availableCards = [...aiArenaCards];
                for (let i = 0; i < 8; i++) {
                    if (availableCards.length === 0) availableCards = [...aiArenaCards]; // Refill if needed
                    let cardIndex = Math.floor(Math.random() * availableCards.length);
                    aiDeck.push(availableCards.splice(cardIndex, 1)[0]);
                }
                
                aiDeck = shuffleDeck(aiDeck);
                aiHand = [];
                aiDiscardPile = [];
                for (let i = 0; i < 4; i++) { if(aiDeck.length > 0) aiHand.push(aiDeck.pop()); }
                if(aiDeck.length > 0) aiNextCard = aiDeck.pop();
            }
            
            function aiPlayCard(cardId) {
                if (!allCards[cardId]) return; // Safety check
                aiElixir -= allCards[cardId].cost;
                aiDiscardPile.push(cardId);
                const handIndex = aiHand.indexOf(cardId);
                if (handIndex > -1) { aiHand.splice(handIndex, 1); }
                aiHand.push(aiNextCard);
                if (aiDeck.length === 0) { aiDeck = shuffleDeck(aiDiscardPile); aiDiscardPile = []; }
                aiNextCard = aiDeck.pop() || null;
            }

            function renderHand() {
                cardHandEl.innerHTML = '';
                hand.forEach((cardId, index) => {
                    const cardEl = createCardDOM(cardId, false, true);
                    cardEl.dataset.handIndex = index;
                    // Handle touch/mouse down for card selection
                    cardEl.addEventListener('mousedown', (e) => handleCardPress(e, cardEl, cardId));
                    cardEl.addEventListener('touchstart', (e) => handleCardPress(e, cardEl, cardId), { passive: false });
                    cardHandEl.appendChild(cardEl);
                });
                nextCardSlotEl.innerHTML = '';
                if (nextCard) {
                    nextCardSlotEl.appendChild(createCardDOM(nextCard, true, true));
                }
                updateCardUI();
            }

            function selectCard(cardEl, cardId) {
                if (!gameRunning) return;
                const card = allCards[cardId];
                if (card.cost > playerElixir) { console.log("Not enough elixir!"); return; }
                
                // Deselect if already selected
                if (selectedSpawningUnit && selectedSpawningUnit.id === cardId) {
                    cancelPlacement();
                    return;
                }

                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                placementOverlay.style.display = 'block'; // Show red overlay
                
                selectedSpawningUnit = {
                    id: cardId, cost: card.cost, type: card.type, radius: card.radius || 0, placementRadius: card.placementRadius,
                    emoji: card.emoji, isFlying: card.isFlying, handIndex: cardEl.dataset.handIndex
                };
                
                if (card.type === 'Spell') {
                    isSpawningSpell = true;
                    spellRadius = card.radius;
                    placementIndicator.className = 'spell';
                    placementIndicator.style.width = `${card.radius * 2}px`;
                    placementIndicator.style.height = `${card.radius * 2}px`;
                    placementIndicator.innerHTML = '';
                } else {
                    isSpawningSpell = false;
                    placementRadius = card.placementRadius;
                    placementIndicator.className = '';
                    placementIndicator.style.width = `${placementRadius * 2}px`;
                    placementIndicator.style.height = `${placementRadius * 2}px`;
                    placementIndicator.innerHTML = card.emoji;
                }
                cardEl.classList.add('selected');
                
                // NEW: Show the indicator immediately on select
                placementIndicator.style.display = 'block'; 
                
                // Update placement overlay based on destroyed towers
                updatePlacementOverlay();
            }
            
            function cancelPlacement() {
                isSpawningSpell = false;
                placementIndicator.style.display = 'none';
                placementOverlay.style.display = 'none'; // Hide red overlay
                selectedSpawningUnit = null;
                isDraggingCard = false;
                cardClickStartPos = null;
                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                updateCardUI();
            }

            function playCard(cardId, handIndex) {
                playerElixir -= allCards[cardId].cost;
                discardPile.push(cardId);
                hand.splice(handIndex, 1);
                hand.push(nextCard);
                if (gameDeck.length === 0) { gameDeck = shuffleDeck(discardPile); discardPile = []; }
                nextCard = gameDeck.pop();
                renderHand();
            }


            // ==============================================
            // GAME OBJECTS (CLASSES)
            // ==============================================
            class GameObject {
                constructor(x, y, radius, team, health) { this.x = x; this.y = y; this.radius = radius; this.team = team; this.health = health; this.maxHealth = health; this.id = Math.random(); }
                drawHealthBar(level) { 
                    const barWidth = this.radius * 2; 
                    const barHeight = 5; 
                    const barX = this.x - this.radius; 
                    const barY = this.y - this.radius - (this instanceof Tower ? 5 : 10); // Towers' bars are closer
                    
                    if (this.health < this.maxHealth) {
                        ctx.fillStyle = '#dc2626'; 
                        ctx.fillRect(barX, barY, barWidth, barHeight); 
                        ctx.fillStyle = '#16a34a'; 
                        ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight); 
                        ctx.strokeStyle = '#000'; 
                        ctx.strokeRect(barX, barY, barWidth, barHeight); 
                    }
                    
                    // Draw Level
                    if (level) {
                        ctx.font = 'bold 10px Inter';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = this.team === 'player' ? '#fff' : '#fde047'; // Player level white, AI yellow
                        
                        let textX = this.x;
                        let textY = barY - 2; // Above health bar
                        
                        if (this instanceof Tower) {
                             textY = this.y + this.radius + 12; // Below tower
                        }
                        
                        ctx.fillText(`Lvl ${level}`, textX, textY);
                    }
                }
                draw(color, emoji, level) { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                    ctx.fillStyle = color; 
                    ctx.fill(); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.stroke(); 
                    if (emoji) { 
                        ctx.font = `${this.radius * 1.5}px Arial`; 
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle'; 
                        ctx.fillText(emoji, this.x, this.y); 
                    } 
                    this.drawHealthBar(level); 
                }
                update() {}
            }

            class Tower extends GameObject {
                constructor(x, y, team, isKing = false, level = 1) {
                    const s = towerStats[level] || towerStats[1];
                    super(x, y, isKing ? 25 : 20, team, isKing ? s.kingHealth : s.princessHealth);
                    this.isKing = isKing;
                    this.level = level; // Store level
                    this.attackRange = 150;
                    this.attackDamage = s.damage;
                    this.attackCooldown = s.hitSpeed * 60;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.isActive = isKing ? false : true; // Princess towers are active by default
                    this.activationAnimation = 0;
                    this.dyingAnimationTimer = 0;
                }
                findTarget() { 
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) { return; } 
                    this.target = null; 
                    let closestDist = this.attackRange; 
                    for (const obj of gameObjects) { 
                        if (obj.team !== this.team && (obj instanceof Unit)) { 
                            const dist = getDistance(this, obj); 
                            if (dist < closestDist) { 
                                closestDist = dist; 
                                this.target = obj; 
                            } 
                        } 
                    } 
                }
                attack() { 
                    if (this.target) { 
                        gameObjects.push(new Projectile(this.x, this.y, this.target, this.team, this.attackDamage)); 
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                update() { 
                    if (this.health <= 0) return; 
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; } 
                    
                    let kingNeedsToActivate = false;
                    if (this.isKing) { 
                        const princessTowersDown = gameObjects.filter(t => t.team === this.team && !t.isKing && t.health > 0).length === 0; 
                        if (princessTowersDown || this.health < this.maxHealth) { 
                            if (!this.isActive) { 
                                this.isActive = true; 
                                this.activationAnimation = 30; 
                            } 
                            kingNeedsToActivate = true; 
                        } 
                        if (!kingNeedsToActivate) return; 
                    } 
                    
                    // Only active towers attack
                    if (this.isActive) {
                        this.findTarget(); 
                        if (this.target && this.cooldownTimer <= 0) { this.attack(); } 
                    }
                }
                draw() { 
                    ctx.save(); 
                    if (this.dyingAnimationTimer > 0) { 
                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 
                        const shakeX = (Math.random() - 0.5) * 4; 
                        const shakeY = (Math.random() - 0.5) * 4; 
                        ctx.translate(shakeX, shakeY); 
                    } 
                    const color = this.team === 'player' ? '#3b82f6' : '#ef4444'; 
                    const emoji = this.isKing ? 'üëë' : 'üë∏'; 
                    ctx.fillStyle = color; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.font = `${this.radius * 1.5}px Arial`; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    ctx.fillText(emoji, this.x, this.y); 
                    if (this.activationAnimation > 0) { 
                        this.activationAnimation--; 
                        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 * (this.activationAnimation / 30)})`; 
                        ctx.beginPath(); 
                        ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2); 
                        ctx.fill(); 
                    } 
                    this.drawHealthBar(this.level); // Pass level to health bar
                    ctx.restore(); 
                }
            }

            class Building extends GameObject {
                constructor(x, y, team, level = 1, cardId) {
                    const s = allCards[cardId].stats[level];
                    super(x, y, 20, team, s.health);
                    this.level = level; // Store level
                    this.maxLifetime = parseFloat(s.lifetime) * 60;
                    this.lifetime = this.maxLifetime;
                    this.dyingAnimationTimer = 0;
                    this.spawnTimer = 0;
                    this.spawnRate = parseFloat(s.spawn_speed) * 60;
                    this.spawnLevel = level;
                    this.cardId = cardId;
                    this.emoji = allCards[cardId].emoji;
                }
                update() { 
                    if (this.health <= 0) return; 
                    this.lifetime--; 
                    this.health = this.maxHealth * (this.lifetime / this.maxLifetime); 
                    if (this.lifetime <= 0) { this.health = 0; return; } 
                    this.spawnTimer--; 
                    if (this.spawnTimer <= 0) {
                        let unitToSpawn = null;
                        if (this.cardId === 'hut') unitToSpawn = Goblin;
                        if (this.cardId === 'barbarianHut') unitToSpawn = Barbarian;
                        
                        if (unitToSpawn) {
                            gameObjects.push(new unitToSpawn(this.x + (Math.random()*10-5), this.y + (Math.random()*10-5), this.team, this.spawnLevel));
                        }
                        this.spawnTimer = this.spawnRate; 
                    } 
                }
                draw() { 
                    ctx.save(); 
                    if (this.dyingAnimationTimer > 0) { 
                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 
                        const shakeX = (Math.random() - 0.5) * 4; 
                        const shakeY = (Math.random() - 0.5) * 4; 
                        ctx.translate(shakeX, shakeY); 
                    } 
                    const color = this.team === 'player' ? '#3b82f6' : '#ef4444'; 
                    ctx.fillStyle = color; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.font = `${this.radius * 1.5}px Arial`; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    ctx.fillText(this.emoji, this.x, this.y); 
                    this.drawHealthBar(this.level); // Pass level
                    ctx.restore(); 
                }
            }
            class GoblinHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'hut'); } }
            class BarbarianHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'barbarianHut'); } }


            class Unit extends GameObject {
                constructor(x, y, radius, team, health, speed, attackRange, attackDamage, attackCooldown, emoji, isFlying = false, targetsAir = false, level = 1) {
                    super(x, y, radius, team, health);
                    this.level = level; // Store level
                    this.speed = speed;
                    this.attackRange = attackRange; // Melee range
                    this.projectileRange = 0; // Ranged range
                    this.attackDamage = attackDamage;
                    this.attackCooldown = attackCooldown * 60;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.emoji = emoji;
                    this.isFlying = isFlying;
                    this.targetsAir = targetsAir;
                    this.aggroRange = 110; // NEW: Standard aggro range
                }
                
                findCloserThreat(targetDist) {
                    let closestThreat = null;
                    let closestThreatDist = targetDist; // Only check for *closer* threats
                    
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Unit)) {
                            if (!this.targetsAir && obj.isFlying) continue; // Can't target air
                            
                            const dist = getDistance(this, obj);
                            if (dist < this.aggroRange && dist < closestThreatDist) {
                                closestThreatDist = dist;
                                closestThreat = obj;
                            }
                        }
                    }
                    return closestThreat;
                }
                
                findTarget() {
                    // Lane-based targeting
                    let newTarget = null;
                    let closestDist = Infinity;
                    const targetLane = (this.x < WIDTH / 2) ? 'left' : 'right';

                    // 1. Find Princess Tower in its lane
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing && obj.health > 0) {
                            const objLane = (obj.x < WIDTH / 2) ? 'left' : 'right';
                            if (objLane === targetLane) {
                                const dist = getDistance(this, obj);
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    newTarget = obj;
                                }
                            }
                        }
                    }
                    if (newTarget) { this.target = newTarget; return; }

                    // 2. If no Princess Tower in lane, find King
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing && obj.health > 0) {
                            const dist = getDistance(this, obj);
                            if (dist < closestDist) {
                                closestDist = dist;
                                newTarget = obj;
                            }
                        }
                    }
                    if (newTarget) { this.target = newTarget; return; }
                    
                    // 3. If King is gone (?), find other Princess
                     for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing && obj.health > 0) {
                            const dist = getDistance(this, obj);
                            if (dist < closestDist) {
                                closestDist = dist;
                                newTarget = obj;
                            }
                        }
                    }
                    this.target = newTarget;
                }
                
                move() {
                    if (!this.target) return;
                    const dist = getDistance(this, this.target);
                    const targetRange = this.projectileRange > 0 ? this.projectileRange : this.attackRange;
                    if (dist <= targetRange) { return; }
                    
                    let targetX = this.target.x;
                    let targetY = this.target.y;
                    if (!this.isFlying) {
                        const needsToCross = (this.team === 'player' && this.y > RIVER_Y && this.target.y < RIVER_Y) || (this.team === 'ai' && this.y < RIVER_Y && this.target.y > RIVER_Y);
                        if (needsToCross) {
                            let bridgeX = (this.x < WIDTH / 2) ? LANE_LEFT_X : LANE_RIGHT_X;
                            if(this.target.x < WIDTH / 2) bridgeX = LANE_LEFT_X;
                            else bridgeX = LANE_RIGHT_X;
                            if ( (this.team === 'player' && this.y > (RIVER_Y + 10)) || (this.team === 'ai' && this.y < (RIVER_Y - 10)) ) {
                                targetX = bridgeX;
                                targetY = BRIDGE_Y;
                            }
                        }
                    }
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                }
                attack() { 
                    if (this.target && this.cooldownTimer <= 0) { 
                        if (this.projectileRange <= 0) { // Melee
                            this.target.health -= this.attackDamage; 
                        } else { // Ranged
                            let projectileType = Projectile;
                            let damage = this.attackDamage;
                            let splash = 0;
                            if (this.emoji === 'üê≤') {
                                projectileType = FireballProjectile;
                                splash = allCards['fireDragon'].stats[this.level].splashRadius;
                            }
                            gameObjects.push(new projectileType(this.x, this.y, this.target, this.team, damage, splash)); 
                        } 
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    
                    if (this.target && this.target.health > 0) {
                        const targetRange = this.projectileRange > 0 ? this.projectileRange : this.attackRange;
                        // NEW AGGRO LOGIC
                        const targetDist = getDistance(this, this.target);
                        if (targetDist <= targetRange) {
                            this.attack();
                            return; // Don't look for new targets or move
                        }
                        
                        // Check for closer threats
                        let closerThreat = this.findCloserThreat(targetDist);
                        if (closerThreat) {
                            this.target = closerThreat; // Switch target
                        }
                        
                        this.move();

                    } else {
                        this.findTarget(); // General findTarget
                        if(this.target) this.move();
                    }
                }
                draw() { const color = this.team === 'player' ? '#60a5fa' : '#f87171'; super.draw(color, this.emoji, this.level); }
            }

            class Knight extends Unit { constructor(x, y, team, level = 1) { const s = allCards['knight'].stats[level]; super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, '‚öîÔ∏è', false, false, level); } }
            class Archer extends Unit { constructor(x, y, team, level = 1) { const s = allCards['archer'].stats[level]; super(x, y, 10, team, s.health, 1.2, 0, s.damage, s.hitSpeed, 'üèπ', false, true, level); this.projectileRange = 120; } }
            class Giant extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['giant'].stats[level];
                    super(x, y, 18, team, s.health, s.speed, 30, s.damage, s.hitSpeed, 'üí™', false, false, level);
                    this.projectileRange = 0; // Melee
                    this.findTarget = () => {
                        // Lane-based targeting
                        let newTarget = null;
                        let closestDist = Infinity;
                        const targetLane = (this.x < WIDTH / 2) ? 'left' : 'right';

                        // 1. Find Princess Tower in its lane
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower || obj instanceof Building) && obj.health > 0) {
                                const objLane = (obj.x < WIDTH / 2) ? 'left' : 'right';
                                if (objLane === targetLane) {
                                    const dist = getDistance(this, obj);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        newTarget = obj;
                                    }
                                }
                            }
                        }
                        if (newTarget) { this.target = newTarget; return; }

                        // 2. If no Princess Tower in lane, find King
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower || obj instanceof Building) && obj.isKing && obj.health > 0) {
                                const dist = getDistance(this, obj);
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    newTarget = obj;
                                }
                            }
                        }
                        if (newTarget) { this.target = newTarget; return; }
                        
                        // 3. If King is gone (?), find other Princess
                         for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower || obj instanceof Building) && !obj.isKing && obj.health > 0) {
                                const dist = getDistance(this, obj);
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    newTarget = obj;
                                }
                            }
                        }
                        this.target = newTarget;
                    };
                }
                // GIANT AI FIX: Add an explicit update method to Giant
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }

                    // Check if current target is still valid
                    if (!this.target || this.target.health <= 0) {
                        this.findTarget(); // Find a new building target
                    }

                    // If we have a target, move or attack
                    if (this.target) {
                        const targetRange = this.projectileRange > 0 ? this.projectileRange : this.attackRange;
                        if (getDistance(this, this.target) <= targetRange) {
                            this.attack(); // Attack if in range
                        } else {
                            this.move(); // Move if not in range
                        }
                    }
                    // If no target (no buildings left), do nothing
                }
            }
            class Goblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; super(x, y, 8, team, s.health, 1.5, 20, s.damage, s.hitSpeed, 'üë∫', false, false, level); } }
            class Skeleton extends Unit { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; super(x, y, 7, team, s.health, 1.6, 20, s.damage, s.hitSpeed, 'üíÄ', false, false, level); } }
            class TinyBot extends Unit { constructor(x, y, team, level = 1) { const s = allCards['tinyBot'].stats[level]; super(x, y, 10, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'ü§ñ', false, false, level); } }
            class Goblins { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class Skeletons { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            
            // --- NEW CARD CLASSES ---
            class SpearGoblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; super(x, y, 8, team, s.spear_health, 1.5, 0, s.spear_damage, s.spear_hitSpeed, 'üéØ', false, true, level); this.projectileRange = 100; } }
            class GoblinGang { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } for (let i = 0; i < s.spear_count; i++) { gameObjects.push(new SpearGoblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } } }
            class SkeletonArmy { constructor(x, y, team, level = 1) { const s = allCards['skeletonArmy'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*30-15, y + Math.random()*30-15, team, level)); } } }
            class Barbarian extends Unit { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; super(x, y, 11, team, s.health, 1.1, 25, s.damage, s.hitSpeed, 'üßî', false, false, level); } }
            class Barbarians { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Barbarian(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class FireDragon extends Unit { constructor(x, y, team, level = 1) { const s = allCards['fireDragon'].stats[level]; super(x, y, 14, team, s.health, 1.2, 0, s.damage, s.hitSpeed, 'üê≤', true, true, level); this.projectileRange = 110; } }
            class BattleRam extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['battleRam'].stats[level];
                    super(x, y, 15, team, s.health, 1.2, 25, s.damage, 1, 'üå≤', false, false, level);
                    this.barbLevel = s.barbLevel;
                    this.chargeTimer = 3 * 60;
                    this.isCharging = false;
                    this.didHit = false; // Flag to prevent double spawns
                    this.projectileRange = 0; // Melee
                    this.findTarget = () => {
                        // Lane-based targeting
                        let newTarget = null;
                        let closestDist = Infinity;
                        const targetLane = (this.x < WIDTH / 2) ? 'left' : 'right';

                        // 1. Find Princess Tower in its lane
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower || obj instanceof Building) && obj.health > 0) {
                                const objLane = (obj.x < WIDTH / 2) ? 'left' : 'right';
                                if (objLane === targetLane) {
                                    const dist = getDistance(this, obj);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        newTarget = obj;
                                    }
                                }
                            }
                        }
                        if (newTarget) { this.target = newTarget; return; }

                        // 2. If no Princess Tower in lane, find King
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower || obj instanceof Building) && obj.isKing && obj.health > 0) {
                                const dist = getDistance(this, obj);
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    newTarget = obj;
                                }
                            }
                        }
                        if (newTarget) { this.target = newTarget; return; }
                        
                        // 3. If King is gone (?), find other Princess
                         for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower || obj instanceof Building) && !obj.isKing && obj.health > 0) {
                                const dist = getDistance(this, obj);
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    newTarget = obj;
                                }
                            }
                        }
                        this.target = newTarget;
                    };
                }
                
                spawnBarbs() {
                    if (this.didHit) return; // Don't spawn twice
                    this.didHit = true;
                    gameObjects.push(new Barbarian(this.x + 5, this.y, this.team, this.barbLevel));
                    gameObjects.push(new Barbarian(this.x - 5, this.y, this.team, this.barbLevel));
                    this.health = 0; // Ram is destroyed
                }

                // BATTLE RAM AI FIX: Replace super.update() with building-only logic
                update() {
                    if (this.health <= 0 && !this.didHit) {
                        this.spawnBarbs(); // Spawn if killed by damage
                        return;
                    }
                    if (this.didHit) return; // Already spawned, do nothing
                    
                    if (this.chargeTimer > 0) { this.chargeTimer--; if(this.chargeTimer === 0) this.isCharging = true; }
                    if (this.isCharging) this.speed = 2.4; else this.speed = 1.2;
                    
                    // --- REPLACEMENT for super.update() ---
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }

                    // Check if current target is still valid
                    if (!this.target || this.target.health <= 0) {
                        this.findTarget(); // Find a new building target
                    }

                    // If we have a target, move or attack
                    if (this.target) {
                        const targetRange = this.projectileRange > 0 ? this.projectileRange : this.attackRange;
                        if (getDistance(this, this.target) <= targetRange) {
                            this.attack(); // Attack if in range (will spawn barbs)
                        } else {
                            this.move(); // Move if not in range
                        }
                    }
                    // --- END REPLACEMENT ---
                }
                attack() { // Ram only attacks when it hits
                    if (this.target && this.cooldownTimer <= 0) { 
                        this.target.health -= this.attackDamage;
                        this.spawnBarbs(); // Spawn on hit
                    } 
                }
            }

            class Projectile extends GameObject {
                constructor(x, y, target, team, damage, splashRadius = 0) { 
                    super(x, y, 4, team, 1); 
                    this.target = target; 
                    this.damage = damage; 
                    this.speed = 5; 
                    this.splashRadius = splashRadius;
                }
                update() { 
                    if (!this.target || this.target.health <= 0) { this.health = 0; return; } 
                    const dist = getDistance(this, this.target); 
                    if (dist < this.speed) { 
                        // Hit target
                        this.target.health -= this.damage; 
                        
                        // Handle splash
                        if (this.splashRadius > 0) {
                            for (const obj of gameObjects) {
                                if (obj.team !== this.team && obj !== this.target && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                    if (getDistance(this.target, obj) < this.splashRadius) {
                                        obj.health -= this.damage; // Splash does full damage
                                    }
                                }
                            }
                        }
                        
                        this.health = 0; 
                        return; 
                    } 
                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); 
                    this.x += Math.cos(angle) * this.speed; 
                    this.y += Math.sin(angle) * this.speed; 
                }
                draw() { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                    ctx.fillStyle = this.team === 'player' ? '#a5f3fc' : '#fecaca'; 
                    ctx.fill(); 
                }
            }
            
            class FireballProjectile extends Projectile {
                draw() { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2); 
                    ctx.fillStyle = this.team === 'player' ? '#ffc107' : '#ff6f00'; 
                    ctx.fill(); 
                }
            }

            class Spell extends GameObject {
                constructor(x, y, team, damage, radius, emoji) {
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.animationTimer = 30;
                    this.maxAnimationTimer = 30;
                    this.hit = false;
                    this.emoji = emoji;
                }
                update() {
                    if (!this.hit) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    obj.health -= this.damage;
                                }
                            }
                        }
                        this.hit = true;
                    }
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / this.maxAnimationTimer;
                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;
                    if (this.emoji === 'üéØ') {
                        ctx.fillStyle = `rgba(139, 69, 19, ${alpha * 0.2})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `20px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = `rgba(101, 67, 33, ${alpha})`;
                        let yOffset = -this.radius + (this.radius * 2 * (1 - progress));
                        ctx.globalAlpha = alpha;
                        ctx.fillText('‚¨áÔ∏è', this.x - 20, this.y - 20 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x + 20, this.y - 10 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x, this.y + 20 + yOffset);
                        ctx.globalAlpha = 1;
                    } else if (this.emoji === 'üî•') {
                        ctx.fillStyle = `rgba(253, 224, 71, ${alpha * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `${this.radius * 2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.globalAlpha = alpha;
                        ctx.fillText(this.emoji, this.x, this.y);
                        ctx.globalAlpha = 1;
                    }
                }
            }


            // ==============================================
            // GAME LOGIC
            // ==============================================
            
            function getDistance(obj1, obj2) {
                const dx = obj1.x - obj2.x; const dy = obj1.y - obj2.y; return Math.sqrt(dx * dx + dy * dy);
            }

            function drawArena() {
                // River
                if (currentArenaTheme === 'arena-3') {
                    ctx.fillStyle = '#f45d22'; // Lava
                } else if (currentArenaTheme === 'arena-2') {
                    ctx.fillStyle = '#4a90e2'; // Lighter blue
                } else {
                    ctx.fillStyle = '#3b82f6'; // Default blue
                }
                ctx.fillRect(0, RIVER_Y - 10, WIDTH, 20);
                
                // Bridges
                ctx.fillStyle = '#a16207'; // Brown
                ctx.fillRect(LANE_LEFT_X - 25, RIVER_Y - 15, 50, 30);
                ctx.fillRect(LANE_RIGHT_X - 25, RIVER_Y - 15, 50, 30);
            }

            function getAILevel() {
                if (trophies > 500) return 3; if (trophies > 250) return 2; return 1;
            }

            function initGame() {
                gameObjects = [];
                playerElixir = 3;
                aiElixir = 3;
                selectedSpawningUnit = null;
                isSpawningSpell = false;
                gameRunning = true;
                aiThinkTimer = 0;
                gameTimer = REGULATION_TIME;
                isOvertime = false;
                isTieBreaker = false;
                tieBreakerTick = 0;
                
                // Reset spawn zones
                playerLeftTowerDestroyed = false;
                playerRightTowerDestroyed = false;
                aiLeftTowerDestroyed = false;
                aiRightTowerDestroyed = false;
                updatePlacementOverlay();
                
                messageOverlay.style.display = 'none';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';

                const aiArenaLevel = getAILevel();
                const aiStatLevel = (aiArenaLevel === 1) ? 1 : (aiArenaLevel === 2) ? 3 : 5;
                
                gameObjects.push(new Tower(LANE_LEFT_X, HEIGHT - 100, 'player', false, towerLevel));
                gameObjects.push(new Tower(LANE_RIGHT_X, HEIGHT - 100, 'player', false, towerLevel));
                gameObjects.push(new Tower(WIDTH / 2, HEIGHT - 50, 'player', true, towerLevel));
                gameObjects.push(new Tower(LANE_LEFT_X, 100, 'ai', false, aiStatLevel));
                gameObjects.push(new Tower(LANE_RIGHT_X, 100, 'ai', false, aiStatLevel));
                gameObjects.push(new Tower(WIDTH / 2, 50, 'ai', true, aiStatLevel));

                startGameDecks();
                updateCardUI();
            }

            function runAI() {
                const aiArenaLevel = getAILevel();
                const aiStatLevel = (aiArenaLevel === 1) ? 1 : (aiArenaLevel === 2) ? 3 : 5;
                
                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit && o.y < RIVER_Y + 50);
                if (playerUnits.length > 0) {
                    let bestCardId = null;
                    if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy) && aiHand.includes('arrows') && aiElixir >= allCards['arrows'].cost) {
                        bestCardId = 'arrows';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) {
                        bestCardId = 'tinyBot';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('barbarians') && aiElixir >= allCards['barbarians'].cost) {
                        bestCardId = 'barbarians';
                    } else if (playerUnits.some(u => u instanceof FireDragon) && aiHand.includes('archer') && aiElixir >= allCards['archer'].cost) {
                        bestCardId = 'archer';
                    } else if (aiHand.includes('goblins') && aiElixir >= allCards['goblins'].cost) {
                        bestCardId = 'goblins';
                    }
                    if (bestCardId) { spawnAIUnit(bestCardId, aiStatLevel, true); return; }
                }
                
                // Fallback: If elixir is high, play a card
                if (aiElixir > 7) {
                    let bestCardId = null;
                    if(aiHand.includes('giant') && aiElixir >= allCards['giant'].cost) { bestCardId = 'giant'; }
                    else if(aiHand.includes('barbarianHut') && aiElixir >= allCards['barbarianHut'].cost) { bestCardId = 'barbarianHut'; }
                    else if (aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) { bestCardId = 'tinyBot'; }
                    else {
                        // Play any random affordable unit
                        let affordableCards = aiHand.filter(id => allCards[id] && allCards[id].cost <= aiElixir && allCards[id].type !== 'Spell');
                        if (affordableCards.length > 0) {
                            bestCardId = affordableCards[Math.floor(Math.random() * affordableCards.length)];
                        }
                    }
                    if (bestCardId) { spawnAIUnit(bestCardId, aiStatLevel, false); return; }
                }

                if (aiElixir === MAX_ELIXIR && aiHand.includes('fireball') && Math.random() < 0.2) {
                    spawnAIUnit('fireball', aiStatLevel, false);
                    return;
                }
            }

            function spawnAIUnit(cardId, level, isDefensive = false) {
                const card = allCards[cardId];
                if (!card || card.cost > aiElixir) return;
                
                // Get AI's level for this card (currently just 'level')
                const cardLevel = level;
                
                if (card.type === 'Spell') {
                    let target = null;
                    const damage = card.stats[cardLevel].damage;
                    if (cardId === 'fireball') {
                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0 && o.health < 600);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Barbarian);
                    } else if (cardId === 'arrows') {
                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Skeleton || o instanceof SkeletonArmy || o instanceof GoblinGang));
                    }
                    if (target) {
                        gameObjects.push(new Spell(target.x, target.y, 'ai', damage, card.radius, card.emoji));
                        aiPlayCard(cardId);
                    }
                    return;
                }
                
                // Determine spawn Y
                let spawnY;
                if (isDefensive) {
                    // Spawn behind princess towers
                    spawnY = 150 + Math.random() * 50;
                } else {
                    // Spawn at the back
                    spawnY = 50 + Math.random() * 50;
                }
                
                // Determine spawn X (which lane)
                const spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;
                
                // Check if spawn is valid (not on top of another building)
                let canSpawn = true;
                if (card.type === 'Building') {
                    for (const obj of gameObjects) {
                        if (obj instanceof Tower || obj instanceof Building) {
                            const dist = getDistance({x: spawnX, y: spawnY}, obj);
                            if (dist < card.placementRadius + obj.radius) { 
                                canSpawn = false; 
                                break; 
                            }
                        }
                    }
                }
                
                if (canSpawn && card.unitClass) {
                    const newUnit = new card.unitClass(spawnX, spawnY, 'ai', cardLevel);
                    if (!card.type.includes('Swarm') && !card.type.includes('Building')) {
                        gameObjects.push(newUnit);
                    }
                    aiPlayCard(cardId);
                }
            }

            function updateCardUI() {
                const elixirInt = Math.floor(playerElixir);
                elixirBar.style.width = `${(playerElixir / MAX_ELIXIR) * 100}%`;
                elixirText.textContent = elixirInt;
                document.querySelectorAll('#cardHand .card-ui').forEach(cardEl => {
                    const cost = parseInt(cardEl.dataset.cost);
                    if (cost > elixirInt) { cardEl.classList.add('disabled'); }
                    else { cardEl.classList.remove('disabled'); }
                });
            }

            function updateTimerAndElixir() {
                const totalSeconds = Math.max(0, Math.floor(gameTimer / 60));
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                if (isOvertime) {
                    timerDisplay.classList.add('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 3 : BASE_ELIXIR_REGEN_RATE * 2;
                } else {
                    timerDisplay.classList.remove('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 2 : BASE_ELIXIR_REGEN_RATE;
                }
                if (playerElixir < MAX_ELIXIR) {
                    playerElixir += currentElixirRate;
                    playerElixir = Math.min(playerElixir, MAX_ELIXIR);
                }
                if (aiElixir < MAX_ELIXIR) {
                    aiElixir += currentElixirRate;
                    aiElixir = Math.min(aiElixir, MAX_ELIXIR);
                }
            }
            
            // NEW: Update function to check tower status
            function checkTowerStatus() {
                const aiLeft = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x < WIDTH / 2);
                const aiRight = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x > WIDTH / 2);
                
                if (aiLeft && aiLeft.health <= 0 && !aiLeftTowerDestroyed) {
                    aiLeftTowerDestroyed = true;
                    if(selectedSpawningUnit) updatePlacementOverlay();
                }
                if (aiRight && aiRight.health <= 0 && !aiRightTowerDestroyed) {
                    aiRightTowerDestroyed = true;
                    if(selectedSpawningUnit) updatePlacementOverlay();
                }
                
                // Can check player towers here too if AI gets spawn zones
            }
            
            // NEW: Update the clip-path of the red overlay
            function updatePlacementOverlay() {
                // Use path() for complex shapes
                // M = move to, L = line to, Z = close path
                let pathString = '';
                
                // If both are destroyed, no overlay
                if (aiLeftTowerDestroyed && aiRightTowerDestroyed) {
                    // Block only the far end
                    pathString = `M0 0 L${WIDTH} 0 L${WIDTH} ${AI_SPAWN_LINE_FAR} L0 ${AI_SPAWN_LINE_FAR} Z`;
                }
                // If neither is destroyed, block top half
                else if (!aiLeftTowerDestroyed && !aiRightTowerDestroyed) {
                    pathString = `M0 0 L${WIDTH} 0 L${WIDTH} ${RIVER_Y} L0 ${RIVER_Y} Z`;
                }
                // If only left is destroyed, block right half AND far-left
                else if (aiLeftTowerDestroyed && !aiRightTowerDestroyed) {
                    pathString = `M${WIDTH/2} 0 L${WIDTH} 0 L${WIDTH} ${RIVER_Y} L${WIDTH/2} ${RIVER_Y} Z ` + // Right half
                                 `M0 0 L${WIDTH/2} 0 L${WIDTH/2} ${AI_SPAWN_LINE_FAR} L0 ${AI_SPAWN_LINE_FAR} Z`; // Far left
                }
                // If only right is destroyed, block left half AND far-right
                else if (!aiLeftTowerDestroyed && aiRightTowerDestroyed) {
                     pathString = `M0 0 L${WIDTH/2} 0 L${WIDTH/2} ${RIVER_Y} L0 ${RIVER_Y} Z ` + // Left half
                                  `M${WIDTH/2} 0 L${WIDTH} 0 L${WIDTH} ${AI_SPAWN_LINE_FAR} L${WIDTH/2} ${AI_SPAWN_LINE_FAR} Z`; // Far right
                }

                placementOverlay.style.clipPath = `path('${pathString}')`;
            }


            function checkGameOver() {
                const playerKing = gameObjects.find(t => t.team === 'player' && t.isKing);
                const aiKing = gameObjects.find(t => t.team === 'ai' && t.isKing);
                if (gameRunning && aiKing && aiKing.health <= 0) { showWinScreen(); }
                else if (gameRunning && playerKing && playerKing.health <= 0) { showLoseScreen(); }
            }

            function checkOvertime() {
                if (!gameRunning) return;
                const getTowerCount = (team) => { return gameObjects.filter(obj => obj.team === team && (obj instanceof Tower) && obj.health > 0).length; };
                const playerTowers = getTowerCount('player');
                const aiTowers = getTowerCount('ai');
                if (playerTowers === aiTowers) {
                    isOvertime = true;
                    gameTimer = OVERTIME_TIME;
                    currentElixirRate = BASE_ELIXIR_REGEN_RATE * 2;
                } else if (playerTowers > aiTowers) {
                    showWinScreen();
                } else {
                    showLoseScreen();
                }
            }

            function startTieBreaker() {
                if (!gameRunning) return;
                gameRunning = true; isTieBreaker = true; gameObjects = gameObjects.filter(obj => (obj instanceof Tower));
                messageText.textContent = 'TIEBREAKER!';
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                setTimeout(() => { if (isTieBreaker) messageOverlay.style.display = 'none'; }, 2000);
            }

            function tieBreakerLoop() {
                tieBreakerTick--;
                if (tieBreakerTick <= 0) {
                    tieBreakerTick = 10;
                    let playerKing = null;
                    let aiKing = null;
                    for (const obj of gameObjects) {
                        if (obj instanceof Tower) { obj.health -= 20; }
                        if (obj.isKing && obj.team === 'player') playerKing = obj;
                        if (obj.isKing && obj.team === 'ai') aiKing = obj;
                    }
                    if (aiKing && aiKing.health <= 0 && playerKing && playerKing.health > 0) {
                        isTieBreaker = false;
                        showWinScreen();
                    } else if (playerKing && playerKing.health <= 0) {
                        isTieBreaker = false;
                        showLoseScreen();
                    }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT); drawArena(); gameObjects.forEach(obj => obj.draw());
                if (isTieBreaker) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            async function showWinScreen() {
                if (!gameRunning) return;
                gameRunning = false;
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                trophies += 30;
                updateArena();
                trophyDisplay.textContent = `üèÜ ${trophies}`;
                gold += 50;
                goldDisplay.textContent = `üí∞ ${gold}`;
                if (trophyChests.length < 4) {
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                }
                messageText.textContent = 'You Win! (+30 üèÜ, +50 üí∞, üì¶)';
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                await saveUserData();
            }

            async function showLoseScreen(message = 'You Lose!') {
                if (!gameRunning) return;
                gameRunning = false;
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                const trophiesToLose = Math.min(30, trophies - currentArenaFloor);
                trophies -= trophiesToLose;
                trophyDisplay.textContent = `üèÜ ${trophies}`;
                messageText.textContent = `${message} (-${trophiesToLose} üèÜ)`;
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                await saveUserData();
            }

            function gameLoop(timestamp) {
                if (isTieBreaker) {
                    tieBreakerLoop();
                    return;
                }
                if (!gameRunning) {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;
                gameTimer--;
                updateTimerAndElixir();
                aiThinkTimer--;
                if (aiThinkTimer <= 0) {
                    runAI();
                    aiThinkTimer = 30 + Math.random() * 30; // Think every 0.5-1s
                }
                
                // Update objects
                gameObjects.forEach(obj => obj.update());
                
                // Check tower status for spawn zones
                checkTowerStatus();
                
                // Filter dead objects
                gameObjects = gameObjects.filter(obj => {
                    if (obj.health > 0) return true;
                    // Handle units/projectiles/spells
                    if (obj instanceof Unit || obj instanceof Projectile || obj instanceof Spell) { 
                        // Special case: Battle Ram needs to spawn barbs
                        if (obj instanceof BattleRam && !obj.didHit) {
                            obj.spawnBarbs();
                        }
                        return false; 
                    }
                    // Handle towers/buildings
                    if (obj instanceof Tower || obj instanceof Building) {
                        if (obj.isKing) { checkGameOver(); return true; }
                        if (obj.dyingAnimationTimer === 0) { obj.dyingAnimationTimer = 30; }
                        obj.dyingAnimationTimer--;
                        return obj.dyingAnimationTimer > 0;
                    }
                    return false;
                });
                
                updateCardUI();
                if (gameTimer <= 0) {
                    if (isOvertime) { startTieBreaker(); }
                    else { checkOvertime(); }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                drawArena();
                gameObjects.forEach(obj => obj.draw());
                if (gameRunning) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            // --- Event Listeners ---
            
            function getCanvasClickPos(e) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) { 
                    clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; 
                } else if (e.changedTouches && e.changedTouches.length > 0) { 
                    clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; 
                } else { 
                    clientX = e.clientX; clientY = e.clientY; 
                }
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                return { x, y };
            }

            function checkPlacement(x, y, radius, cardType) {
                // Check if in allowed zone
                let inAllowedZone = false;
                if (y > RIVER_Y) {
                    inAllowedZone = true; // Always allowed in player's base
                } else if (y > AI_SPAWN_LINE_FAR) {
                    // Check enemy territory
                    if (aiLeftTowerDestroyed && x < WIDTH / 2) inAllowedZone = true;
                    if (aiRightTowerDestroyed && x > WIDTH / 2) inAllowedZone = true;
                }
                if (!inAllowedZone) return false;

                // Check for collision
                for (const obj of gameObjects) {
                    // NEW: Allow placing on troops, not buildings
                    if (obj instanceof Tower || obj instanceof Building) {
                        const dist = getDistance({x: x, y: y}, obj);
                        if (dist < radius + obj.radius) { return false; }
                    }
                }
                
                return true;
            }

            function handleCardPress(e, cardEl, cardId) {
                e.preventDefault(); // Prevent scrolling/other actions
                
                // If we are already dragging, do nothing
                if (isDraggingCard || !gameRunning) return;
                
                // Check if we're trying to place a card (click-to-place)
                if (selectedSpawningUnit) {
                    // This click is ON THE HAND, so it's a "cancel" or "switch"
                    if (selectedSpawningUnit.id === cardId) {
                        // Clicked the same card: cancel
                        cancelPlacement();
                        return;
                    } else {
                        // Clicked a different card: select new one
                        cancelPlacement();
                        selectCard(cardEl, cardId);
                        cardClickStartPos = { x: e.clientX, y: e.clientY }; // Start new drag check
                        return;
                    }
                }
                
                // This is a new card press
                const card = allCards[cardId];
                if (card.cost > playerElixir) {
                    console.log("Not enough elixir!");
                    return;
                }
                
                selectCard(cardEl, cardId);
                cardClickStartPos = { x: e.clientX, y: e.clientY };
                
                // Show indicator at click position
                let initialPos = (e.touches && e.touches[0]) ? e.touches[0] : e;
                movePlacementIndicator(initialPos);
            }
            
            function handleDragMove(e) {
                // If no card is selected, do nothing.
                if (!selectedSpawningUnit) return;
                
                e.preventDefault();
                let pos = (e.touches && e.touches[0]) ? e.touches[0] : e;

                // Check if this is a drag
                if (cardClickStartPos && !isDraggingCard) {
                    const dx = pos.clientX - cardClickStartPos.x;
                    const dy = pos.clientY - cardClickStartPos.y;
                    if (Math.sqrt(dx*dx + dy*dy) > DRAG_SENSITIVITY) {
                        isDraggingCard = true;
                    }
                }

                // Now, just check if we should be showing the indicator
                const rect = canvas.getBoundingClientRect();
                const isOverCanvas = (pos.clientX >= rect.left && pos.clientX <= rect.right &&
                                      pos.clientY >= rect.top && pos.clientY <= rect.bottom);
                                      
                if (isOverCanvas) {
                    // We are over the canvas, show and move the indicator
                    placementIndicator.style.display = 'block';
                    movePlacementIndicator(pos);
                } else {
                    // We are off-canvas.
                    // If dragging, hide it. If click-to-place, also hide it.
                    placementIndicator.style.display = 'none';
                }
            }

            function movePlacementIndicator(e) {
                if (!selectedSpawningUnit) return;
                
                const { x, y } = getCanvasClickPos(e);
                const clampedX = Math.max(0, Math.min(WIDTH, x));
                const clampedY = Math.max(0, Math.min(HEIGHT, y));
                let radius = isSpawningSpell ? spellRadius : placementRadius;
                
                // FIX: Use top/left
                placementIndicator.style.left = `${clampedX}px`;
                placementIndicator.style.top = `${clampedY}px`;
                
                if (isSpawningSpell) {
                    canPlace = true; // Spells can be placed anywhere
                } else {
                    canPlace = checkPlacement(clampedX, clampedY, placementRadius, selectedSpawningUnit.type);
                }
                placementIndicator.classList.toggle('cant-place', !canPlace);
            }
            
            // Re-bind mouse/touch move to window to allow dragging off canvas
            window.addEventListener('mousemove', handleDragMove);
            window.addEventListener('touchmove', handleDragMove, { passive: false });

            // This is the "click-to-place" on the canvas
            canvas.addEventListener('click', (e) => {
                if (selectedSpawningUnit && !isDraggingCard) {
                    handleDragEnd(e); // Treat this "click" as the placement
                }
            });

            // This function is now called by EITHER:
            // 1. A mouseup/touchend (a drag)
            // 2. A click on the canvas (a click-to-place)
            function handleDragEnd(e) {
                
                if (!selectedSpawningUnit || !gameRunning) {
                    cancelPlacement();
                    return;
                };

                // NEW: Check if the event happened over the canvas
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) { 
                    clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; 
                } else if (e.changedTouches && e.changedTouches.length > 0) { 
                    clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; 
                } else { 
                    clientX = e.clientX; clientY = e.clientY; 
                }
                
                const isOverCanvas = (clientX >= rect.left && clientX <= rect.right &&
                                      clientY >= rect.top && clientY <= rect.bottom);

                // If the drag/click ended off-canvas, or it's an invalid placement
                if (!isOverCanvas || !canPlace) {
                    console.log("Cannot spawn there (off-canvas or invalid)!");
                    cancelPlacement();
                    return;
                }
                
                const { x, y } = getCanvasClickPos(e); // This is now safe to call
                const clampedX = Math.max(0, Math.min(WIDTH, x));
                const clampedY = Math.max(0, Math.min(HEIGHT, y));
                
                const card = allCards[selectedSpawningUnit.id];
                const level = cardCollection[selectedSpawningUnit.id] ? cardCollection[selectedSpawningUnit.id].level : 1;
                
                if (card.type === 'Spell') {
                    const damage = card.stats[level].damage;
                    gameObjects.push(new Spell(clampedX, clampedY, 'player', damage, card.radius, card.emoji));
                } else {
                    const newUnit = new card.unitClass(clampedX, clampedY, 'player', level);
                    if (!card.type.includes('Swarm') && !card.type.includes('Building')) {
                        gameObjects.push(newUnit);
                    }
                }
                
                playCard(selectedSpawningUnit.id, selectedSpawningUnit.handIndex);
                cancelPlacement();
            }

            // Use mouseup/touchend on the *window* to catch drags released off-canvas
            window.addEventListener('mouseup', (e) => {
                if (isDraggingCard) {
                    // This was a drag, so let handleDragEnd logic run
                    handleDragEnd(e);
                }
                // If it wasn't a drag (!isDraggingCard), this mouseup does nothing.
                // The 'click' listener on the canvas will handle the placement.
                
                // We must always reset drag state on mouseup
                isDraggingCard = false;
                cardClickStartPos = null;
            });
            window.addEventListener('touchend', (e) => {
                 if (isDraggingCard) {
                    // This was a drag, so let handleDragEnd logic run
                    handleDragEnd(e);
                }
                // If it wasn't a drag (!isDraggingCard), this touchend does nothing.
                // The 'click' listener on the canvas will handle the placement.
                
                // We must always reset drag state on touchend
                isDraggingCard = false;
                cardClickStartPos = null;
            }, { passive: false });

            cardInfoCloseBtn.addEventListener('click', closeModal);
            
            // --- Init App ---
            initCardSystem(); // Define all cards
            onAuthStateChanged(auth, handleAuth); // Wait for user login
        };

    </script>
</body>
</html>
